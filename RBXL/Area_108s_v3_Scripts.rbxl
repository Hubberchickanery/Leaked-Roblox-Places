<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4"><External>null</External><External>nil</External><Item class="Folder" referent="RBX1"><Properties><string name="Name">Game Scripts</string></Properties><Item class="Folder" referent="RBX4"><Properties><string name="Name">gc'ing wont save you now</string></Properties><Item class="ModuleScript" referent="RBX7"><Properties><string name="Name">Service</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

server = nil
client = nil
Pcall = nil
cPcall = nil
Routine = nil
local ErrorHandler
local RealMethods = {}
local methods = setmetatable({}, {
	__index = function(tab, index)
		return function(obj, ...)
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX12"><Properties><string name="Name">cl_circles</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

function CircleClick(Button, X, Y)
	coroutine.resume(coroutine.create(function()
		Button.ClipsDescendants = true
		local Circle = script:WaitForChild("Circle"):Clone()
		local Sound = script:WaitForChild("Sound"):Clone()
		Circle.Parent = Button
		Sound.Parent = Button
		Sound:Play()
		local NewX = X - Circle.AbsolutePosition.X
		local NewY = Y - Circle.AbsolutePosition.Y
		Circle.Position = UDim2.new(0, NewX, 0, NewY)
		local Size = 0
		if Button.AbsoluteSize.Y < Button.AbsoluteSize.X then
			Size = Button.AbsoluteSize.X * 1.5
		elseif Button.AbsoluteSize.X < Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.Y * 1.5
		elseif Button.AbsoluteSize.X == Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.X * 1.5
		end
		local Time = 0.3
		Circle:TweenSizeAndPosition(UDim2.new(0, Size, 0, Size), UDim2.new(0.5, -Size / 2, 0.5, -Size / 2), "Out", "Quad", Time, false, nil)
		local toTween = Circle.ImageTransparency
		for i = 1, 10 do
			Circle.ImageTransparency = 1 - toTween + toTween / 1 * (i / 10)
			wait(Time / 10)
		end
		Circle:Destroy()
		Sound:Destroy()
	end))
end
return CircleClick
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX17"><Properties><string name="Name">HelpButton</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

client = nil
cPcall = nil
Pcall = nil
Routine = nil
service = nil
gTable = nil
return function(data)
	local playergui = service.PlayerGui
	local localplayer = service.Players.LocalPlayer
	local gui = service.New("ScreenGui")
	local toggle = service.New("ImageButton", gui)
	local gTable = client.UI.Register(gui)
	if client.UI.Get("HelpButton", gui, true) then
		gui:Destroy()
		gTable:Destroy()
		return nil
	end
	gTable.Name = "HelpButton"
	gTable.CanKeepAlive = false
	toggle.Name = "Toggle"
	toggle.BackgroundTransparency = 1
	toggle.Position = UDim2.new(1, -45, 1, -45)
	toggle.Size = UDim2.new(0, 40, 0, 40)
	toggle.Image = "rbxassetid://357249130"
	toggle.ImageTransparency = 0.5
	toggle.MouseButton1Down:connect(function()
		local found = client.UI.Get("UserPanel", nil, true)
		if found then
			found.Object:Destroy()
		else
			client.UI.Make("UserPanel", {})
		end
	end)
	gTable:Ready()
end
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX22"><Properties><string name="Name">Client: Example Plugin</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

client = nil
service = nil
return function()
end
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX27"><Properties><string name="Name">Client</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

math.randomseed(os.time())
local _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay = _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay
local unique = {}
local origEnv = getfenv()
setfenv(1, setmetatable({}, {__metatable = unique}))
local origWarn = warn
local startTime = tick()
local clientLocked = false
local oldInstNew = Instance.new
local oldReq = require
local Folder
local locals = {}
local client = {}
local Queues = {}
local service = {}
local RbxEvents = {}
local Debounces = {}
local LoopQueue = {}
local RealMethods = {}
local RunningLoops = {}
local HookedEvents = {}
local WaitingEvents = {}
local ServiceSpecific = {}
local ServiceVariables = {}
local function isModule(module)
	for ind, modu in next, client.Modules, nil do
		if rawequal(module, modu) then
			return true
		end
	end
end
local function logError(err)
	warn("ERROR:" .. tostring(err))
	if client and client.Remote then
		client.Remote.Send("LogError", err)
	end
end
local function message(...)
	game:GetService("TestService"):Message(...)
end
local function print(...)
	for i, v in next, {
		...
	}, nil do
		print(":: Adonis :: " .. tostring(v))
	end
end
local function warn(...)
	for i, v in next, {
		...
	}, nil do
		warn(tostring(v))
	end
end
local function cPcall(func, ...)
	local function cour(...)
		coroutine.resume(coroutine.create(func), ...)
	end
	local ran, error = ypcall(cour, ...)
	if error then
		print(error)
		logError(error)
		warn("ERROR :: " .. error)
	end
end
local function Pcall(func, ...)
	local ran, error = ypcall(func, ...)
	if error then
		logError(error)
	end
end
local function Routine(func, ...)
	coroutine.resume(coroutine.create(func), ...)
end
local function sortedPairs(t, f)
	local a = {}
	for n in next, t, nil do
		table.insert(a, n)
	end
	table.sort(a, f)
	local i = 0
	local function iter()
		i = i + 1
		if a[i] == nil then
			return nil
		else
			return a[i], t[a[i]]
		end
	end
	return iter
end
local player = game:GetService("Players").LocalPlayer
local Fire, Detected
local wrap = coroutine.wrap
local function Kill(info)
	wrap(function()
		pcall(function()
			if Detected then
				Detected("kick", info)
			elseif Fire then
				Fire("BadMemes", info)
			end
		end)
	end)()
	wrap(function()
		pcall(function()
			wait(1)
			service.Player:Kick(info)
		end)
	end)()
	wrap(function()
		pcall(function()
			wait(5)
			while true do
				pcall(spawn, function()
					spawn(Kill)
				end)
			end
		end)
	end)()
end
local GetEnv
function GetEnv(env, repl)
	local scriptEnv = setmetatable({}, {
		__index = function(tab, ind)
			return locals[ind] or (env or origEnv)[ind]
		end,
		__metatable = unique
	})
	if repl and type(repl) == "table" then
		for ind, val in next, repl, nil do
			scriptEnv[ind] = val
		end
	end
	return scriptEnv
end
local function LoadModule(plugin, yield, envVars)
	local plug = require(plugin)
	if type(plug) == "function" then
		if yield then
			local ran, err = service.TrackTask("Plugin: " .. tostring(plugin), setfenv(plug, GetEnv(getfenv(plug), envVars)))
			if not ran then
				warn("Module encountered an error while loading: " .. tostring(plugin))
				warn(tostring(err))
			end
		else
			local ran, err = service.TrackTask("Thread: Plugin: " .. tostring(plugin), setfenv(plug, GetEnv(getfenv(plug), envVars)))
			if not ran then
				warn("Module encountered an error while loading: " .. tostring(plugin))
				warn(tostring(err))
			end
		end
	else
		client[plugin.Name] = plug
	end
end
client = {
	Handlers = {},
	Modules = {},
	Service = service,
	Module = script,
	Print = print,
	Warn = warn,
	Deps = {},
	Pcall = Pcall,
	cPcall = cPcall,
	Routine = Routine,
	LogError = logError,
	TestEvent = Instance.new("RemoteEvent"),
	Disconnect = function(info)
		service.Player:Kick(info or "Disconnected from server")
		wait(30)
		client.Kill(info)
	end,
	Kill = Kill
}
locals = {
	Pcall = Pcall,
	Folder = Folder,
	GetEnv = GetEnv,
	cPcall = cPcall,
	client = client,
	Routine = Routine,
	service = service,
	logError = logError,
	sortedPairs = sortedPairs,
	origEnv = origEnv
}
service = setfenv(require(script.Parent.Core.Service), GetEnv(nil, {client = client}))(function(eType, msg, desc, ...)
	local extra = {
		...
	}
	if eType == "MethodError" and service.Detected then
		Kill("Shananigans denied")
	elseif eType == "ServerError" then
		logError("Client", msg)
	elseif eType == "ReadError" then
		Kill(tostring(msg))
	end
end, function(c, parent, tab)
	if not isModule(c) and c ~= script and c ~= Folder and parent == nil then
		tab.UnHook()
	end
end, ServiceSpecific)
os = service.Localize(os)
math = service.Localize(math)
table = service.Localize(table)
string = service.Localize(string)
coroutine = service.Localize(coroutine)
Instance = service.Localize(Instance)
Vector2 = service.Localize(Vector2)
Vector3 = service.Localize(Vector3)
CFrame = service.Localize(CFrame)
UDim2 = service.Localize(UDim2)
UDim = service.Localize(UDim)
Ray = service.Localize(Ray)
Rect = service.Localize(Rect)
Faces = service.Localize(Faces)
Color3 = service.Localize(Color3)
NumberRange = service.Localize(NumberRange)
NumberSequence = service.Localize(NumberSequence)
NumberSequenceKeypoint = service.Localize(NumberSequenceKeypoint)
ColorSequenceKeypoint = service.Localize(ColorSequenceKeypoint)
PhysicalProperties = service.Localize(PhysicalProperties)
ColorSequence = service.Localize(ColorSequence)
Region3int16 = service.Localize(Region3int16)
Vector3int16 = service.Localize(Vector3int16)
BrickColor = service.Localize(BrickColor)
TweenInfo = service.Localize(TweenInfo)
Axes = service.Localize(Axes)
for i, val in next, service, nil do
	if type(val) == "userdata" then
		service[i] = service.Wrap(val, true)
	end
end
pcall(function()
	return service.Player.Kick
end)
script = service.Wrap(script, true)
Enum = service.Wrap(Enum, true)
game = service.Wrap(game, true)
rawequal = service.RawEqual
workspace = service.Wrap(workspace, true)
Instance = {
	new = function(obj, parent)
		return service.Wrap(oldInstNew(obj, service.UnWrap(parent)), true)
	end
}
function require(obj)
	return service.Wrap(oldReq(service.UnWrap(obj)), true)
end
client.Service = service
client.Module = service.Wrap(client.Module, true)
for ind, loc in next, {
	_G = _G,
	game = game,
	script = script,
	getfenv = getfenv,
	setfenv = setfenv,
	workspace = workspace,
	getmetatable = getmetatable,
	setmetatable = setmetatable,
	loadstring = loadstring,
	coroutine = coroutine,
	rawequal = rawequal,
	typeof = typeof,
	print = print,
	math = math,
	warn = warn,
	error = error,
	pcall = pcall,
	ypcall = ypcall,
	xpcall = xpcall,
	select = select,
	rawset = rawset,
	rawget = rawget,
	ipairs = ipairs,
	pairs = pairs,
	next = next,
	Rect = Rect,
	Axes = Axes,
	os = os,
	tick = tick,
	Faces = Faces,
	delay = delay,
	unpack = unpack,
	string = string,
	Color3 = Color3,
	newproxy = newproxy,
	tostring = tostring,
	tonumber = tonumber,
	Instance = Instance,
	TweenInfo = TweenInfo,
	BrickColor = BrickColor,
	NumberRange = NumberRange,
	ColorSequence = ColorSequence,
	NumberSequence = NumberSequence,
	ColorSequenceKeypoint = ColorSequenceKeypoint,
	NumberSequenceKeypoint = NumberSequenceKeypoint,
	PhysicalProperties = PhysicalProperties,
	Region3int16 = Region3int16,
	Vector3int16 = Vector3int16,
	elapsedTime = elapsedTime,
	require = require,
	table = table,
	type = type,
	wait = wait,
	Enum = Enum,
	UDim = UDim,
	UDim2 = UDim2,
	Vector2 = Vector2,
	Vector3 = Vector3,
	Region3 = Region3,
	CFrame = CFrame,
	Ray = Ray,
	service = service
}, nil do
	locals[ind] = loc
end
return service.NewProxy({
	__metatable = "Adonis",
	__tostring = function()
		return "Adonis"
	end,
	__call = function(tab, data)
		local folder = script.Parent
		local remoteName, depsName = string.match(data.Name, "(.*)\\(.*)")
		Folder = folder:Clone()
		setfenv(1, setmetatable({}, {__metatable = unique}))
		client.Loader = data.Loader
		client.Module = data.Module
		client.DepsName = depsName
		client.TrueStart = data.Start
		client.LoadingTime = data.LoadingTime
		client.RemoteName = remoteName
		folder:Destroy()
		script:Destroy()
		for ind, serv in next, {
			"Workspace",
			"Players",
			"Lighting",
			"ReplicatedStorage",
			"ReplicatedFirst",
			"ScriptContext",
			"JointsService",
			"LogService",
			"Teams",
			"SoundService",
			"StarterGui",
			"StarterPack",
			"StarterPlayers",
			"TestService",
			"NetworkClient"
		}, nil do
			local temp = service[serv]
		end
		local LoadOrder = {
			"Variables",
			"UI",
			"Core",
			"Remote",
			"Functions",
			"Process",
			"Anti"
		}
		for ind, load in next, LoadOrder, nil do
			local modu = Folder.Core:FindFirstChild(load)
			if modu then
				LoadModule(modu, true, {script = script})
			end
		end
		for i, name in next, LoadOrder, nil do
			local core = client[name]
			if core and type(core) == "table" and core.Init then
				core.Init()
				core.Init = nil
			elseif type(core) == "userdata" and getmetatable(core) == "ReadOnly_Table" and core.Init then
				core.Init()
			end
		end
		for ind, obj in next, Folder.Dependencies:GetChildren() do
			client.Deps[obj.Name] = obj
		end
		for index, plugin in next, Folder.Plugins:GetChildren() do
			LoadModule(plugin, nil, {script = plugin})
		end
		ServiceSpecific.Player = service.Players.LocalPlayer
		ServiceSpecific.PlayerGui = service.Player:FindFirstChild("PlayerGui")
		function ServiceSpecific.SafeTweenSize(obj, ...)
			pcall(obj.TweenSize, obj, ...)
		end
		function ServiceSpecific.SafeTweenPos(obj, ...)
			pcall(obj.TweenPosition, obj, ...)
		end
		function ServiceSpecific.Filter(str, from, to)
			return client.Remote.Get("Filter", str, to and from or service.Player, to or from)
		end
		function ServiceSpecific.LaxFilter(str, from)
			return service.Filter(str, from or service.Player, from or service.Player)
		end
		function ServiceSpecific.BroadcastFilter(str, from)
			return client.Remote.Get("BroadcastFilter", str, from or service.Player)
		end
		function ServiceSpecific.IsMobile()
			if service.UserInputService.TouchEnabled and not service.UserInputService.MouseEnabled and not service.UserInputService.KeyboardEnabled then
				return true
			else
				return false
			end
		end
		function ServiceSpecific.LocalContainer()
			if not client.Variables.LocalContainer or not client.Variables.LocalContainer.Parent then
				client.Variables.LocalContainer = service.New("Camera")
				client.Variables.LocalContainer.Name = client.Functions.GetRandom()
				client.Variables.LocalContainer.Parent = service.Workspace
			end
			return client.Variables.LocalContainer
		end
		function client.Finish_Loading()
			if client.Core.Key then
				service.NetworkClient.ChildRemoved:Connect(function()
					wait(30)
					client.Anti.Detected("crash", "Network client disconnected")
				end)
				service.NetworkClient.ChildAdded:Connect(function()
					client.Anti.Detected("crash", "Network client reconnected?")
				end)
				service.Player.Changed:Connect(function()
					if service.Player.Parent ~= service.Players then
						wait(5)
						client.Anti.Detected("kick", "Parent not players")
					elseif client.Anti.RLocked(service.Player) then
						client.Anti.Detected("kick", "Roblox Locked")
					end
				end)
				service.Player.Chatted:Connect(service.EventTask("Event: ProcessChat", client.Process.Chat))
				service.Player.CharacterRemoving:Connect(service.EventTask("Event: CharacterRemoving", client.Process.CharacterRemoving))
				service.Player.CharacterAdded:Connect(service.Threads.NewEventTask("Event: CharacterAdded", client.Process.CharacterAdded))
				service.LogService.MessageOut:Connect(client.Process.LogService)
				service.ScriptContext.Error:Connect(client.Process.ErrorMessage)
				client.Variables.CodeName = client.Remote.Get("Variable", "CodeName")
				client.Remote.Send("ClientLoaded")
				delay(5, function()
					service.StartLoop("ClientCheck", 30, client.Core.CheckClient, true)
				end)
				local settings = client.Remote.Get("Setting", {
					"G_API",
					"G_Access",
					"G_Access_Key",
					"G_Access_Perms",
					"Allowed_API_Calls"
				})
				client.G_API = settings.G_API
				client.G_Access = settings.G_Access
				client.G_Access_Key = settings.G_Access_Key
				client.G_Access_Perms = settings.G_Access_Perms
				client.Allowed_API_Calls = settings.Allowed_API_Calls
				if service.NetworkClient then
					service.TrackTask("Thread: API Manager", client.Core.StartAPI)
				end
				clientLocked = true
				function client.Finish_Loading()
				end
				client.LoadingTime()
			else
				client.Kill("Missing remote key")
			end
		end
		Fire = client.Remote.Fire
		Detected = client.Anti.Detected
		client.Core.Name = "\000"
		client.Core.Special = depsName
		client = service.ReadOnly(client, {
			[client.Variables] = true,
			[client.Handlers] = true,
			G_API = true,
			G_Access = true,
			G_Access_Key = true,
			G_Access_Perms = true,
			Allowed_API_Calls = true,
			Finish_Loading = true,
			RemoteEvent = true,
			ScriptCache = true,
			Returns = true,
			PendingReturns = true,
			EncodeCache = true,
			DecodeCache = true,
			Received = true,
			Sent = true,
			Service = true,
			Holder = true,
			GUIs = true,
			LastUpdate = true
		}, true)
		client.Core.GetEvent()
		return "SUCCESS"
	end
})
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX32"><Properties><string name="Name">ControlModule</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ControlModule = {}
ControlModule.__index = ControlModule
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local Keyboard = require(script:WaitForChild("Keyboard"))
local Gamepad = require(script:WaitForChild("Gamepad"))
local TouchDPad = require(script:WaitForChild("TouchDPad"))
local DynamicThumbstick = require(script:WaitForChild("DynamicThumbstick"))
local ClickToMove = require(script:WaitForChild("ClickToMoveController"))
local TouchThumbstick = require(script:WaitForChild("TouchThumbstick"))
local TouchThumbpad = require(script:WaitForChild("TouchThumbpad"))
local TouchJump = require(script:WaitForChild("TouchJump"))
local VehicleController = require(script:WaitForChild("VehicleController"))
local CONTROL_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
local movementEnumToModuleMap = {
	[Enum.TouchMovementMode.DPad] = TouchDPad,
	[Enum.DevTouchMovementMode.DPad] = TouchDPad,
	[Enum.TouchMovementMode.Thumbpad] = TouchThumbpad,
	[Enum.DevTouchMovementMode.Thumbpad] = TouchThumbpad,
	[Enum.TouchMovementMode.Thumbstick] = TouchThumbstick,
	[Enum.DevTouchMovementMode.Thumbstick] = TouchThumbstick,
	[Enum.TouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
	[Enum.DevTouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
	[Enum.TouchMovementMode.ClickToMove] = ClickToMove,
	[Enum.DevTouchMovementMode.ClickToMove] = ClickToMove,
	[Enum.TouchMovementMode.Default] = DynamicThumbstick,
	[Enum.ComputerMovementMode.Default] = Keyboard,
	[Enum.ComputerMovementMode.KeyboardMouse] = Keyboard,
	[Enum.DevComputerMovementMode.KeyboardMouse] = Keyboard,
	[Enum.DevComputerMovementMode.Scriptable] = nil,
	[Enum.ComputerMovementMode.ClickToMove] = ClickToMove,
	[Enum.DevComputerMovementMode.ClickToMove] = ClickToMove
}
local computerInputTypeToModuleMap = {
	[Enum.UserInputType.Keyboard] = Keyboard,
	[Enum.UserInputType.MouseButton1] = Keyboard,
	[Enum.UserInputType.MouseButton2] = Keyboard,
	[Enum.UserInputType.MouseButton3] = Keyboard,
	[Enum.UserInputType.MouseWheel] = Keyboard,
	[Enum.UserInputType.MouseMovement] = Keyboard,
	[Enum.UserInputType.Gamepad1] = Gamepad,
	[Enum.UserInputType.Gamepad2] = Gamepad,
	[Enum.UserInputType.Gamepad3] = Gamepad,
	[Enum.UserInputType.Gamepad4] = Gamepad
}
function ControlModule.new()
	local self = setmetatable({}, ControlModule)
	self.controllers = {}
	self.activeControlModule = nil
	self.activeController = nil
	self.touchJumpController = nil
	self.moveFunction = Players.LocalPlayer.Move
	self.humanoid = nil
	self.lastInputType = Enum.UserInputType.None
	self.cameraRelative = true
	self.humanoidSeatedConn = nil
	self.vehicleController = nil
	self.touchControlFrame = nil
	self.vehicleController = VehicleController.new(CONTROL_ACTION_PRIORITY)
	Players.LocalPlayer.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char)
	end)
	Players.LocalPlayer.CharacterRemoving:Connect(function(char)
		self:OnCharacterAdded(char)
	end)
	if Players.LocalPlayer.Character then
		self:OnCharacterAdded(Players.LocalPlayer.Character)
	end
	RunService:BindToRenderStep("ControlScriptRenderstep", Enum.RenderPriority.Input.Value, function(dt)
		self:OnRenderStepped(dt)
	end)
	UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
		self:OnLastInputTypeChanged(newLastInputType)
	end)
	local propertyChangeListeners = {
		UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
			self:OnTouchMovementModeChange()
		end),
		Players.LocalPlayer:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
			self:OnTouchMovementModeChange()
		end),
		UserGameSettings:GetPropertyChangedSignal("ComputerMovementMode"):Connect(function()
			self:OnComputerMovementModeChange()
		end),
		Players.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
			self:OnComputerMovementModeChange()
		end)
	}
	self.playerGui = nil
	self.touchGui = nil
	self.playerGuiAddedConn = nil
	if UserInputService.TouchEnabled then
		self.playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
		if self.playerGui then
			self:CreateTouchGuiContainer()
			self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
		else
			self.playerGuiAddedConn = Players.LocalPlayer.ChildAdded:Connect(function(child)
				if child:IsA("PlayerGui") then
					self.playerGui = child
					self:CreateTouchGuiContainer()
					self.playerGuiAddedConn:Disconnect()
					self.playerGuiAddedConn = nil
					self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
				end
			end)
		end
	else
		self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
	end
	return self
end
function ControlModule:GetMoveVector()
	if self.activeController then
		return self.activeController:GetMoveVector()
	end
	return Vector3.new(0, 0, 0)
end
function ControlModule:GetActiveController()
	return self.activeController
end
function ControlModule:EnableActiveControlModule()
	if self.activeControlModule == ClickToMove then
		self.activeController:Enable(true, Players.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice, self.touchJumpController)
	elseif self.touchControlFrame then
		self.activeController:Enable(true, self.touchControlFrame)
	else
		self.activeController:Enable(true)
	end
end
function ControlModule:Enable(enable)
	if not self.activeController then
		return
	end
	if enable == nil then
		enable = true
	end
	if enable then
		self:EnableActiveControlModule()
	else
		self:Disable()
	end
end
function ControlModule:Disable()
	if self.activeController then
		self.activeController:Enable(false)
		if self.moveFunction then
			self.moveFunction(Players.LocalPlayer, Vector3.new(0, 0, 0), self.cameraRelative)
		end
	end
end
function ControlModule:SelectComputerMovementModule()
	if not UserInputService.KeyboardEnabled and not UserInputService.GamepadEnabled then
		return nil, false
	end
	local computerModule
	local DevMovementMode = Players.LocalPlayer.DevComputerMovementMode
	if DevMovementMode == Enum.DevComputerMovementMode.UserChoice then
		computerModule = computerInputTypeToModuleMap[lastInputType]
		if UserGameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove and computerModule == Keyboard then
			computerModule = ClickToMove
		end
	else
		computerModule = movementEnumToModuleMap[DevMovementMode]
		if not computerModule and DevMovementMode ~= Enum.DevComputerMovementMode.Scriptable then
			warn("No character control module is associated with DevComputerMovementMode ", DevMovementMode)
		end
	end
	if computerModule then
		return computerModule, true
	elseif DevMovementMode == Enum.DevComputerMovementMode.Scriptable then
		return nil, true
	else
		return nil, false
	end
end
function ControlModule:SelectTouchModule()
	if not UserInputService.TouchEnabled then
		return nil, false
	end
	local touchModule
	local DevMovementMode = Players.LocalPlayer.DevTouchMovementMode
	if DevMovementMode == Enum.DevTouchMovementMode.UserChoice then
		touchModule = movementEnumToModuleMap[UserGameSettings.TouchMovementMode]
	elseif DevMovementMode == Enum.DevTouchMovementMode.Scriptable then
		return nil, true
	else
		touchModule = movementEnumToModuleMap[DevMovementMode]
	end
	return touchModule, true
end
function ControlModule:OnRenderStepped(dt)
	if self.activeController and self.activeController.enabled and self.humanoid then
		local moveVector = self.activeController:GetMoveVector()
		local vehicleConsumedInput = false
		if self.vehicleController then
			moveVector, vehicleConsumedInput = self.vehicleController:Update(moveVector, self.activeControlModule == Gamepad)
		end
		self.moveFunction(Players.LocalPlayer, moveVector, self.cameraRelative)
		self.humanoid.Jump = not self.activeController:GetIsJumping() and self.touchJumpController and self.touchJumpController:GetIsJumping()
	end
end
function ControlModule:OnHumanoidSeated(active, currentSeatPart)
	if active then
		if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
			if not self.vehicleController then
				self.vehicleController = self.vehicleController.new(CONTROL_ACTION_PRIORITY)
			end
			self.vehicleController:Enable(true, currentSeatPart)
		end
	elseif self.vehicleController then
		self.vehicleController:Enable(false, currentSeatPart)
	end
end
function ControlModule:OnCharacterAdded(char)
	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	while not self.humanoid do
		char.ChildAdded:wait()
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
	end
	if self.humanoidSeatedConn then
		self.humanoidSeatedConn:Disconnect()
		self.humanoidSeatedConn = nil
	end
	self.humanoidSeatedConn = self.humanoid.Seated:Connect(function(active, currentSeatPart)
		self:OnHumanoidSeated(active, currentSeatPart)
	end)
end
function ControlModule:OnCharacterRemoving(char)
	self.humanoid = nil
end
function ControlModule:SwitchToController(controlModule)
	if not controlModule then
		if self.activeController then
			self.activeController:Enable(false)
		end
		self.activeController = nil
		self.activeControlModule = nil
	else
		if not self.controllers[controlModule] then
			self.controllers[controlModule] = controlModule.new(CONTROL_ACTION_PRIORITY)
		end
		if self.activeController ~= self.controllers[controlModule] then
			if self.activeController then
				self.activeController:Enable(false)
			end
			self.activeController = self.controllers[controlModule]
			self.activeControlModule = controlModule
			if self.touchControlFrame and (self.activeControlModule == TouchThumbpad or self.activeControlModule == TouchThumbstick or self.activeControlModule == ClickToMove or self.activeControlModule == DynamicThumbstick) then
				if not self.controllers[TouchJump] then
					self.controllers[TouchJump] = TouchJump.new()
				end
				self.touchJumpController = self.controllers[TouchJump]
				self.touchJumpController:Enable(true, self.touchControlFrame)
			elseif self.touchJumpController then
				self.touchJumpController:Enable(false)
			end
			self:EnableActiveControlModule()
		end
	end
end
function ControlModule:OnLastInputTypeChanged(newLastInputType)
	if lastInputType == newLastInputType then
		warn("LastInputType Change listener called with current type.")
	end
	lastInputType = newLastInputType
	if lastInputType == Enum.UserInputType.Touch then
		local touchModule, success = self:SelectTouchModule()
		if success then
			while not self.touchControlFrame do
				wait()
			end
			self:SwitchToController(touchModule)
		end
	elseif computerInputTypeToModuleMap[lastInputType] ~= nil then
		local computerModule = self:SelectComputerMovementModule()
		if computerModule then
			self:SwitchToController(computerModule)
		end
	end
end
function ControlModule:OnComputerMovementModeChange()
	local controlModule, success = self:SelectComputerMovementModule()
	if success then
		self:SwitchToController(controlModule)
	end
end
function ControlModule:OnTouchMovementModeChange()
	local touchModule, success = self:SelectTouchModule()
	if success then
		while not self.touchControlFrame do
			wait()
		end
		self:SwitchToController(touchModule)
	end
end
function ControlModule:CreateTouchGuiContainer()
	if self.touchGui then
		self.touchGui:Destroy()
	end
	self.touchGui = Instance.new("ScreenGui")
	self.touchGui.Name = "TouchGui"
	self.touchGui.ResetOnSpawn = false
	self.touchControlFrame = Instance.new("Frame")
	self.touchControlFrame.Name = "TouchControlFrame"
	self.touchControlFrame.Size = UDim2.new(1, 0, 1, 0)
	self.touchControlFrame.BackgroundTransparency = 1
	self.touchControlFrame.Parent = self.touchGui
	self.touchGui.Parent = self.playerGui
end
function ControlModule:GetClickToMoveController()
	if not self.controllers[ClickToMove] then
		self.controllers[ClickToMove] = ClickToMove.new(CONTROL_ACTION_PRIORITY)
	end
	return self.controllers[ClickToMove]
end
return ControlModule.new()
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX37"><Properties><string name="Name">PlayerModule</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local PlayerModule = {}
PlayerModule.__index = PlayerModule
function PlayerModule.new()
	local self = setmetatable({}, PlayerModule)
	self.cameras = require(script:WaitForChild("CameraModule"))
	self.controls = require(script:WaitForChild("ControlModule"))
	return self
end
function PlayerModule:GetCameras()
	return self.cameras
end
function PlayerModule:GetControls()
	return self.controls
end
function PlayerModule:GetClickToMoveController()
	return self.controls:GetClickToMoveController()
end
return PlayerModule.new()
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX42"><Properties><string name="Name">VehicleController</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local useTriggersForThrottle = true
local onlyTriggersForThrottle = false
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local VehicleController = {}
VehicleController.__index = VehicleController
function VehicleController.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable({}, VehicleController)
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	self.enabled = false
	self.vehicleSeat = nil
	self.throttle = 0
	self.steer = 0
	self.acceleration = 0
	self.decceleration = 0
	self.turningRight = 0
	self.turningLeft = 0
	self.vehicleMoveVector = ZERO_VECTOR3
	return self
end
function VehicleController:BindContextActions()
	if useTriggersForThrottle then
		ContextActionService:BindActionAtPriority("throttleAccel", function(actionName, inputState, inputObject)
			self:OnThrottleAccel(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonR2)
		ContextActionService:BindActionAtPriority("throttleDeccel", function(actionName, inputState, inputObject)
			self:OnThrottleDeccel(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonL2)
	end
	ContextActionService:BindActionAtPriority("arrowSteerRight", function(actionName, inputState, inputObject)
		self:OnSteerRight(actionName, inputState, inputObject)
		return Enum.ContextActionResult.Pass
	end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Right)
	ContextActionService:BindActionAtPriority("arrowSteerLeft", function(actionName, inputState, inputObject)
		self:OnSteerLeft(actionName, inputState, inputObject)
		return Enum.ContextActionResult.Pass
	end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Left)
end
function VehicleController:Enable(enable, vehicleSeat)
	if enable == self.enabled and vehicleSeat == self.vehicleSeat then
		return
	end
	self.vehicleMoveVector = ZERO_VECTOR3
	if enable then
		if vehicleSeat then
			self.vehicleSeat = vehicleSeat
			if FFlagPlayerScriptsBindAtPriority2 then
				self:BindContextActions()
			else
				if useTriggersForThrottle then
					ContextActionService:BindAction("throttleAccel", function(actionName, inputState, inputObject)
						self:OnThrottleAccel(actionName, inputState, inputObject)
						return Enum.ContextActionResult.Pass
					end, false, Enum.KeyCode.ButtonR2)
					ContextActionService:BindAction("throttleDeccel", function(actionName, inputState, inputObject)
						self:OnThrottleDeccel(actionName, inputState, inputObject)
						return Enum.ContextActionResult.Pass
					end, false, Enum.KeyCode.ButtonL2)
				end
				ContextActionService:BindAction("arrowSteerRight", function(actionName, inputState, inputObject)
					self:OnSteerRight(actionName, inputState, inputObject)
					return Enum.ContextActionResult.Pass
				end, false, Enum.KeyCode.Right)
				ContextActionService:BindAction("arrowSteerLeft", function(actionName, inputState, inputObject)
					self:OnSteerLeft(actionName, inputState, inputObject)
					return Enum.ContextActionResult.Pass
				end, false, Enum.KeyCode.Left)
			end
		end
	else
		if useTriggersForThrottle then
			ContextActionService:UnbindAction("throttleAccel")
			ContextActionService:UnbindAction("throttleDeccel")
		end
		ContextActionService:UnbindAction("arrowSteerRight")
		ContextActionService:UnbindAction("arrowSteerLeft")
		self.vehicleSeat = nil
	end
end
function VehicleController:OnThrottleAccel(actionName, inputState, inputObject)
	self.acceleration = inputState ~= Enum.UserInputState.End and -1 or 0
	self.throttle = self.acceleration + self.decceleration
end
function VehicleController:OnThrottleDeccel(actionName, inputState, inputObject)
	self.decceleration = inputState ~= Enum.UserInputState.End and 1 or 0
	self.throttle = self.acceleration + self.decceleration
end
function VehicleController:OnSteerRight(actionName, inputState, inputObject)
	self.turningRight = inputState ~= Enum.UserInputState.End and 1 or 0
	self.steer = self.turningRight + self.turningLeft
end
function VehicleController:OnSteerLeft(actionName, inputState, inputObject)
	self.turningLeft = inputState ~= Enum.UserInputState.End and -1 or 0
	self.steer = self.turningRight + self.turningLeft
end
function VehicleController:Update(moveVector, usingGamepad)
	if self.vehicleSeat then
		moveVector = moveVector + Vector3.new(self.steer, 0, self.throttle)
		if usingGamepad and onlyTriggersForThrottle and useTriggersForThrottle then
			self.vehicleSeat.ThrottleFloat = -self.throttle
		else
			self.vehicleSeat.ThrottleFloat = -moveVector.Z
		end
		self.vehicleSeat.SteerFloat = moveVector.X
		return moveVector, true
	end
	return moveVector, false
end
return VehicleController
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX47"><Properties><string name="Name">TouchJump</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchJump = setmetatable({}, BaseCharacterController)
TouchJump.__index = TouchJump
function TouchJump.new()
	local self = setmetatable(BaseCharacterController.new(), TouchJump)
	self.parentUIFrame = nil
	self.jumpButton = nil
	self.characterAddedConn = nil
	self.humanoidStateEnabledChangedConn = nil
	self.humanoidJumpPowerConn = nil
	self.humanoidParentConn = nil
	self.externallyEnabled = false
	self.jumpPower = 0
	self.jumpStateEnabled = true
	self.isJumping = false
	self.humanoid = nil
	return self
end
function TouchJump:EnableButton(enable)
	if enable then
		if not self.jumpButton then
			self:Create()
		end
		local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
		if humanoid and self.externallyEnabled and self.externallyEnabled and humanoid.JumpPower > 0 then
			self.jumpButton.Visible = true
		end
	else
		self.jumpButton.Visible = false
		self.isJumping = false
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	end
end
function TouchJump:UpdateEnabled()
	if self.jumpPower > 0 and self.jumpStateEnabled then
		self:EnableButton(true)
	else
		self:EnableButton(false)
	end
end
function TouchJump:HumanoidChanged(prop)
	local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if prop == "JumpPower" then
			self.jumpPower = humanoid.JumpPower
			self:UpdateEnabled()
		elseif prop == "Parent" and not humanoid.Parent then
			self.humanoidChangeConn:Disconnect()
		end
	end
end
function TouchJump:HumanoidStateEnabledChanged(state, isEnabled)
	if state == Enum.HumanoidStateType.Jumping then
		self.jumpStateEnabled = isEnabled
		self:UpdateEnabled()
	end
end
function TouchJump:CharacterAdded(char)
	if self.humanoidChangeConn then
		self.humanoidChangeConn:Disconnect()
		self.humanoidChangeConn = nil
	end
	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	while not self.humanoid do
		char.ChildAdded:wait()
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
	end
	self.humanoidJumpPowerConn = self.humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
		self.jumpPower = self.humanoid.JumpPower
		self:UpdateEnabled()
	end)
	self.humanoidParentConn = self.humanoid:GetPropertyChangedSignal("Parent"):Connect(function()
		if not self.humanoid.Parent then
			self.humanoidJumpPowerConn:Disconnect()
			self.humanoidJumpPowerConn = nil
			self.humanoidParentConn:Disconnect()
			self.humanoidParentConn = nil
		end
	end)
	self.humanoidStateEnabledChangedConn = self.humanoid.StateEnabledChanged:Connect(function(state, enabled)
		self:HumanoidStateEnabledChanged(state, enabled)
	end)
	self.jumpPower = self.humanoid.JumpPower
	self.jumpStateEnabled = self.humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping)
	self:UpdateEnabled()
end
function TouchJump:SetupCharacterAddedFunction()
	self.characterAddedConn = Players.LocalPlayer.CharacterAdded:Connect(function(char)
		self:CharacterAdded(char)
	end)
	if Players.LocalPlayer.Character then
		self:CharacterAdded(Players.LocalPlayer.Character)
	end
end
function TouchJump:Enable(enable, parentFrame)
	if parentFrame then
		self.parentUIFrame = parentFrame
	end
	self.externallyEnabled = enable
	self:EnableButton(enable)
end
function TouchJump:Create()
	if not self.parentUIFrame then
		return
	end
	if self.jumpButton then
		self.jumpButton:Destroy()
		self.jumpButton = nil
	end
	local minAxis = math.min(self.parentUIFrame.AbsoluteSize.x, self.parentUIFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	local jumpButtonSize = isSmallScreen and 70 or 120
	self.jumpButton = Instance.new("ImageButton")
	self.jumpButton.Name = "JumpButton"
	self.jumpButton.Visible = false
	self.jumpButton.BackgroundTransparency = 1
	self.jumpButton.Image = TOUCH_CONTROL_SHEET
	self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	self.jumpButton.ImageRectSize = Vector2.new(144, 144)
	self.jumpButton.Size = UDim2.new(0, jumpButtonSize, 0, jumpButtonSize)
	self.jumpButton.Position = isSmallScreen and UDim2.new(1, -(jumpButtonSize * 1.5 - 10), 1, -jumpButtonSize - 20) or UDim2.new(1, -(jumpButtonSize * 1.5 - 10), 1, -jumpButtonSize * 1.75)
	local touchObject
	self.jumpButton.InputBegan:connect(function(inputObject)
		if touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		touchObject = inputObject
		self.jumpButton.ImageRectOffset = Vector2.new(146, 146)
		self.isJumping = true
	end)
	local function OnInputEnded()
		touchObject = nil
		self.isJumping = false
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	end
	self.jumpButton.InputEnded:connect(function(inputObject)
		if inputObject == touchObject then
			OnInputEnded()
		end
	end)
	GuiService.MenuOpened:connect(function()
		if touchObject then
			OnInputEnded()
		end
	end)
	if not self.characterAddedConn then
		self:SetupCharacterAddedFunction()
	end
	self.jumpButton.Parent = self.parentUIFrame
end
return TouchJump
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX52"><Properties><string name="Name">DynamicThumbstick</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local TOUCH_CONTROLS_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
local DYNAMIC_THUMBSTICK_ACTION_NAME = "DynamicThumbstickAction"
local DYNAMIC_THUMBSTICK_ACTION_PRIORITY = Enum.ContextActionPriority.High.Value
local MIDDLE_TRANSPARENCIES = {
	0.10999999999999999,
	0.30000000000000004,
	0.4,
	0.5,
	0.6,
	0.7,
	0.75
}
local NUM_MIDDLE_IMAGES = #MIDDLE_TRANSPARENCIES
local FADE_IN_OUT_BACKGROUND = true
local FADE_IN_OUT_MAX_ALPHA = 0.35
local FADE_IN_OUT_HALF_DURATION_DEFAULT = 0.3
local FADE_IN_OUT_BALANCE_DEFAULT = 0.5
local ThumbstickFadeTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local thumbstickUseCASFlagSuccess, thumbstickUseCASFlagValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserDynamicThumbstickUseContextActionSevice")
end)
local FFlagDynamicThumbstickUseContextActionSevice = thumbstickUseCASFlagSuccess and thumbstickUseCASFlagValue
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local DynamicThumbstick = setmetatable({}, BaseCharacterController)
DynamicThumbstick.__index = DynamicThumbstick
function DynamicThumbstick.new()
	local self = setmetatable(BaseCharacterController.new(), DynamicThumbstick)
	self.humanoid = nil
	self.tools = {}
	self.toolEquipped = nil
	self.revertAutoJumpEnabledToFalse = false
	self.moveTouchObject = nil
	self.moveTouchFirstChanged = false
	self.moveTouchStartPosition = nil
	self.startImage = nil
	self.endImage = nil
	self.middleImages = {}
	self.startImageFadeTween = nil
	self.endImageFadeTween = nil
	self.middleImageFadeTweens = {}
	self.isFirstTouch = true
	self.isFollowStick = false
	self.thumbstickFrame = nil
	if not FFlagDynamicThumbstickUseContextActionSevice then
		self.onTouchMovedConn = nil
		self.onTouchEndedConn = nil
		self.onTouchActivateConn = nil
	end
	self.onRenderSteppedConn = nil
	self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
	self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
	self.hasFadedBackgroundInPortrait = false
	self.hasFadedBackgroundInLandscape = false
	self.tweenInAlphaStart = nil
	self.tweenOutAlphaStart = nil
	self.shouldRevertAutoJumpOnDisable = false
	return self
end
function DynamicThumbstick:GetIsJumping()
	local wasJumping = self.isJumping
	self.isJumping = false
	return wasJumping
end
function DynamicThumbstick:EnableAutoJump(enable)
	local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if enable then
			self.shouldRevertAutoJumpOnDisable = humanoid.AutoJumpEnabled == false and Players.LocalPlayer.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice
			humanoid.AutoJumpEnabled = true
		elseif self.shouldRevertAutoJumpOnDisable then
			humanoid.AutoJumpEnabled = false
		end
	end
end
function DynamicThumbstick:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	if enable then
		if not self.thumbstickFrame then
			self:Create(uiParentFrame)
		end
		if FFlagDynamicThumbstickUseContextActionSevice then
			self:BindContextActions()
		end
		if Players.LocalPlayer.Character then
			self:OnCharacterAdded(Players.LocalPlayer.Character)
		else
			Players.LocalPlayer.CharacterAdded:Connect(function(char)
				self:OnCharacterAdded(char)
			end)
		end
	else
		if FFlagDynamicThumbstickUseContextActionSevice then
			ContextActionService:UnbindAction(DYNAMIC_THUMBSTICK_ACTION_NAME)
		end
		self:OnInputEnded()
	end
	self.enabled = enable
	self.thumbstickFrame.Visible = enable
end
function DynamicThumbstick:OnCharacterAdded(char)
	for _, child in ipairs(char:GetChildren()) do
		if child:IsA("Tool") then
			self.toolEquipped = child
		end
	end
	char.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			self.toolEquipped = child
		elseif child:IsA("Humanoid") then
			self:EnableAutoJump(true)
		end
	end)
	char.ChildRemoved:Connect(function(child)
		if child == self.toolEquipped then
			self.toolEquipped = nil
		end
	end)
	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	if self.humanoid then
		self:EnableAutoJump(true)
	end
end
function DynamicThumbstick:OnInputEnded()
	self.moveTouchObject = nil
	self.moveVector = ZERO_VECTOR3
	self:FadeThumbstick(false)
	if not FFlagDynamicThumbstickUseContextActionSevice then
		self.thumbstickFrame.Active = true
	end
end
function DynamicThumbstick:FadeThumbstick(visible)
	if not visible and self.moveTouchObject then
		return
	end
	if self.isFirstTouch then
		return
	end
	if self.startImageFadeTween then
		self.startImageFadeTween:Cancel()
	end
	if self.endImageFadeTween then
		self.endImageFadeTween:Cancel()
	end
	for i = 1, #self.middleImages do
		if self.middleImageFadeTweens[i] then
			self.middleImageFadeTweens[i]:Cancel()
		end
	end
	if visible then
		self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, {ImageTransparency = 0})
		self.startImageFadeTween:Play()
		self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, {ImageTransparency = 0.2})
		self.endImageFadeTween:Play()
		for i = 1, #self.middleImages do
			self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, {
				ImageTransparency = MIDDLE_TRANSPARENCIES[i]
			})
			self.middleImageFadeTweens[i]:Play()
		end
	else
		self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, {ImageTransparency = 1})
		self.startImageFadeTween:Play()
		self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, {ImageTransparency = 1})
		self.endImageFadeTween:Play()
		for i = 1, #self.middleImages do
			self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, {ImageTransparency = 1})
			self.middleImageFadeTweens[i]:Play()
		end
	end
end
function DynamicThumbstick:FadeThumbstickFrame(fadeDuration, fadeRatio)
	self.fadeInAndOutHalfDuration = fadeDuration * 0.5
	self.fadeInAndOutBalance = fadeRatio
	self.tweenInAlphaStart = tick()
end
function DynamicThumbstick:InputInFrame(inputObject)
	local frameCornerTopLeft = self.thumbstickFrame.AbsolutePosition
	local frameCornerBottomRight = frameCornerTopLeft + self.thumbstickFrame.AbsoluteSize
	local inputPosition = inputObject.Position
	if inputPosition.X >= frameCornerTopLeft.X and inputPosition.Y >= frameCornerTopLeft.Y and inputPosition.X <= frameCornerBottomRight.X and inputPosition.Y <= frameCornerBottomRight.Y then
		return true
	end
	return false
end
function DynamicThumbstick:DoFadeInBackground()
	local playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
	local hasFadedBackgroundInOrientation = false
	if playerGui then
		if playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight then
			hasFadedBackgroundInOrientation = self.hasFadedBackgroundInLandscape
			self.hasFadedBackgroundInLandscape = true
		elseif playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait then
			hasFadedBackgroundInOrientation = self.hasFadedBackgroundInPortrait
			self.hasFadedBackgroundInPortrait = true
		end
	end
	if not hasFadedBackgroundInOrientation then
		self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
		self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
		self.tweenInAlphaStart = tick()
	end
end
function DynamicThumbstick:DoMove(direction)
	local currentMoveVector = direction
	local inputAxisMagnitude = currentMoveVector.magnitude
	if inputAxisMagnitude < self.radiusOfDeadZone then
		currentMoveVector = Vector3.new()
	else
		currentMoveVector = currentMoveVector.unit * (1 - math.max(0, (self.radiusOfMaxSpeed - currentMoveVector.magnitude) / self.radiusOfMaxSpeed))
		currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
	end
	self.moveVector = currentMoveVector
end
function DynamicThumbstick:LayoutMiddleImages(startPos, endPos)
	local startDist = self.thumbstickSize / 2 + self.middleSize
	local vector = endPos - startPos
	local distAvailable = vector.magnitude - self.thumbstickRingSize / 2 - self.middleSize
	local direction = vector.unit
	local distNeeded = self.middleSpacing * NUM_MIDDLE_IMAGES
	local spacing = self.middleSpacing
	if distAvailable > distNeeded then
		spacing = distAvailable / NUM_MIDDLE_IMAGES
	end
	for i = 1, NUM_MIDDLE_IMAGES do
		local image = self.middleImages[i]
		local distWithout = startDist + spacing * (i - 2)
		local currentDist = startDist + spacing * (i - 1)
		if distAvailable > distWithout then
			local pos = endPos - direction * currentDist
			local exposedFraction = math.clamp(1 - (currentDist - distAvailable) / spacing, 0, 1)
			image.Visible = true
			image.Position = UDim2.new(0, pos.X, 0, pos.Y)
			image.Size = UDim2.new(0, self.middleSize * exposedFraction, 0, self.middleSize * exposedFraction)
		else
			image.Visible = false
		end
	end
end
function DynamicThumbstick:MoveStick(pos)
	local vector2StartPosition = Vector2.new(self.moveTouchStartPosition.X, self.moveTouchStartPosition.Y)
	local startPos = vector2StartPosition - self.thumbstickFrame.AbsolutePosition
	local endPos = Vector2.new(pos.X, pos.Y) - self.thumbstickFrame.AbsolutePosition
	self.endImage.Position = UDim2.new(0, endPos.X, 0, endPos.Y)
	self:LayoutMiddleImages(startPos, endPos)
end
function DynamicThumbstick:BindContextActions()
	local function inputBegan(inputObject)
		if self.moveTouchObject then
			return Enum.ContextActionResult.Pass
		end
		if not self:InputInFrame(inputObject) then
			return Enum.ContextActionResult.Pass
		end
		if self.isFirstTouch then
			self.isFirstTouch = false
			local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0)
			TweenService:Create(self.startImage, tweenInfo, {
				Size = UDim2.new(0, 0, 0, 0)
			}):Play()
			TweenService:Create(self.endImage, tweenInfo, {
				Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize),
				ImageColor3 = Color3.new(0, 0, 0)
			}):Play()
		end
		self.moveTouchObject = inputObject
		self.moveTouchStartPosition = inputObject.Position
		self.moveTouchFirstChanged = true
		if FADE_IN_OUT_BACKGROUND then
			self:DoFadeInBackground()
		end
		return Enum.ContextActionResult.Pass
	end
	local function inputChanged(inputObject)
		if inputObject == self.moveTouchObject then
			if self.moveTouchFirstChanged then
				self.moveTouchFirstChanged = false
				local startPosVec2 = Vector2.new(inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X, inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y)
				self.startImage.Visible = true
				self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
				self.endImage.Visible = true
				self.endImage.Position = self.startImage.Position
				self:FadeThumbstick(true)
				self:MoveStick(inputObject.Position)
			end
			local direction = Vector2.new(inputObject.Position.x - self.moveTouchStartPosition.x, inputObject.Position.y - self.moveTouchStartPosition.y)
			if 0 < math.abs(direction.x) or 0 < math.abs(direction.y) then
				self:DoMove(direction)
				self:MoveStick(inputObject.Position)
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	local function inputEnded(inputObject)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
			if self.moveTouchLockedIn then
				return Enum.ContextActionResult.Sink
			end
		end
		return Enum.ContextActionResult.Pass
	end
	local function handleInput(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.Begin then
			return inputBegan(inputObject)
		elseif inputState == Enum.UserInputState.Change then
			return inputChanged(inputObject)
		elseif inputState == Enum.UserInputState.End then
			return inputEnded(inputObject)
		elseif inputState == Enum.UserInputState.Cancel then
			self:OnInputEnded()
		end
	end
	ContextActionService:BindActionAtPriority(DYNAMIC_THUMBSTICK_ACTION_NAME, handleInput, false, DYNAMIC_THUMBSTICK_ACTION_PRIORITY, Enum.UserInputType.Touch)
end
function DynamicThumbstick:Create(parentFrame)
	if self.thumbstickFrame then
		self.thumbstickFrame:Destroy()
		self.thumbstickFrame = nil
		if not FFlagDynamicThumbstickUseContextActionSevice then
			if self.onTouchMovedConn then
				self.onTouchMovedConn:Disconnect()
				self.onTouchMovedConn = nil
			end
			if self.onTouchEndedConn then
				self.onTouchEndedCon:Disconnect()
				self.onTouchEndedCon = nil
			end
			if self.onTouchActivateConn then
				self.onTouchActivateConn:Disconnect()
				self.onTouchActivateConn = nil
			end
		end
		if self.onRenderSteppedConn then
			self.onRenderSteppedConn:Disconnect()
			self.onRenderSteppedConn = nil
		end
	end
	self.thumbstickSize = 45
	self.thumbstickRingSize = 20
	self.middleSize = 10
	self.middleSpacing = self.middleSize + 4
	self.radiusOfDeadZone = 2
	self.radiusOfMaxSpeed = 20
	local screenSize = parentFrame.AbsoluteSize
	local isBigScreen = math.min(screenSize.x, screenSize.y) > 500
	if isBigScreen then
		self.thumbstickSize = self.thumbstickSize * 2
		self.thumbstickRingSize = self.thumbstickRingSize * 2
		self.middleSize = self.middleSize * 2
		self.middleSpacing = self.middleSpacing * 2
		self.radiusOfDeadZone = self.radiusOfDeadZone * 2
		self.radiusOfMaxSpeed = self.radiusOfMaxSpeed * 2
	end
	local function layoutThumbstickFrame(portraitMode)
		if portraitMode then
			self.thumbstickFrame.Size = UDim2.new(1, 0, 0.4, 0)
			self.thumbstickFrame.Position = UDim2.new(0, 0, 0.6, 0)
		else
			self.thumbstickFrame.Size = UDim2.new(0.4, 0, 0.6666666666666666, 0)
			self.thumbstickFrame.Position = UDim2.new(0, 0, 0.3333333333333333, 0)
		end
	end
	self.thumbstickFrame = Instance.new("TextButton")
	self.thumbstickFrame.Text = ""
	self.thumbstickFrame.Name = "DynamicThumbstickFrame"
	self.thumbstickFrame.Visible = false
	self.thumbstickFrame.BackgroundTransparency = 1
	self.thumbstickFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	if FFlagDynamicThumbstickUseContextActionSevice then
		self.thumbstickFrame.Active = false
	end
	layoutThumbstickFrame(false)
	self.startImage = Instance.new("ImageLabel")
	self.startImage.Name = "ThumbstickStart"
	self.startImage.Visible = true
	self.startImage.BackgroundTransparency = 1
	self.startImage.Image = TOUCH_CONTROLS_SHEET
	self.startImage.ImageRectOffset = Vector2.new(1, 1)
	self.startImage.ImageRectSize = Vector2.new(144, 144)
	self.startImage.ImageColor3 = Color3.new(0, 0, 0)
	self.startImage.AnchorPoint = Vector2.new(0.5, 0.5)
	self.startImage.Position = UDim2.new(0, self.thumbstickRingSize * 3.3, 1, -self.thumbstickRingSize * 2.8)
	self.startImage.Size = UDim2.new(0, self.thumbstickRingSize * 3.7, 0, self.thumbstickRingSize * 3.7)
	self.startImage.ZIndex = 10
	self.startImage.Parent = self.thumbstickFrame
	self.endImage = Instance.new("ImageLabel")
	self.endImage.Name = "ThumbstickEnd"
	self.endImage.Visible = true
	self.endImage.BackgroundTransparency = 1
	self.endImage.Image = TOUCH_CONTROLS_SHEET
	self.endImage.ImageRectOffset = Vector2.new(1, 1)
	self.endImage.ImageRectSize = Vector2.new(144, 144)
	self.endImage.AnchorPoint = Vector2.new(0.5, 0.5)
	self.endImage.Position = self.startImage.Position
	self.endImage.Size = UDim2.new(0, self.thumbstickSize * 0.8, 0, self.thumbstickSize * 0.8)
	self.endImage.ZIndex = 10
	self.endImage.Parent = self.thumbstickFrame
	for i = 1, NUM_MIDDLE_IMAGES do
		self.middleImages[i] = Instance.new("ImageLabel")
		self.middleImages[i].Name = "ThumbstickMiddle"
		self.middleImages[i].Visible = false
		self.middleImages[i].BackgroundTransparency = 1
		self.middleImages[i].Image = TOUCH_CONTROLS_SHEET
		self.middleImages[i].ImageRectOffset = Vector2.new(1, 1)
		self.middleImages[i].ImageRectSize = Vector2.new(144, 144)
		self.middleImages[i].ImageTransparency = MIDDLE_TRANSPARENCIES[i]
		self.middleImages[i].AnchorPoint = Vector2.new(0.5, 0.5)
		self.middleImages[i].ZIndex = 9
		self.middleImages[i].Parent = self.thumbstickFrame
	end
	local CameraChangedConn
	local function onCurrentCameraChanged()
		if CameraChangedConn then
			CameraChangedConn:Disconnect()
			CameraChangedConn = nil
		end
		local newCamera = workspace.CurrentCamera
		if newCamera then
			local function onViewportSizeChanged()
				local size = newCamera.ViewportSize
				local portraitMode = size.X < size.Y
				layoutThumbstickFrame(portraitMode)
			end
			CameraChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(onViewportSizeChanged)
			onViewportSizeChanged()
		end
	end
	workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(onCurrentCameraChanged)
	if workspace.CurrentCamera then
		onCurrentCameraChanged()
	end
	self.moveTouchStartPosition = nil
	self.startImageFadeTween = nil
	self.endImageFadeTween = nil
	self.middleImageFadeTweens = {}
	if not FFlagDynamicThumbstickUseContextActionSevice then
		self.thumbstickFrame.InputBegan:Connect(function(inputObject)
			if inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
				return
			end
			if self.moveTouchObject then
				return
			end
			if self.isFirstTouch then
				self.isFirstTouch = false
				local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0)
				TweenService:Create(self.startImage, tweenInfo, {
					Size = UDim2.new(0, 0, 0, 0)
				}):Play()
				TweenService:Create(self.endImage, tweenInfo, {
					Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize),
					ImageColor3 = Color3.new(0, 0, 0)
				}):Play()
			end
			self.moveTouchObject = inputObject
			self.moveTouchStartPosition = inputObject.Position
			local startPosVec2 = Vector2.new(inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X, inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y)
			self.startImage.Visible = true
			self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
			self.endImage.Visible = true
			self.endImage.Position = self.startImage.Position
			self:FadeThumbstick(true)
			self:MoveStick(inputObject.Position)
			if FADE_IN_OUT_BACKGROUND then
				self:DoFadeInBackground()
			end
		end)
		self.onTouchMovedConn = UserInputService.TouchMoved:connect(function(inputObject)
			if inputObject == self.moveTouchObject then
				self.thumbstickFrame.Active = false
				local direction = Vector2.new(inputObject.Position.x - self.moveTouchStartPosition.x, inputObject.Position.y - self.moveTouchStartPosition.y)
				if math.abs(direction.x) > 0 or math.abs(direction.y) > 0 then
					self:DoMove(direction)
					self:MoveStick(inputObject.Position)
				end
			end
		end)
	end
	self.onRenderSteppedConn = RunService.RenderStepped:Connect(function()
		if self.tweenInAlphaStart ~= nil then
			local delta = tick() - self.tweenInAlphaStart
			local fadeInTime = self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance
			self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA * math.min(delta / fadeInTime, 1)
			if delta > fadeInTime then
				self.tweenOutAlphaStart = tick()
				self.tweenInAlphaStart = nil
			end
		elseif self.tweenOutAlphaStart ~= nil then
			local delta = tick() - self.tweenOutAlphaStart
			local fadeOutTime = self.fadeInAndOutHalfDuration * 2 - self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance
			self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA + FADE_IN_OUT_MAX_ALPHA * math.min(delta / fadeOutTime, 1)
			if delta > fadeOutTime then
				self.tweenOutAlphaStart = nil
			end
		end
	end)
	self.onTouchEndedConn = UserInputService.TouchEnded:connect(function(inputObject)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	GuiService.MenuOpened:connect(function()
		if self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	local playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
	while not playerGui do
		Players.LocalPlayer.ChildAdded:wait()
		playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
	end
	local playerGuiChangedConn
	local originalScreenOrientationWasLandscape = playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight
	local function longShowBackground()
		self.fadeInAndOutHalfDuration = 2.5
		self.fadeInAndOutBalance = 0.05
		self.tweenInAlphaStart = tick()
	end
	playerGuiChangedConn = playerGui.Changed:connect(function(prop)
		if prop == "CurrentScreenOrientation" and (originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait or not originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation ~= Enum.ScreenOrientation.Portrait) then
			playerGuiChangedConn:disconnect()
			longShowBackground()
			if originalScreenOrientationWasLandscape then
				self.hasFadedBackgroundInPortrait = true
			else
				self.hasFadedBackgroundInLandscape = true
			end
		end
	end)
	self.thumbstickFrame.Parent = parentFrame
	spawn(function()
		if game:IsLoaded() then
			longShowBackground()
		else
			game.Loaded:wait()
			longShowBackground()
		end
	end)
end
return DynamicThumbstick
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX57"><Properties><string name="Name">ClickToMoveController</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UserInputService = game:GetService("UserInputService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local DebrisService = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local CollectionService = game:GetService("CollectionService")
local ShowPath = true
local PlayFailureAnimation = true
local UseDirectPath = false
local movementKeys = {
	[Enum.KeyCode.W] = true,
	[Enum.KeyCode.A] = true,
	[Enum.KeyCode.S] = true,
	[Enum.KeyCode.D] = true,
	[Enum.KeyCode.Up] = true,
	[Enum.KeyCode.Down] = true
}
local FFlagUserNavigationClickToMoveSkipPassedWaypointsSuccess, FFlagUserNavigationClickToMoveSkipPassedWaypointsResult = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNavigationClickToMoveSkipPassedWaypoints")
end)
local FFlagUserNavigationClickToMoveSkipPassedWaypoints = FFlagUserNavigationClickToMoveSkipPassedWaypointsSuccess and FFlagUserNavigationClickToMoveSkipPassedWaypointsResult
local FFlagUserNewClickToMoveDisplaySuccess, FFlagUserNewClickToMoveDisplayValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNewClickToMoveDisplay")
end)
local FFlagUserNewClickToMoveDisplay = FFlagUserNewClickToMoveDisplaySuccess and FFlagUserNewClickToMoveDisplayValue
local FFlagUserFixClickToMoveWithACMSuccess, FFlagUserFixClickToMoveWithACMResult = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserFixClickToMoveWithACM")
end)
local FFlagUserFixClickToMoveWithACM = FFlagUserFixClickToMoveWithACMSuccess and FFlagUserFixClickToMoveWithACMResult
local Player = Players.LocalPlayer
local ClickToMoveDisplay
if FFlagUserNewClickToMoveDisplay then
	ClickToMoveDisplay = require(script.Parent:WaitForChild("ClickToMoveDisplay"))
end
local CurrentSeatPart, DrivingTo
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local ZERO_VECTOR2 = Vector2.new(0, 0)
local Utility = {}
do
	local function FindCharacterAncestor(part)
		if part then
			local humanoid = part:FindFirstChildOfClass("Humanoid")
			if humanoid then
				return part, humanoid
			else
				return FindCharacterAncestor(part.Parent)
			end
		end
	end
	Utility.FindCharacterAncestor = FindCharacterAncestor
	local function Raycast(ray, ignoreNonCollidable, ignoreList)
		ignoreList = ignoreList or {}
		local hitPart, hitPos, hitNorm, hitMat = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
		if hitPart then
			if ignoreNonCollidable and hitPart.CanCollide == false then
				local _, humanoid
				if FFlagUserFixClickToMoveWithACM then
					_, humanoid = FindCharacterAncestor(hitPart)
				end
				if humanoid == nil then
					table.insert(ignoreList, hitPart)
					return Raycast(ray, ignoreNonCollidable, ignoreList)
				end
			end
			return hitPart, hitPos, hitNorm, hitMat
		end
		return nil, nil
	end
	Utility.Raycast = Raycast
end
local humanoidCache = {}
local function findPlayerHumanoid(player)
	local character = player and player.Character
	if character then
		local resultHumanoid = humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			humanoidCache[player] = nil
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoidCache[player] = humanoid
			end
			return humanoid
		end
	end
end
local CurrentIgnoreList, CurrentIgnoreTag, TaggedInstanceAddedConnection, TaggedInstanceRemovedConnection
local function GetCharacter()
	return Player and Player.Character
end
local function UpdateIgnoreTag(newIgnoreTag)
	if newIgnoreTag == CurrentIgnoreTag then
		return
	end
	if TaggedInstanceAddedConnection then
		TaggedInstanceAddedConnection:Disconnect()
		TaggedInstanceAddedConnection = nil
	end
	if TaggedInstanceRemovedConnection then
		TaggedInstanceRemovedConnection:Disconnect()
		TaggedInstanceRemovedConnection = nil
	end
	CurrentIgnoreTag = newIgnoreTag
	CurrentIgnoreList = {
		GetCharacter()
	}
	if CurrentIgnoreTag ~= nil then
		local ignoreParts = CollectionService:GetTagged(CurrentIgnoreTag)
		for _, ignorePart in ipairs(ignoreParts) do
			table.insert(CurrentIgnoreList, ignorePart)
		end
		TaggedInstanceAddedConnection = CollectionService:GetInstanceAddedSignal(CurrentIgnoreTag):Connect(function(ignorePart)
			table.insert(CurrentIgnoreList, ignorePart)
		end)
		TaggedInstanceRemovedConnection = CollectionService:GetInstanceRemovedSignal(CurrentIgnoreTag):Connect(function(ignorePart)
			for i = 1, #CurrentIgnoreList do
				if CurrentIgnoreList[i] == ignorePart then
					CurrentIgnoreList[i] = CurrentIgnoreList[#CurrentIgnoreList]
					table.remove(CurrentIgnoreList)
					break
				end
			end
		end)
	end
end
local function getIgnoreList()
	if CurrentIgnoreList then
		return CurrentIgnoreList
	end
	CurrentIgnoreList = {}
	table.insert(CurrentIgnoreList, GetCharacter())
	return CurrentIgnoreList
end
local popupAdornee
local function getPopupAdorneePart()
	if popupAdornee and not popupAdornee.Parent then
		popupAdornee = nil
	end
	if not popupAdornee then
		popupAdornee = Instance.new("Part")
		popupAdornee.Name = "ClickToMovePopupAdornee"
		popupAdornee.Transparency = 1
		popupAdornee.CanCollide = false
		popupAdornee.Anchored = true
		popupAdornee.Size = Vector3.new(2, 2, 2)
		popupAdornee.CFrame = CFrame.new()
		popupAdornee.Parent = Workspace.CurrentCamera
	end
	return popupAdornee
end
local activePopups = {}
local function createNewPopup(popupType)
	local newModel = Instance.new("ImageHandleAdornment")
	newModel.AlwaysOnTop = false
	newModel.Transparency = 1
	newModel.Size = ZERO_VECTOR2
	newModel.SizeRelativeOffset = ZERO_VECTOR3
	newModel.Image = "rbxasset://textures/ui/move.png"
	newModel.ZIndex = 20
	local radius = 0
	if popupType == "DestinationPopup" then
		newModel.Color3 = Color3.fromRGB(0, 175, 255)
		radius = 1.25
	elseif popupType == "DirectWalkPopup" then
		newModel.Color3 = Color3.fromRGB(0, 175, 255)
		radius = 1.25
	elseif popupType == "FailurePopup" then
		newModel.Color3 = Color3.fromRGB(255, 100, 100)
		radius = 1.25
	elseif popupType == "PatherPopup" then
		newModel.Color3 = Color3.fromRGB(255, 255, 255)
		radius = 1
		newModel.ZIndex = 10
	end
	newModel.Size = Vector2.new(5, 0.1) * radius
	local dataStructure = {}
	dataStructure.Model = newModel
	activePopups[#activePopups + 1] = newModel
	function dataStructure:TweenIn()
		local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out)
		local tween1 = TweenService:Create(newModel, tweenInfo, {
			Size = Vector2.new(2, 2) * radius
		})
		tween1:Play()
		TweenService:Create(newModel, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, 0.1), {
			Transparency = 0,
			SizeRelativeOffset = Vector3.new(0, radius * 1.5, 0)
		}):Play()
		return tween1
	end
	function dataStructure:TweenOut()
		local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
		local tween1 = TweenService:Create(newModel, tweenInfo, {Size = ZERO_VECTOR2})
		tween1:Play()
		coroutine.wrap(function()
			tween1.Completed:Wait()
			for i = 1, #activePopups do
				if activePopups[i] == newModel then
					table.remove(activePopups, i)
					break
				end
			end
		end)()
		return tween1
	end
	function dataStructure:Place(position)
		if not self.Model.Parent then
			local popupAdorneePart = getPopupAdorneePart()
			self.Model.Parent = popupAdorneePart
			self.Model.Adornee = popupAdorneePart
			local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
			local _, hitPoint = Workspace:FindPartOnRayWithIgnoreList(ray, {
				Workspace.CurrentCamera,
				Player.Character
			})
			self.Model.CFrame = CFrame.new(hitPoint) + Vector3.new(0, -radius, 0)
		end
	end
	return dataStructure
end
local function createPopupPath(points, numCircles)
	local popups = {}
	local stopTraversing = false
	local function killPopup(i)
		for iter, v in pairs(popups) do
			if iter <= i then
				do
					local tween = v:TweenOut()
					coroutine.wrap(function()
						tween.Completed:Wait()
						v.Model:Destroy()
					end)()
					popups[iter] = nil
				end
			end
		end
	end
	local function stopFunction()
		stopTraversing = true
		killPopup(#points)
	end
	coroutine.wrap(function()
		for i = 1, #points do
			if stopTraversing then
				break
			end
			local includeWaypoint = i % numCircles == 0 and i < #points and (points[#points].Position - points[i].Position).magnitude > 4
			if includeWaypoint then
				local popup = createNewPopup("PatherPopup")
				popups[i] = popup
				popup:Place(points[i].Position)
				popup:TweenIn()
				wait(0.2)
			end
		end
	end)()
	return stopFunction, killPopup
end
local function Pather(character, endPoint, surfaceNormal)
	local this = {}
	this.Cancelled = false
	this.Started = false
	this.Finished = Instance.new("BindableEvent")
	this.PathFailed = Instance.new("BindableEvent")
	this.PathComputing = false
	this.PathComputed = false
	this.OriginalPoint = endPoint
	this.TargetPoint = endPoint
	this.TargetSurfaceNormal = surfaceNormal
	this.DiedConn = nil
	this.SeatedConn = nil
	this.MoveToConn = nil
	this.BlockedConn = nil
	this.CurrentPoint = 0
	function this:Cleanup()
		if this.stopTraverseFunc then
			this.stopTraverseFunc()
			this.stopTraverseFunc = nil
		end
		if this.MoveToConn then
			this.MoveToConn:Disconnect()
			this.MoveToConn = nil
		end
		if this.BlockedConn then
			this.BlockedConn:Disconnect()
			this.BlockedConn = nil
		end
		if this.DiedConn then
			this.DiedConn:Disconnect()
			this.DiedConn = nil
		end
		if this.SeatedConn then
			this.SeatedConn:Disconnect()
			this.SeatedConn = nil
		end
		this.humanoid = nil
	end
	function this:Cancel()
		this.Cancelled = true
		this:Cleanup()
	end
	function this:IsActive()
		return this.humanoid and this.Started and not this.Cancelled
	end
	function this:OnPathInterrupted()
		this.Cancelled = true
		this:OnPointReached(false)
	end
	function this:ComputePath()
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if torso then
			if this.PathComputed or this.PathComputing then
				return
			end
			this.PathComputing = true
			pcall(function()
				this.pathResult = PathfindingService:FindPathAsync(torso.CFrame.p, this.TargetPoint)
			end)
			this.pointList = this.pathResult and this.pathResult:GetWaypoints()
			if this.pathResult then
				this.BlockedConn = this.pathResult.Blocked:Connect(function(blockedIdx)
					this:OnPathBlocked(blockedIdx)
				end)
			end
			this.PathComputing = false
			this.PathComputed = this.pathResult and this.pathResult.Status == Enum.PathStatus.Success or false
		end
		return true
	end
	function this:IsValidPath()
		if not this.pathResult then
			this:ComputePath()
		end
		return this.pathResult.Status == Enum.PathStatus.Success
	end
	this.Recomputing = false
	function this:OnPathBlocked(blockedWaypointIdx)
		local pathBlocked = blockedWaypointIdx >= this.CurrentPoint
		if not pathBlocked or this.Recomputing then
			return
		end
		this.Recomputing = true
		if this.stopTraverseFunc then
			this.stopTraverseFunc()
			this.stopTraverseFunc = nil
		end
		this.pathResult:ComputeAsync(this.humanoid.Torso.CFrame.p, this.TargetPoint)
		this.pointList = this.pathResult:GetWaypoints()
		this.PathComputed = this.pathResult and this.pathResult.Status == Enum.PathStatus.Success or false
		if ShowPath then
			if FFlagUserNewClickToMoveDisplay then
				this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList)
			else
				this.stopTraverseFunc, this.setPointFunc = createPopupPath(this.pointList, 4, true)
			end
		end
		if this.PathComputed then
			this.humanoid = findPlayerHumanoid(Player)
			this.CurrentPoint = 1
			this:OnPointReached(true)
		else
			this.PathFailed:Fire()
			this:Cleanup()
		end
		this.Recomputing = false
	end
	function this:OnPointReached(reached)
		if reached and not this.Cancelled then
			local nextWaypointIdx = this.CurrentPoint + 1
			if nextWaypointIdx > #this.pointList then
				if this.stopTraverseFunc then
					this.stopTraverseFunc()
				end
				this.Finished:Fire()
				this:Cleanup()
			else
				local currentWaypoint = this.pointList[this.CurrentPoint]
				local nextWaypoint = this.pointList[nextWaypointIdx]
				local currentState = this.humanoid:GetState()
				local isInAir = currentState == Enum.HumanoidStateType.FallingDown or currentState == Enum.HumanoidStateType.Freefall or currentState == Enum.HumanoidStateType.Jumping
				if isInAir then
					local shouldWaitForGround = nextWaypoint.Action == Enum.PathWaypointAction.Jump
					shouldWaitForGround = shouldWaitForGround
					if shouldWaitForGround then
						this.humanoid.FreeFalling:Wait()
						wait(0.1)
					end
				end
				if FFlagUserNavigationClickToMoveSkipPassedWaypoints then
					local nextWaypointAlreadyReached
					local planeNormal = currentWaypoint.Position - nextWaypoint.Position
					if planeNormal.Magnitude > 1.0E-6 then
						planeNormal = planeNormal.Unit
						local planeDistance = planeNormal:Dot(nextWaypoint.Position)
						local humanoidPosition = this.humanoid.RootPart.Position - Vector3.new(0, 0.5 * this.humanoid.RootPart.Size.y + this.humanoid.HipHeight, 0)
						local dist = planeNormal:Dot(humanoidPosition) - planeDistance
						nextWaypointAlreadyReached = dist < 1
					else
						nextWaypointAlreadyReached = true
					end
					if this.setPointFunc then
						this.setPointFunc(nextWaypointIdx)
					end
					this.CurrentPoint = nextWaypointIdx
					if nextWaypointAlreadyReached then
						this:OnPointReached(true)
					else
						if nextWaypoint.Action == Enum.PathWaypointAction.Jump then
							this.humanoid.Jump = true
						end
						this.humanoid:MoveTo(nextWaypoint.Position)
					end
				else
					if this.setPointFunc then
						this.setPointFunc(nextWaypointIdx)
					end
					if nextWaypoint.Action == Enum.PathWaypointAction.Jump then
						this.humanoid.Jump = true
					end
					this.humanoid:MoveTo(nextWaypoint.Position)
					this.CurrentPoint = nextWaypointIdx
				end
			end
		else
			this.PathFailed:Fire()
			this:Cleanup()
		end
	end
	function this:Start(overrideShowPath)
		if CurrentSeatPart then
			return
		end
		this.humanoid = findPlayerHumanoid(Player)
		if not this.humanoid then
			this.PathFailed:Fire()
			return
		end
		if this.Started then
			return
		end
		this.Started = true
		if FFlagUserNewClickToMoveDisplay then
			ClickToMoveDisplay.CancelFailureAnimation()
		end
		if ShowPath then
			if FFlagUserNewClickToMoveDisplay then
				if overrideShowPath == nil or overrideShowPath then
					this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList, this.OriginalPoint)
				end
			else
				this.stopTraverseFunc, this.setPointFunc = createPopupPath(this.pointList, 4)
			end
		end
		if #this.pointList > 0 then
			this.SeatedConn = this.humanoid.Seated:Connect(function(reached)
				this:OnPathInterrupted()
			end)
			this.DiedConn = this.humanoid.Died:Connect(function(reached)
				this:OnPathInterrupted()
			end)
			this.MoveToConn = this.humanoid.MoveToFinished:Connect(function(reached)
				this:OnPointReached(reached)
			end)
			this.CurrentPoint = 1
			this:OnPointReached(true)
		else
			this.PathFailed:Fire()
			if this.stopTraverseFunc then
				this.stopTraverseFunc()
			end
		end
	end
	if FFlagUserNewClickToMoveDisplay then
		local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal * 1.5
		local ray = Ray.new(offsetPoint, Vector3.new(0, -1, 0) * 50)
		local newHitPart, newHitPos = Workspace:FindPartOnRayWithIgnoreList(ray, getIgnoreList())
		if newHitPart then
			this.TargetPoint = newHitPos
		end
		this:ComputePath()
	else
		this:ComputePath()
		if not this.PathComputed then
			local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal * 1.5
			local ray = Ray.new(offsetPoint, Vector3.new(0, -1, 0) * 50)
			local newHitPart, newHitPos = Workspace:FindPartOnRayWithIgnoreList(ray, getIgnoreList())
			if newHitPart then
				this.TargetPoint = newHitPos
			end
			this:ComputePath()
		end
	end
	return this
end
local function CheckAlive()
	local humanoid = findPlayerHumanoid(Player)
	return humanoid ~= nil and humanoid.Health > 0
end
local GetEquippedTool = function(character)
	if character ~= nil then
		for _, child in pairs(character:GetChildren()) do
			if child:IsA("Tool") then
				return child
			end
		end
	end
end
local ExistingPather, ExistingIndicator, PathCompleteListener, PathFailedListener
local function CleanupPath()
	DrivingTo = nil
	if ExistingPather then
		ExistingPather:Cancel()
	end
	if PathCompleteListener then
		PathCompleteListener:Disconnect()
		PathCompleteListener = nil
	end
	if PathFailedListener then
		PathFailedListener:Disconnect()
		PathFailedListener = nil
	end
	if ExistingIndicator then
		if FFlagUserNewClickToMoveDisplay then
			ExistingIndicator:Destroy()
		else
			do
				local obj = ExistingIndicator
				local tween = obj:TweenOut()
				local tweenCompleteEvent
				tweenCompleteEvent = tween.Completed:connect(function()
					tweenCompleteEvent:Disconnect()
					obj.Model:Destroy()
				end)
				ExistingIndicator = nil
			end
		end
	end
end
local getExtentsSize = function(Parts)
	local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge
	local minX, minY, minZ = math.huge, math.huge, math.huge
	for i = 1, #Parts do
		local position = Parts[i].Position
		maxX = math.max(maxX, position.X)
		maxY = math.max(maxY, position.Y)
		maxZ = math.max(maxZ, position.Z)
		minX = math.min(minX, position.X)
		minY = math.min(minY, position.Y)
		minZ = math.min(minZ, position.Z)
	end
	return Region3.new(Vector3.new(minX, minY, minZ), Vector3.new(maxX, maxY, maxZ))
end
local inExtents = function(Extents, Position)
	if Position.X < Extents.CFrame.p.X - Extents.Size.X / 2 or Position.X > Extents.CFrame.p.X + Extents.Size.X / 2 then
		return false
	end
	if Position.Z < Extents.CFrame.p.Z - Extents.Size.Z / 2 or Position.Z > Extents.CFrame.p.Z + Extents.Size.Z / 2 then
		return false
	end
	return true
end
local function showQuickPopupAsync(position, popupType)
	local popup = createNewPopup(popupType)
	popup:Place(position)
	local tweenIn = popup:TweenIn()
	tweenIn.Completed:Wait()
	local tweenOut = popup:TweenOut()
	tweenOut.Completed:Wait()
	popup.Model:Destroy()
end
local function HandleDirectMoveTo(hitPt, myHumanoid)
	if myHumanoid then
		if myHumanoid.Sit then
			myHumanoid.Jump = true
		end
		myHumanoid:MoveTo(hitPt)
	end
	local endWaypoint = ClickToMoveDisplay.CreateEndWaypoint(hitPt)
	ExistingIndicator = endWaypoint
	coroutine.wrap(function()
		myHumanoid.MoveToFinished:wait()
		endWaypoint:Destroy()
	end)
end
local OnTap
local function HandleDriveTo(tapPositions, hitPt, character)
	local destinationPopup
	if FFlagUserNewClickToMoveDisplay then
		destinationPopup = ClickToMoveDisplay.CreateEndWaypoint(hitPt)
	else
		destinationPopup = createNewPopup("DestinationPopup")
		ExistingIndicator = destinationPopup
		destinationPopup:Place(hitPt)
		destinationPopup:TweenIn()
	end
	DrivingTo = hitPt
	local ConnectedParts = CurrentSeatPart:GetConnectedParts(true)
	local heartBeatConnection
	heartBeatConnection = RunService.Heartbeat:Connect(function()
		if CurrentSeatPart and ExistingIndicator == destinationPopup then
			local ExtentsSize = getExtentsSize(ConnectedParts)
			if inExtents(ExtentsSize, hitPt) then
				if FFlagUserNewClickToMoveDisplay then
					destinationPopup:Destroy()
				else
					do
						local popup = destinationPopup
						coroutine.wrap(function()
							local tweenOut = popup:TweenOut()
							tweenOut.Completed:Wait()
							popup.Model:Destroy()
						end)()
					end
				end
				DrivingTo = nil
				heartBeatConnection:Disconnect()
			end
		else
			if CurrentSeatPart == nil and destinationPopup == ExistingIndicator then
				DrivingTo = nil
				OnTap(tapPositions, hitPt)
			end
			if FFlagUserNewClickToMoveDisplay then
				destinationPopup:Destroy()
			else
				do
					local popup = destinationPopup
					coroutine.wrap(function()
						local tweenOut = popup:TweenOut()
						tweenOut.Completed:Wait()
						popup.Model:Destroy()
					end)()
				end
			end
			heartBeatConnection:Disconnect()
		end
	end)
end
local function HandleMoveTo(thisPather, hitPt, hitChar, character, overrideShowPath)
	thisPather:Start(overrideShowPath)
	CleanupPath()
	local destinationPopup, failurePopup
	if not FFlagUserNewClickToMoveDisplay then
		destinationPopup = createNewPopup("DestinationPopup")
		destinationPopup:Place(hitPt, Vector3.new(0, hitPt.y, 0))
		failurePopup = createNewPopup("FailurePopup")
		destinationPopup:TweenIn()
		ExistingIndicator = destinationPopup
	end
	ExistingPather = thisPather
	PathCompleteListener = thisPather.Finished.Event:Connect(function()
		if destinationPopup then
			if ExistingIndicator == destinationPopup then
				ExistingIndicator = nil
			end
			do
				local tween = destinationPopup:TweenOut()
				local tweenCompleteEvent
				tweenCompleteEvent = tween.Completed:Connect(function()
					tweenCompleteEvent:Disconnect()
					destinationPopup.Model:Destroy()
					destinationPopup = nil
				end)
			end
		end
		if hitChar then
			local currentWeapon = GetEquippedTool(character)
			if currentWeapon then
				currentWeapon:Activate()
			end
		end
	end)
	PathFailedListener = thisPather.PathFailed.Event:Connect(function()
		CleanupPath()
		if FFlagUserNewClickToMoveDisplay then
			if overrideShowPath == nil or overrideShowPath then
				local shouldPlayFailureAnim = PlayFailureAnimation and (not ExistingPather or not ExistingPather:IsActive())
				if shouldPlayFailureAnim then
					ClickToMoveDisplay.PlayFailureAnimation()
				end
				ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
			end
		elseif failurePopup then
			failurePopup:Place(hitPt, Vector3.new(0, hitPt.y, 0))
			local failTweenIn = failurePopup:TweenIn()
			failTweenIn.Completed:Wait()
			local failTweenOut = failurePopup:TweenOut()
			failTweenOut.Completed:Wait()
			failurePopup.Model:Destroy()
			failurePopup = nil
		end
	end)
end
local function ShowPathFailedFeedback(hitPt)
	if ExistingPather and ExistingPather:IsActive() then
		ExistingPather:Cancel()
	end
	if PlayFailureAnimation then
		ClickToMoveDisplay.PlayFailureAnimation()
	end
	ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
end
function OnTap(tapPositions, goToPoint, wasTouchTap)
	local camera = Workspace.CurrentCamera
	local character = Player.Character
	if not CheckAlive() then
		return
	end
	if #tapPositions == 1 or goToPoint then
		if camera then
			local unitRay = camera:ScreenPointToRay(tapPositions[1].x, tapPositions[1].y)
			local ray = Ray.new(unitRay.Origin, unitRay.Direction * 1000)
			local myHumanoid = findPlayerHumanoid(Player)
			local hitPart, hitPt, hitNormal = Utility.Raycast(ray, true, getIgnoreList())
			local hitChar, hitHumanoid = Utility.FindCharacterAncestor(hitPart)
			if FFlagUserFixClickToMoveWithACM and wasTouchTap and hitHumanoid and StarterGui:GetCore("AvatarContextMenuEnabled") then
				local clickedPlayer = Players:GetPlayerFromCharacter(hitHumanoid.Parent)
				if clickedPlayer then
					CleanupPath()
					return
				end
			end
			if goToPoint then
				hitPt = goToPoint
				hitChar = nil
			end
			if UseDirectPath and hitPt and character and not CurrentSeatPart then
				HandleDirectMoveTo(hitPt, myHumanoid)
			elseif hitPt and character and not CurrentSeatPart then
				local thisPather = Pather(character, hitPt, hitNormal)
				if thisPather:IsValidPath() then
					HandleMoveTo(thisPather, hitPt, hitChar, character)
				elseif hitPt then
					if FFlagUserNewClickToMoveDisplay then
						ShowPathFailedFeedback(hitPt)
					else
						coroutine.wrap(showQuickPopupAsync)(hitPt, "FailurePopup")
					end
				end
			elseif hitPt and character and CurrentSeatPart then
				HandleDriveTo(tapPositions, hitPt, character)
			end
		end
	elseif #tapPositions >= 2 and camera then
		local currentWeapon = GetEquippedTool(character)
		if currentWeapon then
			currentWeapon:Activate()
		end
	end
end
local DisconnectEvent = function(event)
	if event then
		event:Disconnect()
	end
end
local KeyboardController = require(script.Parent:WaitForChild("Keyboard"))
local ClickToMove = setmetatable({}, KeyboardController)
ClickToMove.__index = ClickToMove
function ClickToMove.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(KeyboardController.new(CONTROL_ACTION_PRIORITY), ClickToMove)
	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	self.mouse1Down = tick()
	self.mouse1DownPos = Vector2.new()
	self.mouse2DownTime = tick()
	self.mouse2DownPos = Vector2.new()
	self.mouse2UpTime = tick()
	self.tapConn = nil
	self.inputBeganConn = nil
	self.inputChangedConn = nil
	self.inputEndedConn = nil
	self.humanoidDiedConn = nil
	self.characterChildAddedConn = nil
	self.onCharacterAddedConn = nil
	self.characterChildRemovedConn = nil
	self.renderSteppedConn = nil
	self.humanoidSeatedConn = nil
	self.running = false
	self.wasdEnabled = false
	return self
end
function ClickToMove:DisconnectEvents()
	DisconnectEvent(self.tapConn)
	DisconnectEvent(self.inputBeganConn)
	DisconnectEvent(self.inputChangedConn)
	DisconnectEvent(self.inputEndedConn)
	DisconnectEvent(self.humanoidDiedConn)
	DisconnectEvent(self.characterChildAddedConn)
	DisconnectEvent(self.onCharacterAddedConn)
	DisconnectEvent(self.renderSteppedConn)
	DisconnectEvent(self.characterChildRemovedConn)
	DisconnectEvent(self.humanoidSeatedConn)
	RunService:UnbindFromRenderStep("ClickToMoveRenderUpdate")
end
function ClickToMove:OnTouchBegan(input, processed)
	if self.fingerTouches[input] == nil and not processed then
		self.numUnsunkTouches = self.numUnsunkTouches + 1
	end
	self.fingerTouches[input] = processed
end
function ClickToMove:OnTouchChanged(input, processed)
	if self.fingerTouches[input] == nil then
		self.fingerTouches[input] = processed
		if not processed then
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
end
function ClickToMove:OnTouchEnded(input, processed)
	if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
		self.numUnsunkTouches = self.numUnsunkTouches - 1
	end
	self.fingerTouches[input] = nil
end
function ClickToMove:OnCharacterAdded(character)
	self:DisconnectEvents()
	self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchBegan(input, processed)
		end
		if processed == false and input.UserInputType == Enum.UserInputType.Keyboard and movementKeys[input.KeyCode] then
			CleanupPath()
		end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			self.mouse1DownTime = tick()
			self.mouse1DownPos = input.Position
		end
		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.mouse2DownTime = tick()
			self.mouse2DownPos = input.Position
		end
	end)
	self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchChanged(input, processed)
		end
	end)
	self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchEnded(input, processed)
		end
		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.mouse2UpTime = tick()
			local currPos = input.Position
			if self.mouse2UpTime - self.mouse2DownTime < 0.25 and (currPos - self.mouse2DownPos).magnitude < 5 and self.moveVector.Magnitude <= 0 then
				local positions = {currPos}
				OnTap(positions)
			end
		end
	end)
	self.tapConn = UserInputService.TouchTap:Connect(function(touchPositions, processed)
		if not processed then
			OnTap(touchPositions, nil, true)
		end
	end)
	local computeThrottle = function(dist)
		if dist > 0.2 then
			return 0.5 + dist ^ 2 / 2
		else
			return 0
		end
	end
	local kP = 1
	local kD = 0.5
	local function getThrottleAndSteer(object, point)
		local oCF = object.CFrame
		local relativePosition = oCF:pointToObjectSpace(point)
		local relativeZDirection = -relativePosition.z
		local relativeDistance = relativePosition.magnitude
		local throttle = computeThrottle(math.min(1, relativeDistance / 50)) * math.sign(relativeZDirection)
		local steerAngle = -math.atan2(-relativePosition.x, -relativePosition.z)
		local steer = steerAngle / (math.pi / 4)
		local pdSteer = kP * steer + kD * steer
		return throttle, pdSteer
	end
	local function Update()
		if CurrentSeatPart then
			if DrivingTo then
				local throttle, steer = getThrottleAndSteer(CurrentSeatPart, DrivingTo)
				CurrentSeatPart.ThrottleFloat = throttle
				CurrentSeatPart.SteerFloat = steer
			else
				CurrentSeatPart.ThrottleFloat = 0
				CurrentSeatPart.SteerFloat = 0
			end
		end
		local cameraPos = Workspace.CurrentCamera.CFrame.p
		for i = 1, #activePopups do
			local popup = activePopups[i]
			popup.CFrame = CFrame.new(popup.CFrame.p, cameraPos)
		end
	end
	RunService:BindToRenderStep("ClickToMoveRenderUpdate", Enum.RenderPriority.Camera.Value - 1, Update)
	local function onSeated(active, currentSeatPart)
		if active then
			if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
				CurrentSeatPart = currentSeatPart
			end
		else
			CurrentSeatPart = nil
		end
	end
	local function OnCharacterChildAdded(child)
		if UserInputService.TouchEnabled and child:IsA("Tool") then
			child.ManualActivationOnly = true
		end
		if child:IsA("Humanoid") then
			DisconnectEvent(self.humanoidDiedConn)
			self.humanoidDiedConn = child.Died:Connect(function()
				if ExistingIndicator then
					DebrisService:AddItem(ExistingIndicator.Model, 1)
				end
			end)
			if FFlagUserNewClickToMoveDisplay then
			end
		end
	end
	self.characterChildAddedConn = character.ChildAdded:Connect(function(child)
		OnCharacterChildAdded(child)
	end)
	self.characterChildRemovedConn = character.ChildRemoved:Connect(function(child)
		if UserInputService.TouchEnabled and child:IsA("Tool") then
			child.ManualActivationOnly = false
		end
	end)
	for _, child in pairs(character:GetChildren()) do
		OnCharacterChildAdded(child)
	end
end
function ClickToMove:Start()
	self:Enable(true)
end
function ClickToMove:Stop()
	self:Enable(false)
end
function ClickToMove:Enable(enable, enableWASD, touchJumpController)
	if enable then
		if not self.running then
			if Player.Character then
				self:OnCharacterAdded(Player.Character)
			end
			self.onCharacterAddedConn = Player.CharacterAdded:Connect(function(char)
				self:OnCharacterAdded(char)
			end)
			self.running = true
		end
		self.touchJumpController = touchJumpController
		if self.touchJumpController then
			self.touchJumpController:Enable(self.jumpEnabled)
		end
	else
		if self.running then
			self:DisconnectEvents()
			CleanupPath()
			if UserInputService.TouchEnabled then
				local character = Player.Character
				if character then
					for _, child in pairs(character:GetChildren()) do
						if child:IsA("Tool") then
							child.ManualActivationOnly = false
						end
					end
				end
			end
			DrivingTo = nil
			self.running = false
		end
		if self.touchJumpController and not self.jumpEnabled then
			self.touchJumpController:Enable(true)
		end
		self.touchJumpController = nil
	end
	if UserInputService.KeyboardEnabled and enable ~= self.enabled then
		self.forwardValue = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.moveVector = ZERO_VECTOR3
		if enable then
			self:BindContextActions()
			self:ConnectFocusEventListeners()
		else
			self:UnbindContextActions()
			self:DisconnectFocusEventListeners()
		end
	end
	self.wasdEnabled = enable and enableWASD or false
	self.enabled = enable
end
function ClickToMove:UpdateMovement(inputState)
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector = ZERO_VECTOR3
	elseif self.wasdEnabled then
		self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		if FFlagUserNewClickToMoveDisplay and 0 < self.moveVector.magnitude then
			CleanupPath()
			ClickToMoveDisplay.CancelFailureAnimation()
		end
	end
end
function ClickToMove:SetShowPath(value)
	ShowPath = value
end
function ClickToMove:GetShowPath()
	return ShowPath
end
function ClickToMove:SetWaypointTexture(texture)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetWaypointTexture(texture)
	end
end
function ClickToMove:GetWaypointTexture()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetWaypointTexture()
	end
	return ""
end
function ClickToMove:SetWaypointRadius(radius)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetWaypointRadius(radius)
	end
end
function ClickToMove:GetWaypointRadius()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetWaypointRadius()
	end
	return 0
end
function ClickToMove:SetEndWaypointTexture(texture)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetEndWaypointTexture(texture)
	end
end
function ClickToMove:GetEndWaypointTexture()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetEndWaypointTexture()
	end
	return ""
end
function ClickToMove:SetWaypointsAlwaysOnTop(alwaysOnTop)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
	end
end
function ClickToMove:GetWaypointsAlwaysOnTop()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
	end
	return false
end
function ClickToMove:SetFailureAnimationEnabled(enabled)
	PlayFailureAnimation = enabled
end
function ClickToMove:GetFailureAnimationEnabled()
	return PlayFailureAnimation
end
function ClickToMove:SetIgnoredPartsTag(tag)
	UpdateIgnoreTag(tag)
end
function ClickToMove:GetIgnoredPartsTag()
	return CurrentIgnoreTag
end
function ClickToMove:SetUseDirectPath(directPath)
	UseDirectPath = directPath
end
function ClickToMove:GetUseDirectPath()
	return UseDirectPath
end
function ClickToMove:SetUserJumpEnabled(jumpEnabled)
	self.jumpEnabled = jumpEnabled
	if self.touchJumpController then
		self.touchJumpController:Enable(jumpEnabled)
	end
end
function ClickToMove:GetUserJumpEnabled()
	return self.jumpEnabled
end
function ClickToMove:MoveTo(position, showPath)
	local character = Player.Character
	if character == nil then
		return false
	end
	local thisPather = Pather(character, position, Vector3.new(0, 1, 0))
	if thisPather:IsValidPath() then
		HandleMoveTo(thisPather, position, nil, character, showPath)
		return true
	end
	return false
end
return ClickToMove
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX62"><Properties><string name="Name">TouchThumbpad</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local DPAD_SHEET = "rbxasset://textures/ui/DPadSheet.png"
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local UNIT_Z = Vector3.new(0, 0, 1)
local UNIT_X = Vector3.new(1, 0, 0)
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchThumbpad = setmetatable({}, BaseCharacterController)
TouchThumbpad.__index = TouchThumbpad
function TouchThumbpad.new()
	local self = setmetatable(BaseCharacterController.new(), TouchThumbpad)
	self.thumbpadFrame = nil
	self.touchChangedConn = nil
	self.touchEndedConn = nil
	self.menuOpenedConn = nil
	self.screenPos = nil
	self.isRight, self.isLeft, self.isUp, self.isDown = false, false, false, false
	self.smArrowSize = nil
	self.lgArrowSize = nil
	self.smImgOffset = nil
	self.lgImgOffset = nil
	return self
end
local doTween = function(guiObject, endSize, endPosition)
	guiObject:TweenSizeAndPosition(endSize, endPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, 0.15, true)
end
local function CreateArrowLabel(name, position, size, rectOffset, rectSize, parent)
	local image = Instance.new("ImageLabel")
	image.Name = name
	image.Image = DPAD_SHEET
	image.ImageRectOffset = rectOffset
	image.ImageRectSize = rectSize
	image.BackgroundTransparency = 1
	image.ImageColor3 = Color3.fromRGB(190, 190, 190)
	image.Size = size
	image.Position = position
	image.Parent = parent
	return image
end
function TouchThumbpad:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		if not self.thumbpadFrame then
			self:Create(uiParentFrame)
		end
		self.thumbpadFrame.Visible = true
	else
		self.thumbpadFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end
function TouchThumbpad:OnInputEnded()
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	self.thumbpadFrame.Position = self.screenPos
	self.touchObject = nil
	self.isUp, self.isDown, self.isLeft, self.isRight = false, false, false, false
	doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset))
	doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset))
	doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
	doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
end
function TouchThumbpad:Create(parentFrame)
	if self.thumbpadFrame then
		self.thumbpadFrame:Destroy()
		self.thumbpadFrame = nil
	end
	if self.touchChangedConn then
		self.touchChangedConn:Disconnect()
		self.touchChangedConn = nil
	end
	if self.touchEndedConn then
		self.touchEndedConn:Disconnect()
		self.touchEndedConn = nil
	end
	if self.menuOpenedConn then
		self.menuOpenedConn:Disconnect()
		self.menuOpenedConn = nil
	end
	local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	local thumbpadSize = isSmallScreen and 70 or 120
	self.screenPos = isSmallScreen and UDim2.new(0, thumbpadSize * 1.25, 1, -thumbpadSize - 20) or UDim2.new(0, thumbpadSize * 0.5 - 10, 1, -thumbpadSize * 1.75 - 10)
	self.thumbpadFrame = Instance.new("Frame")
	self.thumbpadFrame.Name = "ThumbpadFrame"
	self.thumbpadFrame.Visible = false
	self.thumbpadFrame.Active = true
	self.thumbpadFrame.Size = UDim2.new(0, thumbpadSize + 20, 0, thumbpadSize + 20)
	self.thumbpadFrame.Position = self.screenPos
	self.thumbpadFrame.BackgroundTransparency = 1
	local outerImage = Instance.new("ImageLabel")
	outerImage.Name = "OuterImage"
	outerImage.Image = TOUCH_CONTROL_SHEET
	outerImage.ImageRectOffset = Vector2.new(0, 0)
	outerImage.ImageRectSize = Vector2.new(220, 220)
	outerImage.BackgroundTransparency = 1
	outerImage.Size = UDim2.new(0, thumbpadSize, 0, thumbpadSize)
	outerImage.Position = UDim2.new(0, 10, 0, 10)
	outerImage.Parent = self.thumbpadFrame
	self.smArrowSize = isSmallScreen and UDim2.new(0, 32, 0, 32) or UDim2.new(0, 64, 0, 64)
	self.lgArrowSize = UDim2.new(0, self.smArrowSize.X.Offset * 2, 0, self.smArrowSize.Y.Offset * 2)
	local imgRectSize = Vector2.new(110, 110)
	self.smImgOffset = isSmallScreen and -4 or -9
	self.lgImgOffset = isSmallScreen and -28 or -55
	self.dArrow = CreateArrowLabel("DownArrow", UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset), self.smArrowSize, Vector2.new(8, 8), imgRectSize, outerImage)
	self.uArrow = CreateArrowLabel("UpArrow", UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset), self.smArrowSize, Vector2.new(8, 266), imgRectSize, outerImage)
	self.lArrow = CreateArrowLabel("LeftArrow", UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset), self.smArrowSize, Vector2.new(137, 137), imgRectSize, outerImage)
	self.rArrow = CreateArrowLabel("RightArrow", UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset), self.smArrowSize, Vector2.new(8, 137), imgRectSize, outerImage)
	local doTween = function(guiObject, endSize, endPosition)
		guiObject:TweenSizeAndPosition(endSize, endPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, 0.15, true)
	end
	local padOrigin
	local deadZone = 0.1
	self.isRight, self.isLeft, self.isUp, self.isDown = false, false, false, false
	local function doMove(pos)
		local moveDelta = pos - padOrigin
		local moveVector2 = 2 * moveDelta / thumbpadSize
		if moveVector2.Magnitude < deadZone then
			self.moveVector = ZERO_VECTOR3
		else
			moveVector2 = moveVector2.unit * ((moveVector2.Magnitude - deadZone) / (1 - deadZone))
			if moveVector2.Magnitude == 0 then
				self.moveVector = ZERO_VECTOR3
			else
				self.moveVector = Vector3.new(moveVector2.x, 0, moveVector2.y).Unit
			end
		end
		local forwardDot = self.moveVector:Dot(-UNIT_Z)
		local rightDot = self.moveVector:Dot(UNIT_X)
		if forwardDot > 0.5 then
			if not self.isUp then
				self.isUp, self.isDown = true, false
				doTween(self.uArrow, self.lgArrowSize, UDim2.new(0.5, -self.smArrowSize.X.Offset, 0, self.smImgOffset - 1.5 * self.smArrowSize.Y.Offset))
				doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset))
			end
		elseif forwardDot < -0.5 then
			if not self.isDown then
				self.isDown, self.isUp = true, false
				doTween(self.dArrow, self.lgArrowSize, UDim2.new(0.5, -self.smArrowSize.X.Offset, 1, self.lgImgOffset + 0.5 * self.smArrowSize.Y.Offset))
				doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset))
			end
		else
			self.isUp, self.isDown = false, false
			doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset))
			doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset))
		end
		if rightDot > 0.5 then
			if not self.isRight then
				self.isRight, self.isLeft = true, false
				doTween(self.rArrow, self.lgArrowSize, UDim2.new(1, self.lgImgOffset + 0.5 * self.smArrowSize.X.Offset, 0.5, -self.smArrowSize.Y.Offset))
				doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
			end
		elseif rightDot < -0.5 then
			if not self.isLeft then
				self.isLeft, self.isRight = true, false
				doTween(self.lArrow, self.lgArrowSize, UDim2.new(0, self.smImgOffset - 1.5 * self.smArrowSize.X.Offset, 0.5, -self.smArrowSize.Y.Offset))
				doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
			end
		else
			self.isRight, self.isLeft = false, false
			doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
			doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
		end
	end
	self.thumbpadFrame.InputBegan:connect(function(inputObject)
		if self.touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		self.thumbpadFrame.Position = UDim2.new(0, inputObject.Position.x - 0.5 * self.thumbpadFrame.AbsoluteSize.x, 0, inputObject.Position.y - 0.5 * self.thumbpadFrame.Size.Y.Offset)
		padOrigin = Vector3.new(self.thumbpadFrame.AbsolutePosition.x + 0.5 * self.thumbpadFrame.AbsoluteSize.x, self.thumbpadFrame.AbsolutePosition.y + 0.5 * self.thumbpadFrame.AbsoluteSize.y, 0)
		doMove(inputObject.Position)
		self.touchObject = inputObject
	end)
	self.touchChangedConn = UserInputService.TouchMoved:connect(function(inputObject, isProcessed)
		if inputObject == self.touchObject then
			doMove(self.touchObject.Position)
		end
	end)
	self.touchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject)
		if inputObject == self.touchObject then
			self:OnInputEnded()
		end
	end)
	self.menuOpenedConn = GuiService.MenuOpened:Connect(function()
		if self.touchObject then
			self:OnInputEnded()
		end
	end)
	self.thumbpadFrame.Parent = parentFrame
end
return TouchThumbpad
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX67"><Properties><string name="Name">Keyboard</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local Keyboard = setmetatable({}, BaseCharacterController)
Keyboard.__index = Keyboard
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
function Keyboard.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new(), Keyboard)
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	self.textFocusReleasedConn = nil
	self.textFocusGainedConn = nil
	self.windowFocusReleasedConn = nil
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.jumpEnabled = true
	return self
end
function Keyboard:Enable(enable)
	if not UserInputService.KeyboardEnabled then
		return false
	end
	if enable == self.enabled then
		return true
	end
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		self:BindContextActions()
		self:ConnectFocusEventListeners()
	else
		self:UnbindContextActions()
		self:DisconnectFocusEventListeners()
	end
	self.enabled = enable
	return true
end
function Keyboard:UpdateMovement(inputState)
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector = ZERO_VECTOR3
	else
		self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
	end
end
function Keyboard:BindContextActions()
	local function handleMoveForward(actionName, inputState, inputObject)
		self.forwardValue = inputState == Enum.UserInputState.Begin and -1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleMoveBackward(actionName, inputState, inputObject)
		self.backwardValue = inputState == Enum.UserInputState.Begin and 1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleMoveLeft(actionName, inputState, inputObject)
		self.leftValue = inputState == Enum.UserInputState.Begin and -1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleMoveRight(actionName, inputState, inputObject)
		self.rightValue = inputState == Enum.UserInputState.Begin and 1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleJumpAction(actionName, inputState, inputObject)
		self.isJumping = self.jumpEnabled and inputState == Enum.UserInputState.Begin
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		ContextActionService:BindActionAtPriority("moveForwardAction", handleMoveForward, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterForward)
		ContextActionService:BindActionAtPriority("moveBackwardAction", handleMoveBackward, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterBackward)
		ContextActionService:BindActionAtPriority("moveLeftAction", handleMoveLeft, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterLeft)
		ContextActionService:BindActionAtPriority("moveRightAction", handleMoveRight, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterRight)
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterJump)
	else
		ContextActionService:BindAction("moveForwardAction", handleMoveForward, false, Enum.PlayerActions.CharacterForward)
		ContextActionService:BindAction("moveBackwardAction", handleMoveBackward, false, Enum.PlayerActions.CharacterBackward)
		ContextActionService:BindAction("moveLeftAction", handleMoveLeft, false, Enum.PlayerActions.CharacterLeft)
		ContextActionService:BindAction("moveRightAction", handleMoveRight, false, Enum.PlayerActions.CharacterRight)
		ContextActionService:BindAction("jumpAction", handleJumpAction, false, Enum.PlayerActions.CharacterJump)
	end
end
function Keyboard:UnbindContextActions()
	ContextActionService:UnbindAction("moveForwardAction")
	ContextActionService:UnbindAction("moveBackwardAction")
	ContextActionService:UnbindAction("moveLeftAction")
	ContextActionService:UnbindAction("moveRightAction")
	ContextActionService:UnbindAction("jumpAction")
end
function Keyboard:ConnectFocusEventListeners()
	local function onFocusReleased()
		self.moveVector = ZERO_VECTOR3
		self.forwardValue = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.isJumping = false
	end
	local function onTextFocusGained(textboxFocused)
		self.isJumping = false
	end
	self.textFocusReleasedConn = UserInputService.TextBoxFocusReleased:Connect(onFocusReleased)
	self.textFocusGainedConn = UserInputService.TextBoxFocused:Connect(onTextFocusGained)
	self.windowFocusReleasedConn = UserInputService.WindowFocused:Connect(onFocusReleased)
end
function Keyboard:DisconnectFocusEventListeners()
	if self.textFocusReleasedCon then
		self.textFocusReleasedCon:Disconnect()
		self.textFocusReleasedCon = nil
	end
	if self.textFocusGainedConn then
		self.textFocusGainedConn:Disconnect()
		self.textFocusGainedConn = nil
	end
	if self.windowFocusReleasedConn then
		self.windowFocusReleasedConn:Disconnect()
		self.windowFocusReleasedConn = nil
	end
end
return Keyboard
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX72"><Properties><string name="Name">TouchThumbstick</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchThumbstick = setmetatable({}, BaseCharacterController)
TouchThumbstick.__index = TouchThumbstick
function TouchThumbstick.new()
	local self = setmetatable(BaseCharacterController.new(), TouchThumbstick)
	self.isFollowStick = false
	self.thumbstickFrame = nil
	self.moveTouchObject = nil
	self.onTouchMovedConn = nil
	self.onTouchEndedConn = nil
	self.screenPos = nil
	self.stickImage = nil
	self.thumbstickSize = nil
	return self
end
function TouchThumbstick:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		if not self.thumbstickFrame then
			self:Create(uiParentFrame)
		end
		self.thumbstickFrame.Visible = true
	else
		self.thumbstickFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end
function TouchThumbstick:OnInputEnded()
	self.thumbstickFrame.Position = self.screenPos
	self.stickImage.Position = UDim2.new(0, self.thumbstickFrame.Size.X.Offset / 2 - self.thumbstickSize / 4, 0, self.thumbstickFrame.Size.Y.Offset / 2 - self.thumbstickSize / 4)
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	self.thumbstickFrame.Position = self.screenPos
	self.moveTouchObject = nil
end
function TouchThumbstick:Create(parentFrame)
	if self.thumbstickFrame then
		self.thumbstickFrame:Destroy()
		self.thumbstickFrame = nil
		if self.onTouchMovedConn then
			self.onTouchMovedConn:Disconnect()
			self.onTouchMovedConn = nil
		end
		if self.onTouchEndedConn then
			self.onTouchEndedConn:Disconnect()
			self.onTouchEndedConn = nil
		end
	end
	local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	self.thumbstickSize = isSmallScreen and 70 or 120
	self.screenPos = isSmallScreen and UDim2.new(0, self.thumbstickSize / 2 - 10, 1, -self.thumbstickSize - 20) or UDim2.new(0, self.thumbstickSize / 2, 1, -self.thumbstickSize * 1.75)
	self.thumbstickFrame = Instance.new("Frame")
	self.thumbstickFrame.Name = "ThumbstickFrame"
	self.thumbstickFrame.Active = true
	self.thumbstickFrame.Visible = false
	self.thumbstickFrame.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
	self.thumbstickFrame.Position = self.screenPos
	self.thumbstickFrame.BackgroundTransparency = 1
	local outerImage = Instance.new("ImageLabel")
	outerImage.Name = "OuterImage"
	outerImage.Image = TOUCH_CONTROL_SHEET
	outerImage.ImageRectOffset = Vector2.new()
	outerImage.ImageRectSize = Vector2.new(220, 220)
	outerImage.BackgroundTransparency = 1
	outerImage.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
	outerImage.Position = UDim2.new(0, 0, 0, 0)
	outerImage.Parent = self.thumbstickFrame
	self.stickImage = Instance.new("ImageLabel")
	self.stickImage.Name = "StickImage"
	self.stickImage.Image = TOUCH_CONTROL_SHEET
	self.stickImage.ImageRectOffset = Vector2.new(220, 0)
	self.stickImage.ImageRectSize = Vector2.new(111, 111)
	self.stickImage.BackgroundTransparency = 1
	self.stickImage.Size = UDim2.new(0, self.thumbstickSize / 2, 0, self.thumbstickSize / 2)
	self.stickImage.Position = UDim2.new(0, self.thumbstickSize / 2 - self.thumbstickSize / 4, 0, self.thumbstickSize / 2 - self.thumbstickSize / 4)
	self.stickImage.ZIndex = 2
	self.stickImage.Parent = self.thumbstickFrame
	local centerPosition
	local deadZone = 0.05
	local function DoMove(direction)
		local currentMoveVector = direction / (self.thumbstickSize / 2)
		local inputAxisMagnitude = currentMoveVector.magnitude
		if inputAxisMagnitude < deadZone then
			currentMoveVector = Vector3.new()
		else
			currentMoveVector = currentMoveVector.unit * ((inputAxisMagnitude - deadZone) / (1 - deadZone))
			currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
		end
		self.moveVector = currentMoveVector
	end
	local function MoveStick(pos)
		local relativePosition = Vector2.new(pos.x - centerPosition.x, pos.y - centerPosition.y)
		local length = relativePosition.magnitude
		local maxLength = self.thumbstickFrame.AbsoluteSize.x / 2
		if self.isFollowStick and length > maxLength then
			local offset = relativePosition.unit * maxLength
			self.thumbstickFrame.Position = UDim2.new(0, pos.x - self.thumbstickFrame.AbsoluteSize.x / 2 - offset.x, 0, pos.y - self.thumbstickFrame.AbsoluteSize.y / 2 - offset.y)
		else
			length = math.min(length, maxLength)
			relativePosition = relativePosition.unit * length
		end
		self.stickImage.Position = UDim2.new(0, relativePosition.x + self.stickImage.AbsoluteSize.x / 2, 0, relativePosition.y + self.stickImage.AbsoluteSize.y / 2)
	end
	self.thumbstickFrame.InputBegan:Connect(function(inputObject)
		if self.moveTouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		self.moveTouchObject = inputObject
		self.thumbstickFrame.Position = UDim2.new(0, inputObject.Position.x - self.thumbstickFrame.Size.X.Offset / 2, 0, inputObject.Position.y - self.thumbstickFrame.Size.Y.Offset / 2)
		centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x / 2, self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y / 2)
		local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
	end)
	self.onTouchMovedConn = UserInputService.TouchMoved:Connect(function(inputObject, isProcessed)
		if inputObject == self.moveTouchObject then
			centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x / 2, self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y / 2)
			local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
			DoMove(direction)
			MoveStick(inputObject.Position)
		end
	end)
	self.onTouchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject, isProcessed)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	GuiService.MenuOpened:Connect(function()
		if self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	self.thumbstickFrame.Parent = parentFrame
end
return TouchThumbstick
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX77"><Properties><string name="Name">TouchDPad</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local DPAD_SHEET = "rbxasset://textures/ui/DPadSheet.png"
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local COMPASS_DIR = {
	Vector3.new(1, 0, 0),
	Vector3.new(1, 0, 1).unit,
	Vector3.new(0, 0, 1),
	Vector3.new(-1, 0, 1).unit,
	Vector3.new(-1, 0, 0),
	Vector3.new(-1, 0, -1).unit,
	Vector3.new(0, 0, -1),
	Vector3.new(1, 0, -1).unit
}
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchDPad = setmetatable({}, BaseCharacterController)
TouchDPad.__index = TouchDPad
function TouchDPad.new()
	local self = setmetatable(BaseCharacterController.new(), TouchDPad)
	self.DPadFrame = nil
	self.touchObject = nil
	self.flBtn = nil
	self.frBtn = nil
	return self
end
local function CreateArrowLabel(name, position, size, rectOffset, rectSize, parent)
	local image = Instance.new("ImageLabel")
	image.Name = name
	image.Image = DPAD_SHEET
	image.ImageRectOffset = rectOffset
	image.ImageRectSize = rectSize
	image.BackgroundTransparency = 1
	image.Size = size
	image.Position = position
	image.Parent = parent
	return image
end
function TouchDPad:GetCenterPosition()
	return Vector2.new(self.DPadFrame.AbsolutePosition.x + self.DPadFrame.AbsoluteSize.x * 0.5, self.DPadFrame.AbsolutePosition.y + self.DPadFrame.AbsoluteSize.y * 0.5)
end
function TouchDPad:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		if not self.DPadFrame then
			self:Create(uiParentFrame)
		end
		self.DPadFrame.Visible = true
	else
		self.DPadFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end
function TouchDPad:GetIsJumping()
	local wasJumping = self.isJumping
	self.isJumping = false
	return wasJumping
end
function TouchDPad:OnInputEnded()
	self.touchObject = nil
	if self.flBtn then
		self.flBtn.Visible = false
	end
	if self.frBtn then
		self.frBtn.Visible = false
	end
	self.moveVector = ZERO_VECTOR3
end
function TouchDPad:Create(parentFrame)
	if self.DPadFrame then
		self.DPadFrame:Destroy()
		self.DPadFrame = nil
	end
	local position = UDim2.new(0, 10, 1, -230)
	self.DPadFrame = Instance.new("Frame")
	self.DPadFrame.Name = "DPadFrame"
	self.DPadFrame.Active = true
	self.DPadFrame.Visible = false
	self.DPadFrame.Size = UDim2.new(0, 192, 0, 192)
	self.DPadFrame.Position = position
	self.DPadFrame.BackgroundTransparency = 1
	local smArrowSize = UDim2.new(0, 23, 0, 23)
	local lgArrowSize = UDim2.new(0, 64, 0, 64)
	local smImgOffset = Vector2.new(46, 46)
	local lgImgOffset = Vector2.new(128, 128)
	local bBtn = CreateArrowLabel("BackButton", UDim2.new(0.5, -32, 1, -64), lgArrowSize, Vector2.new(0, 0), lgImgOffset, self.DPadFrame)
	local fBtn = CreateArrowLabel("ForwardButton", UDim2.new(0.5, -32, 0, 0), lgArrowSize, Vector2.new(0, 258), lgImgOffset, self.DPadFrame)
	local lBtn = CreateArrowLabel("LeftButton", UDim2.new(0, 0, 0.5, -32), lgArrowSize, Vector2.new(129, 129), lgImgOffset, self.DPadFrame)
	local rBtn = CreateArrowLabel("RightButton", UDim2.new(1, -64, 0.5, -32), lgArrowSize, Vector2.new(0, 129), lgImgOffset, self.DPadFrame)
	local jumpBtn = CreateArrowLabel("JumpButton", UDim2.new(0.5, -32, 0.5, -32), lgArrowSize, Vector2.new(129, 0), lgImgOffset, self.DPadFrame)
	self.flBtn = CreateArrowLabel("ForwardLeftButton", UDim2.new(0, 35, 0, 35), smArrowSize, Vector2.new(129, 258), smImgOffset, self.DPadFrame)
	self.frBtn = CreateArrowLabel("ForwardRightButton", UDim2.new(1, -55, 0, 35), smArrowSize, Vector2.new(176, 258), smImgOffset, self.DPadFrame)
	self.flBtn.Visible = false
	self.frBtn.Visible = false
	jumpBtn.InputBegan:Connect(function(inputObject)
		self.isJumping = true
	end)
	local function normalizeDirection(inputPosition)
		local jumpRadius = jumpBtn.AbsoluteSize.x * 0.5
		local centerPosition = self:GetCenterPosition()
		local direction = Vector2.new(inputPosition.x - centerPosition.x, inputPosition.y - centerPosition.y)
		if jumpRadius < direction.magnitude then
			local angle = math.atan2(direction.y, direction.x)
			local octant = math.floor(8 * angle / (2 * math.pi) + 8.5) % 8 + 1
			self.moveVector = COMPASS_DIR[octant]
		end
		if not self.flBtn.Visible and self.moveVector == COMPASS_DIR[7] then
			self.flBtn.Visible = true
			self.frBtn.Visible = true
		end
	end
	self.DPadFrame.InputBegan:Connect(function(inputObject)
		if self.touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		self.touchObject = inputObject
		normalizeDirection(self.touchObject.Position)
	end)
	self.DPadFrame.InputChanged:Connect(function(inputObject)
		if inputObject == self.touchObject then
			normalizeDirection(self.touchObject.Position)
			self.isJumping = false
		end
	end)
	self.DPadFrame.InputEnded:connect(function(inputObject)
		if inputObject == self.touchObject then
			self:OnInputEnded()
		end
	end)
	GuiService.MenuOpened:Connect(function()
		if self.touchObject then
			self:OnInputEnded()
		end
	end)
	self.DPadFrame.Parent = parentFrame
end
return TouchDPad
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX82"><Properties><string name="Name">BaseCharacterController</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local Players = game:GetService("Players")
local BaseCharacterController = {}
BaseCharacterController.__index = BaseCharacterController
function BaseCharacterController.new()
	local self = setmetatable({}, BaseCharacterController)
	self.enabled = false
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	return self
end
function BaseCharacterController:GetMoveVector()
	return self.moveVector
end
function BaseCharacterController:GetIsJumping()
	return self.isJumping
end
function BaseCharacterController:Enable(enable)
	error("BaseCharacterController:Enable must be overridden in derived classes and should not be called.")
	return false
end
return BaseCharacterController
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX87"><Properties><string name="Name">Gamepad</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local NONE = Enum.UserInputType.None
local thumbstickDeadzone = 0.2
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local Gamepad = setmetatable({}, BaseCharacterController)
Gamepad.__index = Gamepad
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
function Gamepad.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new(), Gamepad)
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.activeGamepad = NONE
	self.gamepadConnectedConn = nil
	self.gamepadDisconnectedConn = nil
	return self
end
function Gamepad:Enable(enable)
	if not UserInputService.GamepadEnabled then
		return false
	end
	if enable == self.enabled then
		return true
	end
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		self.activeGamepad = self:GetHighestPriorityGamepad()
		if self.activeGamepad ~= NONE then
			self:BindContextActions()
			self:ConnectGamepadConnectionListeners()
		else
			return false
		end
	else
		self:UnbindContextActions()
		self:DisconnectGamepadConnectionListeners()
		self.activeGamepad = NONE
	end
	self.enabled = enable
	return true
end
function Gamepad:GetHighestPriorityGamepad()
	local connectedGamepads = UserInputService:GetConnectedGamepads()
	local bestGamepad = NONE
	for _, gamepad in pairs(connectedGamepads) do
		if gamepad.Value < bestGamepad.Value then
			bestGamepad = gamepad
		end
	end
	return bestGamepad
end
function Gamepad:BindContextActions()
	if self.activeGamepad == NONE then
		return false
	end
	local function updateMovement(inputState)
		if inputState == Enum.UserInputState.Cancel then
			self.moveVector = ZERO_VECTOR3
		else
			self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		end
	end
	local function handleMoveForward(actionName, inputState, inputObject)
		self.forwardValue = inputState == Enum.UserInputState.Begin and -1 or 0
		updateMovement(inputState)
	end
	local function handleMoveBackward(actionName, inputState, inputObject)
		self.backwardValue = inputState == Enum.UserInputState.Begin and 1 or 0
		updateMovement(inputState)
	end
	local function handleMoveLeft(actionName, inputState, inputObject)
		self.leftValue = inputState == Enum.UserInputState.Begin and -1 or 0
		updateMovement(inputState)
	end
	local function handleMoveRight(actionName, inputState, inputObject)
		self.rightValue = inputState == Enum.UserInputState.Begin and 1 or 0
		updateMovement(inputState)
	end
	local function handleJumpAction(actionName, inputState, inputObject)
		self.isJumping = inputState == Enum.UserInputState.Begin
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	local function handleThumbstickInput(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.Cancel then
			self.moveVector = ZERO_VECTOR3
			return FFlagPlayerScriptsBindAtPriority2 and Enum.ContextActionResult.Sink or nil
		end
		if self.activeGamepad ~= inputObject.UserInputType then
			return FFlagPlayerScriptsBindAtPriority2 and Enum.ContextActionResult.Pass or nil
		end
		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then
			return
		end
		if inputObject.Position.magnitude > thumbstickDeadzone then
			self.moveVector = Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
		else
			self.moveVector = ZERO_VECTOR3
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	if FFlagPlayerScriptsBindAtPriority2 then
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
		ContextActionService:BindActionAtPriority("moveThumbstick", handleThumbstickInput, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
	else
		ContextActionService:BindAction("jumpAction", handleJumpAction, false, Enum.KeyCode.ButtonA)
		ContextActionService:BindAction("moveThumbstick", handleThumbstickInput, false, Enum.KeyCode.Thumbstick1)
	end
	return true
end
function Gamepad:UnbindContextActions()
	if self.activeGamepad ~= NONE then
		ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
	ContextActionService:UnbindAction("moveThumbstick")
	ContextActionService:UnbindAction("jumpAction")
end
function Gamepad:OnNewGamepadConnected()
	local bestGamepad = self:GetHighestPriorityGamepad()
	if bestGamepad == self.activeGamepad then
		return
	end
	if bestGamepad == NONE then
		warn("Gamepad:OnNewGamepadConnected found no connected gamepads")
		self:UnbindContextActions()
		return
	end
	if self.activeGamepad ~= NONE then
		self:UnbindContextActions()
	end
	self.activeGamepad = bestGamepad
	self:BindContextActions()
end
function Gamepad:OnCurrentGamepadDisconnected()
	if self.activeGamepad ~= NONE then
		ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
	local bestGamepad = self:GetHighestPriorityGamepad()
	if self.activeGamepad ~= NONE and bestGamepad == self.activeGamepad then
		warn("Gamepad:OnCurrentGamepadDisconnected found the supposedly disconnected gamepad in connectedGamepads.")
		self:UnbindContextActions()
		self.activeGamepad = NONE
		return
	end
	if bestGamepad == NONE then
		self:UnbindContextActions()
		self.activeGamepad = NONE
	else
		self.activeGamepad = bestGamepad
		ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
end
function Gamepad:ConnectGamepadConnectionListeners()
	self.gamepadConnectedConn = UserInputService.GamepadConnected:Connect(function(gamepadEnum)
		self:OnNewGamepadConnected()
	end)
	self.gamepadDisconnectedConn = UserInputService.GamepadDisconnected:Connect(function(gamepadEnum)
		if self.activeGamepad == gamepadEnum then
			self:OnCurrentGamepadDisconnected()
		end
	end)
end
function Gamepad:DisconnectGamepadConnectionListeners()
	if self.gamepadConnectedConn then
		self.gamepadConnectedConn:Disconnect()
		self.gamepadConnectedConn = nil
	end
	if self.gamepadDisconnectedConn then
		self.gamepadDisconnectedConn:Disconnect()
		self.gamepadDisconnectedConn = nil
	end
end
return Gamepad
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX92"><Properties><string name="Name">LegacyCamera</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UNIT_X = Vector3.new(1, 0, 0)
local UNIT_Y = Vector3.new(0, 1, 0)
local UNIT_Z = Vector3.new(0, 0, 1)
local X1_Y0_Z1 = Vector3.new(1, 0, 1)
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local ZERO_VECTOR2 = Vector2.new(0, 0)
local VR_PITCH_FRACTION = 0.25
local tweenAcceleration = math.rad(220)
local tweenSpeed = math.rad(0)
local tweenMaxSpeed = math.rad(250)
local TIME_BEFORE_AUTO_ROTATE = 2
local PORTRAIT_OFFSET = Vector3.new(0, -3, 0)
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local VRService = game:GetService("VRService")
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local LegacyCamera = setmetatable({}, BaseCamera)
LegacyCamera.__index = LegacyCamera
function LegacyCamera.new()
	local self = setmetatable(BaseCamera.new(), LegacyCamera)
	self.cameraType = Enum.CameraType.Fixed
	self.lastUpdate = tick()
	self.lastDistanceToSubject = nil
	return self
end
function LegacyCamera:GetModuleName()
	return "LegacyCamera"
end
function LegacyCamera:Test()
	print("LegacyCamera:Test()")
end
function LegacyCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	return BaseCamera.SetCameraToSubjectDistance(self, desiredSubjectDistance)
end
function LegacyCamera:Update(dt)
	if not self.cameraType then
		return
	end
	local now = tick()
	local timeDelta = now - self.lastUpdate
	local camera = workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera and camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	local isOnASkateboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastDistanceToSubject = nil
	end
	local subjectPosition = self:GetSubjectPosition()
	if self.cameraType == Enum.CameraType.Fixed then
		if self.lastUpdate then
			local delta = math.min(0.1, now - self.lastUpdate)
			local gamepadRotation = self:UpdateGamepad()
			self.rotateInput = self.rotateInput + gamepadRotation * delta
		end
		if subjectPosition and player and camera then
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local newLookVector = self:CalculateNewLookVector()
			self.rotateInput = ZERO_VECTOR2
			newCameraFocus = camera.Focus
			newCameraCFrame = CFrame.new(camera.CFrame.p, camera.CFrame.p + distanceToSubject * newLookVector)
		end
	elseif self.cameraType == Enum.CameraType.Attach then
		if subjectPosition and camera then
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local humanoid = self:GetHumanoid()
			if self.lastUpdate and humanoid and humanoid.RootPart then
				local delta = math.min(0.1, now - self.lastUpdate)
				local gamepadRotation = self:UpdateGamepad()
				self.rotateInput = self.rotateInput + gamepadRotation * delta
				local forwardVector = humanoid.RootPart.CFrame.lookVector
				local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
				if Util.IsFinite(y) then
					self.rotateInput = Vector2.new(y, self.rotateInput.Y)
				end
			end
			local newLookVector = self:CalculateNewLookVector()
			self.rotateInput = ZERO_VECTOR2
			newCameraFocus = CFrame.new(subjectPosition)
			newCameraCFrame = CFrame.new(subjectPosition - distanceToSubject * newLookVector, subjectPosition)
		end
	elseif self.cameraType == Enum.CameraType.Watch then
		if subjectPosition and player and camera then
			local cameraLook
			local humanoid = self:GetHumanoid()
			if humanoid and humanoid.RootPart then
				local diffVector = subjectPosition - camera.CFrame.p
				cameraLook = diffVector.unit
				if self.lastDistanceToSubject and self.lastDistanceToSubject == self:GetCameraToSubjectDistance() then
					local newDistanceToSubject = diffVector.magnitude
					self:SetCameraToSubjectDistance(newDistanceToSubject)
				end
			end
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local newLookVector = self:CalculateNewLookVector(cameraLook)
			self.rotateInput = ZERO_VECTOR2
			newCameraFocus = CFrame.new(subjectPosition)
			newCameraCFrame = CFrame.new(subjectPosition - distanceToSubject * newLookVector, subjectPosition)
			self.lastDistanceToSubject = distanceToSubject
		end
	else
		return camera.CFrame, camera.Focus
	end
	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end
return LegacyCamera
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX97"><Properties><string name="Name">Poppercam</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZoomController = require(script.Parent:WaitForChild("ZoomController"))
local TransformExtrapolator = {}
TransformExtrapolator.__index = TransformExtrapolator
do
	local CF_IDENTITY = CFrame.new()
	local cframeToAxis = function(cframe)
		local axis, angle = cframe:toAxisAngle()
		return axis * angle
	end
	local function axisToCFrame(axis)
		local angle = axis.magnitude
		if angle > 1.0E-5 then
			return CFrame.fromAxisAngle(axis, angle)
		end
		return CF_IDENTITY
	end
	local extractRotation = function(cf)
		local _, _, _, xx, yx, zx, xy, yy, zy, xz, yz, zz = cf:components()
		return CFrame.new(0, 0, 0, xx, yx, zx, xy, yy, zy, xz, yz, zz)
	end
	function TransformExtrapolator.new()
		return setmetatable({lastCFrame = nil}, TransformExtrapolator)
	end
	function TransformExtrapolator:Step(dt, currentCFrame)
		local lastCFrame = self.lastCFrame or currentCFrame
		self.lastCFrame = currentCFrame
		local currentPos = currentCFrame.p
		local currentRot = extractRotation(currentCFrame)
		local lastPos = lastCFrame.p
		local lastRot = extractRotation(lastCFrame)
		local dp = (currentPos - lastPos) / dt
		local dr = cframeToAxis(currentRot * lastRot:inverse()) / dt
		local function extrapolate(t)
			local p = dp * t + currentPos
			local r = axisToCFrame(dr * t) * currentRot
			return r + p
		end
		return {
			extrapolate = extrapolate,
			posVelocity = dp,
			rotVelocity = dr
		}
	end
	function TransformExtrapolator:Reset()
		self.lastCFrame = nil
	end
end
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Poppercam = setmetatable({}, BaseOcclusion)
Poppercam.__index = Poppercam
function Poppercam.new()
	local self = setmetatable(BaseOcclusion.new(), Poppercam)
	self.focusExtrapolator = TransformExtrapolator.new()
	return self
end
function Poppercam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Zoom
end
function Poppercam:Enable(enable)
	self.focusExtrapolator:Reset()
end
function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
	local rotatedFocus = CFrame.new(desiredCameraFocus.p, desiredCameraCFrame.p) * CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1)
	local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
	local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
	return rotatedFocus * CFrame.new(0, 0, zoom), desiredCameraFocus
end
function Poppercam:CharacterAdded(character, player)
end
function Poppercam:CharacterRemoving(character, player)
end
function Poppercam:OnCameraSubjectChanged(newSubject)
end
return Poppercam
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX102"><Properties><string name="Name">TransparencyController</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local MAX_TWEEN_RATE = 2.8
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local TransparencyController = {}
TransparencyController.__index = TransparencyController
function TransparencyController.new()
	local self = setmetatable({}, TransparencyController)
	self.lastUpdate = tick()
	self.transparencyDirty = false
	self.enabled = false
	self.lastTransparency = nil
	self.descendantAddedConn, self.descendantRemovingConn = nil, nil
	self.toolDescendantAddedConns = {}
	self.toolDescendantRemovingConns = {}
	self.cachedParts = {}
	return self
end
function TransparencyController:HasToolAncestor(object)
	if object.Parent == nil then
		return false
	end
	return object.Parent:IsA("Tool") or self:HasToolAncestor(object.Parent)
end
function TransparencyController:IsValidPartToModify(part)
	if part:IsA("BasePart") or part:IsA("Decal") then
		return not self:HasToolAncestor(part)
	end
	return false
end
function TransparencyController:CachePartsRecursive(object)
	if object then
		if self:IsValidPartToModify(object) then
			self.cachedParts[object] = true
			self.transparencyDirty = true
		end
		for _, child in pairs(object:GetChildren()) do
			self:CachePartsRecursive(child)
		end
	end
end
function TransparencyController:TeardownTransparency()
	for child, _ in pairs(self.cachedParts) do
		child.LocalTransparencyModifier = 0
	end
	self.cachedParts = {}
	self.transparencyDirty = true
	self.lastTransparency = nil
	if self.descendantAddedConn then
		self.descendantAddedConn:disconnect()
		self.descendantAddedConn = nil
	end
	if self.descendantRemovingConn then
		self.descendantRemovingConn:disconnect()
		self.descendantRemovingConn = nil
	end
	for object, conn in pairs(self.toolDescendantAddedConns) do
		conn:Disconnect()
		self.toolDescendantAddedConns[object] = nil
	end
	for object, conn in pairs(self.toolDescendantRemovingConns) do
		conn:Disconnect()
		self.toolDescendantRemovingConns[object] = nil
	end
end
function TransparencyController:SetupTransparency(character)
	self:TeardownTransparency()
	if self.descendantAddedConn then
		self.descendantAddedConn:disconnect()
	end
	self.descendantAddedConn = character.DescendantAdded:Connect(function(object)
		if self:IsValidPartToModify(object) then
			self.cachedParts[object] = true
			self.transparencyDirty = true
		elseif object:IsA("Tool") then
			if self.toolDescendantAddedConns[object] then
				self.toolDescendantAddedConns[object]:Disconnect()
			end
			self.toolDescendantAddedConns[object] = object.DescendantAdded:Connect(function(toolChild)
				self.cachedParts[toolChild] = nil
				if toolChild:IsA("BasePart") or toolChild:IsA("Decal") then
					toolChild.LocalTransparencyModifier = 0
				end
			end)
			if self.toolDescendantRemovingConns[object] then
				self.toolDescendantRemovingConns[object]:disconnect()
			end
			self.toolDescendantRemovingConns[object] = object.DescendantRemoving:Connect(function(formerToolChild)
				wait()
				if character and formerToolChild and formerToolChild:IsDescendantOf(character) and self:IsValidPartToModify(formerToolChild) then
					self.cachedParts[formerToolChild] = true
					self.transparencyDirty = true
				end
			end)
		end
	end)
	if self.descendantRemovingConn then
		self.descendantRemovingConn:disconnect()
	end
	self.descendantRemovingConn = character.DescendantRemoving:connect(function(object)
		if self.cachedParts[object] then
			self.cachedParts[object] = nil
			object.LocalTransparencyModifier = 0
		end
	end)
	self:CachePartsRecursive(character)
end
function TransparencyController:Enable(enable)
	if self.enabled ~= enable then
		self.enabled = enable
		self:Update()
	end
end
function TransparencyController:SetSubject(subject)
	local character
	if subject and subject:IsA("Humanoid") then
		character = subject.Parent
	end
	if subject and subject:IsA("VehicleSeat") and subject.Occupant then
		character = subject.Occupant.Parent
	end
	if character then
		self:SetupTransparency(character)
	else
		self:TeardownTransparency()
	end
end
function TransparencyController:Update()
	local instant = false
	local now = tick()
	local currentCamera = workspace.CurrentCamera
	if currentCamera then
		local transparency = 0
		if not self.enabled then
			instant = true
		else
			local distance = (currentCamera.Focus.p - currentCamera.CoordinateFrame.p).magnitude
			transparency = distance < 2 and 1 - (distance - 0.5) / 1.5 or 0
			if transparency < 0.5 then
				transparency = 0
			end
			if self.lastTransparency then
				local deltaTransparency = transparency - self.lastTransparency
				if not instant and transparency < 1 and self.lastTransparency < 0.95 then
					local maxDelta = MAX_TWEEN_RATE * (now - self.lastUpdate)
					deltaTransparency = Util.Clamp(-maxDelta, maxDelta, deltaTransparency)
				end
				transparency = self.lastTransparency + deltaTransparency
			else
				self.transparencyDirty = true
			end
			transparency = Util.Clamp(0, 1, Util.Round(transparency, 2))
		end
		if self.transparencyDirty or self.lastTransparency ~= transparency then
			for child, _ in pairs(self.cachedParts) do
				child.LocalTransparencyModifier = transparency
			end
			self.transparencyDirty = false
			self.lastTransparency = transparency
		end
	end
	self.lastUpdate = now
end
return TransparencyController
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX107"><Properties><string name="Name">CameraModule</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local CameraModule = {}
CameraModule.__index = CameraModule
local PLAYER_CAMERA_PROPERTIES = {
	"CameraMinZoomDistance",
	"CameraMaxZoomDistance",
	"CameraMode",
	"DevCameraOcclusionMode",
	"DevComputerCameraMode",
	"DevTouchCameraMode",
	"DevComputerMovementMode",
	"DevTouchMovementMode",
	"DevEnableMouseLock"
}
local USER_GAME_SETTINGS_PROPERTIES = {
	"ComputerCameraMovementMode",
	"ComputerMovementMode",
	"ControlMode",
	"GamepadCameraSensitivity",
	"MouseSensitivity",
	"RotationType",
	"TouchCameraMovementMode",
	"TouchMovementMode"
}
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterPlayer = game:GetService("StarterPlayer")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local CameraUtils = require(script:WaitForChild("CameraUtils"))
local ClassicCamera = require(script:WaitForChild("ClassicCamera"))
local OrbitalCamera = require(script:WaitForChild("OrbitalCamera"))
local LegacyCamera = require(script:WaitForChild("LegacyCamera"))
local Invisicam = require(script:WaitForChild("Invisicam"))
local Poppercam
do
	local success, useNewPoppercam = pcall(UserSettings().IsUserFeatureEnabled, UserSettings(), "UserNewPoppercam4")
	if success and useNewPoppercam then
		Poppercam = require(script:WaitForChild("Poppercam"))
	else
		Poppercam = require(script:WaitForChild("Poppercam_Classic"))
	end
end
local TransparencyController = require(script:WaitForChild("TransparencyController"))
local MouseLockController = require(script:WaitForChild("MouseLockController"))
local instantiatedCameraControllers = {}
local instantiatedOcclusionModules = {}
do
	local PlayerScripts = Players.LocalPlayer:WaitForChild("PlayerScripts")
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Default)
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Follow)
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Classic)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Default)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Follow)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Classic)
end
function CameraModule.new()
	local self = setmetatable({}, CameraModule)
	self.activeCameraController = nil
	self.activeOcclusionModule = nil
	self.activeTransparencyController = nil
	self.activeMouseLockController = nil
	self.currentComputerCameraMovementMode = nil
	self.cameraSubjectChangedConn = nil
	self.cameraTypeChangedConn = nil
	for _, player in pairs(Players:GetPlayers()) do
		self:OnPlayerAdded(player)
	end
	Players.PlayerAdded:Connect(function(player)
		self:OnPlayerAdded(player)
	end)
	self.activeTransparencyController = TransparencyController.new()
	self.activeTransparencyController:Enable(true)
	if not UserInputService.TouchEnabled then
		self.activeMouseLockController = MouseLockController.new()
		local toggleEvent = self.activeMouseLockController:GetBindableToggleEvent()
		if toggleEvent then
			toggleEvent:Connect(function()
				self:OnMouseLockToggled()
			end)
		end
	end
	self:ActivateCameraController(self:GetCameraControlChoice())
	self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
	self:OnCurrentCameraChanged()
	RunService:BindToRenderStep("cameraRenderUpdate", Enum.RenderPriority.Camera.Value, function(dt)
		self:Update(dt)
	end)
	for _, propertyName in pairs(PLAYER_CAMERA_PROPERTIES) do
		Players.LocalPlayer:GetPropertyChangedSignal(propertyName):Connect(function()
			self:OnLocalPlayerCameraPropertyChanged(propertyName)
		end)
	end
	for _, propertyName in pairs(USER_GAME_SETTINGS_PROPERTIES) do
		UserGameSettings:GetPropertyChangedSignal(propertyName):Connect(function()
			self:OnUserGameSettingsPropertyChanged(propertyName)
		end)
	end
	game.Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		self:OnCurrentCameraChanged()
	end)
	self.lastInputType = UserInputService:GetLastInputType()
	UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
		self.lastInputType = newLastInputType
	end)
	return self
end
function CameraModule:GetCameraMovementModeFromSettings()
	local cameraMode = Players.LocalPlayer.CameraMode
	if cameraMode == Enum.CameraMode.LockFirstPerson then
		return CameraUtils.ConvertCameraModeEnumToStandard(Enum.ComputerCameraMovementMode.Classic)
	end
	local devMode, userMode
	if UserInputService.TouchEnabled then
		devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevTouchCameraMode)
		userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
	else
		devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevComputerCameraMode)
		userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
	end
	if devMode == Enum.DevComputerCameraMovementMode.UserChoice then
		return userMode
	end
	return devMode
end
function CameraModule:ActivateOcclusionModule(occlusionMode)
	local newModuleCreator
	if occlusionMode == Enum.DevCameraOcclusionMode.Zoom then
		newModuleCreator = Poppercam
	elseif occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
		newModuleCreator = Invisicam
	else
		warn("CameraScript ActivateOcclusionModule called with unsupported mode")
		return
	end
	if self.activeOcclusionModule and self.activeOcclusionModule:GetOcclusionMode() == occlusionMode then
		if not self.activeOcclusionModule:GetEnabled() then
			self.activeOcclusionModule:Enable(true)
		end
		return
	end
	local prevOcclusionModule = self.activeOcclusionModule
	self.activeOcclusionModule = instantiatedOcclusionModules[newModuleCreator]
	if not self.activeOcclusionModule then
		self.activeOcclusionModule = newModuleCreator.new()
		if self.activeOcclusionModule then
			instantiatedOcclusionModules[newModuleCreator] = self.activeOcclusionModule
		end
	end
	if self.activeOcclusionModule then
		local newModuleOcclusionMode = self.activeOcclusionModule:GetOcclusionMode()
		if newModuleOcclusionMode ~= occlusionMode then
			warn("CameraScript ActivateOcclusionModule mismatch: ", self.activeOcclusionModule:GetOcclusionMode(), "~=", occlusionMode)
		end
		if prevOcclusionModule then
			if prevOcclusionModule ~= self.activeOcclusionModule then
				prevOcclusionModule:Enable(false)
			else
				warn("CameraScript ActivateOcclusionModule failure to detect already running correct module")
			end
		end
		if occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
			if Players.LocalPlayer.Character then
				self.activeOcclusionModule:CharacterAdded(Players.LocalPlayer.Character, Players.LocalPlayer)
			end
		else
			for _, player in pairs(Players:GetPlayers()) do
				if player and player.Character then
					self.activeOcclusionModule:CharacterAdded(player.Character, player)
				end
			end
			self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
		end
		self.activeOcclusionModule:Enable(true)
	end
end
function CameraModule:ActivateCameraController(cameraMovementMode, legacyCameraType)
	local newCameraCreator
	if legacyCameraType ~= nil then
		if legacyCameraType == Enum.CameraType.Scriptable then
			if self.activeCameraController then
				self.activeCameraController:Enable(false)
				self.activeCameraController = nil
				return
			end
		elseif legacyCameraType == Enum.CameraType.Custom then
			cameraMovementMode = self:GetCameraMovementModeFromSettings()
		elseif legacyCameraType == Enum.CameraType.Track then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Classic
		elseif legacyCameraType == Enum.CameraType.Follow then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Follow
		elseif legacyCameraType == Enum.CameraType.Orbital then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Orbital
		elseif legacyCameraType == Enum.CameraType.Attach or legacyCameraType == Enum.CameraType.Watch or legacyCameraType == Enum.CameraType.Fixed then
			newCameraCreator = LegacyCamera
		else
			warn("CameraScript encountered an unhandled Camera.CameraType value: ", legacyCameraType)
		end
	end
	if not newCameraCreator then
		if cameraMovementMode == Enum.ComputerCameraMovementMode.Classic or cameraMovementMode == Enum.ComputerCameraMovementMode.Follow or cameraMovementMode == Enum.ComputerCameraMovementMode.Default then
			newCameraCreator = ClassicCamera
		elseif cameraMovementMode == Enum.ComputerCameraMovementMode.Orbital then
			newCameraCreator = OrbitalCamera
		else
			warn("ActivateCameraController did not select a module.")
			return
		end
	end
	local newCameraController
	if not instantiatedCameraControllers[newCameraCreator] then
		newCameraController = newCameraCreator.new()
		instantiatedCameraControllers[newCameraCreator] = newCameraController
	else
		newCameraController = instantiatedCameraControllers[newCameraCreator]
	end
	if self.activeCameraController then
		if self.activeCameraController ~= newCameraController then
			self.activeCameraController:Enable(false)
			self.activeCameraController = newCameraController
			self.activeCameraController:Enable(true)
		elseif not self.activeCameraController:GetEnabled() then
			self.activeCameraController:Enable(true)
		end
	elseif newCameraController ~= nil then
		self.activeCameraController = newCameraController
		self.activeCameraController:Enable(true)
	end
	if self.activeCameraController then
		if cameraMovementMode ~= nil then
			self.activeCameraController:SetCameraMovementMode(cameraMovementMode)
		elseif legacyCameraType ~= nil then
			self.activeCameraController:SetCameraType(legacyCameraType)
		end
	end
end
function CameraModule:OnCameraSubjectChanged()
	if self.activeTransparencyController then
		self.activeTransparencyController:SetSubject(game.Workspace.CurrentCamera.CameraSubject)
	end
	if self.activeOcclusionModule then
		self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
	end
end
function CameraModule:OnCameraTypeChanged(newCameraType)
	if newCameraType == Enum.CameraType.Scriptable and UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
	self:ActivateCameraController(nil, newCameraType)
end
function CameraModule:OnCurrentCameraChanged()
	local currentCamera = game.Workspace.CurrentCamera
	if not currentCamera then
		return
	end
	if self.cameraSubjectChangedConn then
		self.cameraSubjectChangedConn:Disconnect()
	end
	if self.cameraTypeChangedConn then
		self.cameraTypeChangedConn:Disconnect()
	end
	self.cameraSubjectChangedConn = currentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
		self:OnCameraSubjectChanged(currentCamera.CameraSubject)
	end)
	self.cameraTypeChangedConn = currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
		self:OnCameraTypeChanged(currentCamera.CameraType)
	end)
	self:OnCameraSubjectChanged(currentCamera.CameraSubject)
	self:OnCameraTypeChanged(currentCamera.CameraType)
end
function CameraModule:OnLocalPlayerCameraPropertyChanged(propertyName)
	if propertyName == "CameraMode" then
		if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
			if not self.activeCameraController or self.activeCameraController:GetModuleName() ~= "ClassicCamera" then
				self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(Enum.DevComputerCameraMovementMode.Classic))
			end
			if self.activeCameraController then
				self.activeCameraController:UpdateForDistancePropertyChange()
			end
		elseif Players.LocalPlayer.CameraMode == Enum.CameraMode.Classic then
			local cameraMovementMode = self:GetCameraMovementModeFromSettings()
			self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
		else
			warn("Unhandled value for property player.CameraMode: ", Players.LocalPlayer.CameraMode)
		end
	elseif propertyName == "DevComputerCameraMode" or propertyName == "DevTouchCameraMode" then
		local cameraMovementMode = self:GetCameraMovementModeFromSettings()
		self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
	elseif propertyName == "DevCameraOcclusionMode" then
		self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
	elseif propertyName == "CameraMinZoomDistance" or propertyName == "CameraMaxZoomDistance" then
		if self.activeCameraController then
			self.activeCameraController:UpdateForDistancePropertyChange()
		end
	elseif propertyName == "DevTouchMovementMode" then
	elseif propertyName == "DevComputerMovementMode" then
	elseif propertyName == "DevEnableMouseLock" then
	end
end
function CameraModule:OnUserGameSettingsPropertyChanged(propertyName)
	if propertyName == "ComputerCameraMovementMode" then
		local cameraMovementMode = self:GetCameraMovementModeFromSettings()
		self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
	end
end
function CameraModule:Update(dt)
	if self.activeCameraController then
		local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)
		self.activeCameraController:ApplyVRTransform()
		if self.activeOcclusionModule then
			newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
		end
		game.Workspace.CurrentCamera.CFrame = newCameraCFrame
		game.Workspace.CurrentCamera.Focus = newCameraFocus
		if self.activeTransparencyController then
			self.activeTransparencyController:Update()
		end
	end
end
function CameraModule:GetCameraControlChoice()
	local player = Players.LocalPlayer
	if player then
		if self.lastInputType == Enum.UserInputType.Touch or UserInputService.TouchEnabled then
			if player.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice then
				return CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
			else
				return CameraUtils.ConvertCameraModeEnumToStandard(player.DevTouchCameraMode)
			end
		elseif player.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice then
			local computerMovementMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
			return CameraUtils.ConvertCameraModeEnumToStandard(computerMovementMode)
		else
			return CameraUtils.ConvertCameraModeEnumToStandard(player.DevComputerCameraMode)
		end
	end
end
function CameraModule:OnCharacterAdded(char, player)
	if self.activeOcclusionModule then
		self.activeOcclusionModule:CharacterAdded(char, player)
	end
end
function CameraModule:OnCharacterRemoving(char, player)
	if self.activeOcclusionModule then
		self.activeOcclusionModule:CharacterRemoving(char, player)
	end
end
function CameraModule:OnPlayerAdded(player)
	player.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char, player)
	end)
	player.CharacterRemoving:Connect(function(char)
		self:OnCharacterRemoving(char, player)
	end)
end
function CameraModule:OnMouseLockToggled()
	if self.activeMouseLockController then
		local mouseLocked = self.activeMouseLockController:GetIsMouseLocked()
		local mouseLockOffset = self.activeMouseLockController:GetMouseLockOffset()
		if self.activeCameraController then
			self.activeCameraController:SetIsMouseLocked(mouseLocked)
			self.activeCameraController:SetMouseLockOffset(mouseLockOffset)
		end
	end
end
return CameraModule.new()
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX112"><Properties><string name="Name">Remote</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

client = nil
service = nil
cPcall = nil
Pcall = nil
Routine = nil
GetEnv = nil
origEnv = nil
logError = nil
return function()
	local _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay = _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay
	local script = script
	local service = service
	local client = client
	local Anti, Core, Functions, Process, Remote, UI, Variables
	local function Init()
		UI = client.UI
		Anti = client.Anti
		Core = client.Core
		Variables = client.Variables
		Functions = client.Functions
		Process = client.Process
		Remote = client.Remote
	end
	getfenv().client = nil
	getfenv().service = nil
	getfenv().script = nil
	client.Remote = {
		Init = Init,
		Returns = {},
		PendingReturns = {},
		EncodeCache = {},
		DecodeCache = {},
		Received = 0,
		Sent = 0,
		Returnables = {
			Test = function(args)
				return "HELLO FROM THE CLIENT SIDE :)! ", unpack(args)
			end,
			Ping = function(args)
				return Remote.Ping()
			end,
			ClientHooked = function(args)
				return Core.Special
			end,
			TaskManager = function(args)
				local action = args[1]
				if action == "GetTasks" then
					local tab = {}
					for i, v in next, service.GetTasks() do
						local new = {}
						new.Status = v.Status
						new.Name = v.Name
						new.Index = v.Index
						new.Created = v.Created
						new.CurrentTime = os.time()
						new.Function = tostring(v.Function)
						table.insert(tab, new)
					end
					return tab
				end
			end,
			LoadCode = function(args)
				local code = args[1]
				local func = Core.LoadCode(code, GetEnv())
				if func then
					return func()
				end
			end,
			Function = function(args)
				local func = client.Functions[args[1]]
				if func and type(func) == "function" then
					return func(unpack(args, 2))
				end
			end,
			Handler = function(args)
				local handler = client.Handlers[args[1]]
				if handler and type(handler) == "function" then
					return handler(unpack(args, 2))
				end
			end,
			UIKeepAlive = function(args)
				if Variables.UIKeepAlive then
					for ind, g in next, client.GUIs, nil do
						if g.KeepAlive then
							if g.Class == "ScreenGui" or g.Class == "GuiMain" then
								g.Object.Parent = service.PlayerGui
							elseif g.Class == "TextLabel" then
								g.Object.Parent = UI.GetHolder()
							end
							g.KeepAlive = false
						else
							g.KeepAlive = false
						end
					end
				end
				return "Done"
			end,
			UI = function(args)
				local guiName = args[1]
				local themeData = args[2]
				local guiData = args[3]
				return UI.Make(guiName, guiData, themeData)
			end,
			InstanceList = function(args)
				local objects = service.GetAdonisObjects()
				local temp = {}
				for i, v in next, objects, nil do
					table.insert(temp, {
						Text = v:GetFullName(),
						Desc = v.ClassName
					})
				end
				return temp
			end,
			ClientLog = function(args)
				local temp = {}
				local function toTab(str, desc, color)
					for i, v in next, service.ExtractLines(str) do
						table.insert(temp, {
							Text = v,
							Desc = desc .. v,
							Color = color
						})
					end
				end
				for i, v in next, service.LogService:GetLogHistory() do
					if v.messageType == Enum.MessageType.MessageOutput then
						toTab(v.message, "Output: ")
					elseif v.messageType == Enum.MessageType.MessageWarning then
						toTab(v.message, "Warning: ", Color3.new(1, 1, 0))
					elseif v.messageType == Enum.MessageType.MessageInfo then
						toTab(v.message, "Info: ", Color3.new(0, 0, 1))
					elseif v.messageType == Enum.MessageType.MessageError then
						toTab(v.message, "Error: ", Color3.new(1, 0, 0))
					end
				end
				return temp
			end
		},
		UnEncrypted = {
			LightingChange = function(prop, val)
				print(prop, "TICKLE ME!?")
				Variables.LightingChanged = true
				service.Lighting[prop] = val
				Anti.LastChanges.Lighting = prop
				wait(0.1)
				Variables.LightingChanged = false
				print("TICKLED :)", Variables.LightingChanged)
				if Anti.LastChanges.Lighting == prop then
					Anti.LastChanges.Lighting = nil
				end
			end
		},
		Commands = {
			GetReturn = function(args)
				local com = args[1]
				local key = args[2]
				local parms = {
					unpack(args, 3)
				}
				local retfunc = Remote.Returnables[com]
				local retable = retfunc and {
					pcall(retfunc, parms)
				} or {}
				if retable[1] ~= true then
					logError(retable[2])
					Remote.Send("GiveReturn", key, "__ADONIS_RETURN_ERROR", retable[2])
				else
					Remote.Send("GiveReturn", key, unpack(retable, 2))
				end
			end,
			GiveReturn = function(args)
				if Remote.PendingReturns[args[1]] then
					Remote.PendingReturns[args[1]] = nil
					service.Events[args[1]]:fire(unpack(args, 2))
				end
			end,
			SetVariables = function(args)
				local vars = args[1]
				for var, val in next, vars, nil do
					Variables[var] = val
				end
			end,
			Print = function(args)
				print(unpack(args))
			end,
			FireEvent = function(args)
				service.FireEvent(unpack(args))
			end,
			Test = function(args)
				print("OK WE GOT COMMUNICATION!  ORGL: " .. tostring(args[1]))
			end,
			TestError = function(args)
				error("THIS IS A TEST ERROR")
			end,
			TestEvent = function(args)
				Remote.PlayerEvent(args[1], unpack(args, 2))
			end,
			LoadCode = function(args)
				local code = args[1]
				local func = Core.LoadCode(code, GetEnv())
				if func then
					return func()
				end
			end,
			LaunchAnti = function(args)
				Anti.Launch(args[1], args[2])
			end,
			UI = function(args)
				local guiName = args[1]
				local themeData = args[2]
				local guiData = args[3]
				UI.Make(guiName, guiData, themeData)
			end,
			RemoveUI = function(args)
				UI.Remove(args[1], args[2])
			end,
			StartLoop = function(args)
				local name = args[1]
				local delay = args[2]
				local code = args[3]
				local func = Core.LoadCode(code, GetEnv())
				if name and delay and code and func then
					service.StartLoop(name, delay, func)
				end
			end,
			StopLoop = function(args)
				service.StopLoop(args[1])
			end,
			Function = function(args)
				local func = client.Functions[args[1]]
				if func and type(func) == "function" then
					Pcall(func, unpack(args, 2))
				end
			end,
			Handler = function(args)
				local handler = client.Handlers[args[1]]
				if handler and type(handler) == "function" then
					Pcall(handler, unpack(args, 2))
				end
			end
		},
		Fire = function(...)
			local RemoteEvent = Core.RemoteEvent
			if RemoteEvent and RemoteEvent.Object then
				Remote.Sent = Remote.Sent + 1
				RemoteEvent.Object:FireServer({
					Module = client.Module,
					Loader = client.Loader,
					Sent = Remote.Sent,
					Received = Remote.Received
				}, ...)
			end
		end,
		Send = function(com, ...)
			Core.LastUpdate = tick()
			Remote.Fire(Remote.Encrypt(com, Core.Key), ...)
		end,
		Get = function(com, ...)
			local returns
			local key = Functions:GetRandom()
			local event = service.Events[key]:Connect(function(...)
				returns = {
					...
				}
			end)
			Remote.PendingReturns[key] = true
			Remote.Send("GetReturn", com, key, ...)
			returns = returns or {
				event:Wait()
			}
			event:Disconnect()
			if returns then
				if returns[1] == "__ADONIS_RETURN_ERROR" then
					error(returns[2])
				else
					return unpack(returns)
				end
			else
				return nil
			end
		end,
		Ping = function()
			local t = tick()
			local ping = Remote.Get("Ping")
			if not ping then
				return false
			end
			local t2 = tick()
			local mult = 1000
			local ms = math.floor((t2 - t) * mult + 0.5) / mult * 100
			return ms
		end,
		PlayerEvent = function(event, ...)
			Remote.Send("PlayerEvent", event, ...)
		end,
		Encrypt = function(str, key, cache)
			local cache = cache or Remote.EncodeCache or {}
			if not key or not str then
				return str
			elseif cache[key] and cache[key][str] then
				return cache[key][str]
			else
				do
					local keyCache = cache[key] or {}
					local tobyte = string.byte
					local abs = math.abs
					local sub = string.sub
					local len = string.len
					local char = string.char
					local strBytes = {}
					local endStr = ""
					local function byte(str, pos)
						return tobyte(sub(str, pos, pos))
					end
					for i = 1, len(str) do
						if i % len(str) > 0 then
							if byte(str, i) + byte(key, i % len(key) + 1) > 255 then
								strBytes[i] = abs(byte(str, i) - byte(key, i % len(key) + 1))
							else
								strBytes[i] = abs(byte(key, i % len(key) + 1) + byte(str, i))
							end
						elseif byte(str, i) + byte(key, 1) > 255 then
							strBytes[i] = abs(byte(str, i) - byte(key, 1))
						else
							strBytes[i] = abs(byte(key, 1) + byte(str, i))
						end
					end
					for i = 1, #strBytes do
						endStr = endStr .. char(strBytes[i])
					end
					cache[key] = keyCache
					keyCache[str] = endStr
					return endStr
				end
			end
		end,
		Decrypt = function(str, key, cache)
			local cache = cache or Remote.DecodeCache or {}
			if not key or not str then
				return str
			elseif cache[key] and cache[key][str] then
				return cache[key][str]
			else
				do
					local keyCache = cache[key] or {}
					local tobyte = string.byte
					local abs = math.abs
					local sub = string.sub
					local len = string.len
					local char = string.char
					local strBytes = {}
					local endStr = ""
					local function byte(str, pos)
						return tobyte(sub(str, pos, pos))
					end
					for i = 1, len(str) do
						if i % len(str) > 0 then
							if byte(str, i) + byte(key, i % len(key) + 1) > 255 then
								strBytes[i] = abs(byte(str, i) - byte(key, i % len(key) + 1))
							else
								strBytes[i] = abs(byte(key, i % len(key) + 1) - byte(str, i))
							end
						elseif byte(str, i) + byte(key, 1) > 255 then
							strBytes[i] = abs(byte(str, i) - byte(key, 1))
						else
							strBytes[i] = abs(byte(key, 1) - byte(str, i))
						end
					end
					for i = 1, #strBytes do
						endStr = endStr .. char(strBytes[i])
					end
					cache[key] = keyCache
					keyCache[str] = endStr
					return endStr
				end
			end
		end
	}
end
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX117"><Properties><string name="Name">Core</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

client = nil
service = nil
cPcall = nil
Pcall = nil
Routine = nil
GetEnv = nil
origEnv = nil
logError = nil
return function()
	local _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay = _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay
	local script = script
	local service = service
	local client = client
	local Anti, Core, Functions, Process, Remote, UI, Variables
	local function Init()
		UI = client.UI
		Anti = client.Anti
		Core = client.Core
		Variables = client.Variables
		Functions = client.Functions
		Process = client.Process
		Remote = client.Remote
	end
	getfenv().client = nil
	getfenv().service = nil
	getfenv().script = nil
	client.Core = {
		Init = Init,
		Name = script.Name,
		Special = script.Name,
		MakeGui = client.UI.Make,
		GetGui = client.UI.Get,
		RemoveGui = client.UI.Remove,
		ScriptCache = {},
		GetEvent = function()
			if Core.RemoteEvent then
				Core.RemoteEvent.Event:Disconnect()
				Core.RemoteEvent.Security:Disconnect()
				Core.RemoteEvent = nil
			end
			Core.RemoteEvent = {}
			local rindex = 0
			local firstSearch
			local timer = 1
			local prevTime = 0
			local start = os.time()
			local events = {}
			local found
			local function finishEvent(event)
				if event then
					Core.RemoteEvent.Object = event
					Core.RemoteEvent.FireServer = event.FireServer
					Core.RemoteEvent.Event = event.OnClientEvent:Connect(Process.Remote)
					Core.RemoteEvent.Security = event.Changed:Connect(function(p)
						if p == "RobloxLocked" and Anti.RLocked(event) then
							client.Kill("RemoteEvent Locked")
						elseif not event or not event.Parent then
							Core.GetEvent()
						end
					end)
					if not Core.Key then
						Remote.Fire(client.DepsName .. "GET_KEY")
					end
				else
					client.Kill("RemoteEvent not found")
				end
			end
			local function search()
				local children = {}
				for i, child in next, service.JointsService:GetChildren() do
					if string.sub(child.Name, 1, #client.RemoteName) == client.RemoteName then
						table.insert(children, child)
					end
				end
				for ind, e in next, events, nil do
					e.Event:Disconnect()
					events[ind] = nil
				end
				for i, child in next, children, nil do
					if not Anti.ObjRLocked(child) and child:IsA("RemoteEvent") then
						local index = rindex + 1
						rindex = index
						if not events[child] then
							do
								local eventTab
								eventTab = {
									Event = child.OnClientEvent:Connect(function(com, ...)
										if com == "TrustCheck" and select(1, ...) == Core.Special and not found then
											found = child
											Core.RemoteEvent.Event = eventTab.Event
											finishEvent(child)
											for ind, e in next, events, nil do
												if ind ~= child then
													e.Event:Disconnect()
													events[ind] = nil
												end
											end
										elseif not found or found == child then
										end
									end),
									Object = child
								}
								events[child] = eventTab
							end
						end
						child:FireServer(client.Module, "TrustCheck")
					end
				end
			end
			repeat
				if prevTime < os.time() then
					prevTime = os.time()
					timer = timer + 1
					if timer % 10 == 0 or not firstSearch then
						firstSearch = true
						local event = service.JointsService:FindFirstChild(client.RemoteName)
						if event then
							found = event
							finishEvent(event)
						end
					end
				end
			until found or not wait(0.01)
		end,
		LoadPlugin = function(plugin)
			local plug = require(plugin)
			local func = setfenv(plug, GetEnv(getfenv(plug)))
			cPcall(func)
		end,
		LoadBytecode = function(str, env)
			return require(client.Deps.Rerubi)(str, env)
		end,
		LoadCode = function(str, env)
			return Core.LoadBytecode(str, env)
		end,
		CheckClient = function()
			if tick() - Core.LastUpdate >= 55 then
				wait(math.random())
				local returner = math.random()
				local ret = Remote.Send("ClientCheck", {
					Sent = 0,
					Received = Remote.Received
				}, client.DepsName, returner)
			end
		end,
		StartAPI = function()
			local ScriptCache = Core.ScriptCache
			local Rerubi = client.Deps.Rerubi
			local Get = Remote.Get
			local G_API = client.G_API
			local Allowed_API_Calls = client.Allowed_API_Calls
			local NewProxy = service.NewProxy
			local MetaFunc = service.MetaFunc
			local ReadOnly = service.ReadOnly
			local StartLoop = service.StartLoop
			local ReadOnly = service.ReadOnly
			local UnWrap = service.UnWrap
			local service, client
			local _G = _G
			local setmetatable = setmetatable
			local type = type
			local print = print
			local error = error
			local pairs = pairs
			local warn = warn
			local next = next
			local table = table
			local rawset = rawset
			local rawget = rawget
			local getfenv = getfenv
			local setfenv = setfenv
			local require = require
			local tostring = tostring
			local client = client
			local Routine = Routine
			local cPcall = cPcall
			local API_Special = {}
			setfenv(1, setmetatable({}, {
				__metatable = getmetatable(getfenv())
			}))
			local API_Specific = {
				API_Specific = {
					Test = function()
						print("We ran the api specific stuff")
					end
				},
				Service = service
			}
			local API = {
				Access = ReadOnly({}, nil, nil, true),
				Scripts = ReadOnly({
					ExecutePermission = MetaFunc(function(code)
						local exists
						for i, v in next, ScriptCache, nil do
							if UnWrap(v.Script) == getfenv(2).script then
								exists = v
							end
						end
						if exists and exists.noCache ~= true and (not exists.runLimit or exists.runLimit and exists.Executions <= exists.runLimit) then
							exists.Executions = exists.Executions + 1
							return exists.Source, exists.Loadstring
						end
						local data = Get("ExecutePermission", UnWrap(getfenv(3).script), code, true)
						if data and data.Source then
							local module
							if not exists then
								module = require(Rerubi:Clone())
								table.insert(ScriptCache, {
									Script = getfenv(2).script,
									Source = data.Source,
									Loadstring = module,
									noCache = data.noCache,
									runLimit = data.runLimit,
									Executions = data.Executions
								})
							else
								module = exists.Loadstring
								exists.Source = data.Source
							end
							return data.Source, module
						end
					end),
					ReportLBI = MetaFunc(function(scr, origin)
						if origin == "Local" then
							return true
						end
					end)
				}, nil, nil, true)
			}
			AdonisGTable = NewProxy({
				__index = function(tab, ind)
					if ind == "Scripts" then
						return API.Scripts
					elseif G_API and Allowed_API_Calls.Client == true then
						if type(API[ind]) == "function" then
							return MetaFunc(API[ind])
						else
							return API[ind]
						end
					else
						error("_G API is disabled")
					end
				end,
				__newindex = function(tabl, ind, new)
					error("Read-only")
				end,
				__metatable = "API"
			})
			if not _G.Adonis then
				rawset(_G, "Adonis", AdonisGTable)
				StartLoop("APICheck", 1, function()
					rawset(_G, "Adonis", AdonisGTable)
				end, true)
			end
		end
	}
end
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX122"><Properties><string name="Name">Anti</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

client = nil
service = nil
cPcall = nil
Pcall = nil
Routine = nil
GetEnv = nil
origEnv = nil
logError = nil
return function()
	local _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay = _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay
	local Anti, Process, UI, Variables
	local function Init()
		UI = client.UI
		Anti = client.Anti
		Variables = client.Variables
		Process = client.Process
	end
	local script = script
	local service = service
	local client = client
	local Core = client.Core
	local Remote = client.Remote
	local Functions = client.Functions
	local Disconnect = client.Disconnect
	local Send = client.Remote.Send
	local Get = client.Remote.Get
	local NetworkClient = service.NetworkClient
	local Kill = client.Kill
	local Player = service.Players.LocalPlayer
	local Kick = Player.Kick
	local toget = tostring(getfenv)
	getfenv().client = nil
	getfenv().service = nil
	getfenv().script = nil
	local function Detected(action, info)
		if NetworkClient then
			pcall(Send, "Detected", action, info)
			wait(1)
			if action == "kick" then
				Disconnect(info)
			elseif action == "crash" then
				Kill(info)
			end
		end
	end
	local function CheckEnv()
		if tostring(getfenv) ~= toget or type(getfenv) ~= "function" then
		end
	end
	local Detectors = service.ReadOnly({
		Speed = function(data)
			service.StartLoop("AntiSpeed", 1, function()
				if workspace:GetRealPhysicsFPS() > tonumber(data.Speed) then
					Detected("kill", "Speed exploiting")
				end
			end)
		end,
		LockLighting = function(data)
			local settings = {
				Ambient = service.Lighting.Ambient,
				Brightness = service.Lighting.Brightness,
				ColorShift_Bottom = service.Lighting.ColorShift_Bottom,
				ColorShift_Top = service.Lighting.ColorShift_Top,
				GlobalShadows = service.Lighting.GlobalShadows,
				OutdoorAmbient = service.Lighting.OutdoorAmbient,
				Outlines = service.Lighting.Outlines,
				ShadowColor = service.Lighting.ShadowColor,
				GeographicLatitude = service.Lighting.GeographicLatitude,
				Name = service.Lighting.Name,
				TimeOfDay = service.Lighting.TimeOfDay,
				FogColor = service.Lighting.FogColor,
				FogEnd = service.Lighting.FogEnd,
				FogStart = service.Lighting.FogStart
			}
			local checking = false
			Routine(function()
				while true do
					if not checking then
						for i, v in pairs(settings) do
							if service.Lighting[i] ~= nil then
								settings[i] = service.Lighting[i]
							end
						end
					end
					wait(1)
				end
			end)
			Variables.LightingChanged = false
			local tempIgnore = false
			local function check(c)
				if Variables.LightingChanged then
					return true
				end
				local temp = service.Lighting[c]
				if service.Lighting[c] ~= nil and settings[c] ~= nil then
					tempIgnore = true
					service.Lighting[c] = settings[c]
					tempIgnore = false
					wait(0.01)
					if c == Anti.LastChanges.Lighting then
						tempIgnore = true
						service.Lighting[c] = temp
						tempIgnore = false
						return true
					else
						return false
					end
				end
			end
			service.Lighting.Changed:connect(function(c)
				checking = true
				if not tempIgnore then
					if check(c) then
						print("SERVER CHANGED IT")
					else
						print("CLIENT CHANGED IT")
					end
				end
				checking = false
			end)
		end,
		ReplicationLogs = function()
			local filtering = workspace.FilteringEnabled
			local function checkParent(obj, class)
				local tester
				pcall(function()
					tester = obj:GetFullName()
				end)
				if tester then
					local full = obj:GetFullName()
					local prev = game
					local blackParents = {
						service.InsertService,
						service.TweenService,
						service.GamepadService,
						service.Workspace.CurrentCamera,
						service.LocalContainer(),
						service.Player,
						service.Player.Character
					}
					local blackClasses = {
						"TouchTransmitter"
					}
					local players = service.Players:GetPlayers()
					for ind, b in pairs(blackParents) do
						if b and (rawequal(obj, b) or obj:IsDescendantOf(b)) then
							return true
						end
					end
					for ind, b in pairs(blackClasses) do
						if obj:IsA(b) then
							return true
						end
					end
					for ind, p in pairs(players) do
						if p and (obj:IsDescendantOf(p) or p.Character and obj:IsDescendantOf(p.Character)) then
							return true
						end
					end
					local new = obj
					for i = 1, 50 do
						if new then
							if class and new:IsA(class) and (not string.find(new.Name, "ADONIS") or not new:IsA("LocalScript")) then
								return true
							else
								prev = new
							end
						else
							return false
						end
						new = obj.Parent
					end
					return false
				else
					return true
				end
			end
			game.DescendantAdded:Connect(function(c)
				if not filtering and not checkParent(c) then
					local data = {}
					data.obj = c
					data.name = c.Name
					data.class = c.ClassName
					data.parent = c.Parent
					data.path = c:GetFullName()
					Remote.Fire("AddReplication", "Created", c, data)
				end
			end)
			game.DescendantRemoving:Connect(function(c)
				if not filtering and not checkParent(c) then
					do
						local data = {}
						data.obj = c
						data.name = c.Name
						data.class = c.ClassName
						data.parent = c.Parent
						data.path = c:GetFullName()
						if c and c.Parent then
							do
								local event
								event = c.Parent.ChildRemoved:connect(function(n)
									if rawequal(c, n) then
										Remote.Fire("AddReplication", "Destroyed", c, data)
										event:disconnect()
									end
								end)
								wait(5)
								if event then
									event:disconnect()
								end
							end
						else
							Remote.Fire("AddReplication", "Destroyed", c, data)
						end
					end
				end
			end)
		end,
		NameId = function(data)
			local realId = data.RealID
			local realName = data.RealName
			service.StartLoop("NameIDCheck", 10, function()
				if service.Player.Name ~= realName then
					Detected("log", "Local username does not match server username")
				end
				if service.Player.userId ~= realId then
					Detected("log", "Local userID does not match server userID")
				end
			end)
		end,
		AntiGui = function(data)
			service.Player.DescendantAdded:connect(function(c)
				if c:IsA("GuiMain") or c:IsA("PlayerGui") and rawequal(c.Parent, service.PlayerGui) and not UI.Get(c) then
					c:Destroy()
					Detected("log", "Unknown GUI detected and destroyed")
				end
			end)
		end,
		AntiTools = function(data)
			service.Player:WaitForChild("Backpack")
			local btools = data.BTools
			local tools = data.AntiTools
			local allowed = data.AllowedList
			local function check(t)
				if (t:IsA("Tool") or t:IsA("HopperBin")) and not t:FindFirstChild(Variables.CodeName) then
					if client.AntiBuildingTools and t:IsA("HopperBin") and (rawequal(t.BinType, Enum.BinType.Grab) or rawequal(t.BinType, Enum.BinType.Clone) or rawequal(t.BinType, Enum.BinType.Hammer) or rawequal(t.BinType, Enum.BinType.GameTool)) then
						t.Active = false
						t:Destroy()
						Detected("log", "Building tools detected")
					end
					if tools then
						local good = false
						for i, v in pairs(client.AllowedToolsList) do
							if t.Name == v then
								good = true
							end
						end
						if not good then
							t:Destroy()
							Detected("log", "Tool detected")
						end
					end
				end
			end
			for i, t in pairs(service.Player.Backpack:children()) do
				check(t)
			end
			service.Player.Backpack.ChildAdded:connect(check)
		end,
		HumanoidState = function(data)
			wait(1)
			local humanoid = service.Player.Character:WaitForChild("Humanoid")
			local event
			local doing = true
			event = humanoid.StateChanged:connect(function(old, new)
				if not doing then
					event:disconnect()
				end
				if rawequal(new, Enum.HumanoidStateType.StrafingNoPhysics) and doing then
					doing = false
					Detected("kill", "Noclipping")
					event:disconnect()
				end
			end)
			while humanoid and humanoid.Parent and humanoid.Parent.Parent and doing and wait(0.1) do
				if rawequal(humanoid:GetState(), Enum.HumanoidStateType.StrafingNoPhysics) and doing then
					doing = false
					Detected("kill", "Noclipping")
				end
			end
		end,
		Paranoid = function(data)
			wait(1)
			local char = service.Player.Character
			local torso = char:WaitForChild("Head")
			local humPart = char:WaitForChild("HumanoidRootPart")
			local hum = char:WaitForChild("Humanoid")
			while torso and humPart and rawequal(torso.Parent, char) and rawequal(humPart.Parent, char) and char.Parent ~= nil and hum.Health > 0 and hum and hum.Parent and wait(1) do
				if (humPart.Position - torso.Position).magnitude > 10 and hum and hum.Health > 0 then
					Detected("kill", "HumanoidRootPart too far from Torso (Paranoid?)")
				end
			end
		end,
		MainDetection = function(data)
			local game = service.DataModel
			local isStudio = select(2, pcall(service.RunService.IsStudio, service.RunService))
			local findService = service.DataModel.FindService
			local lastUpdate = tick()
			local doingCrash = false
			local goodCores = {}
			local gettingGood = false
			local gettingMenu = false
			local menuOpened = false
			local gotGoodTime = tick()
			local coreNums = {}
			local coreClears = {
				FriendStatus = true,
				ImageButton = false,
				ButtonHoverText = true,
				HoverMid = true,
				HoverLeft = true,
				HoverRight = true,
				ButtonHoverTextLabel = true,
				Icon = true,
				ImageLabel = true,
				NameLabel = true,
				Players = true,
				ColumnValue = true,
				ColumnName = true,
				Frame = false,
				StatText = false
			}
			local lookFor = {
				"current identity is 0",
				"gui made by kujo",
				"tetanus reloaded hooked"
			}
			local files = {
				["C:RC7\rc7.dat"] = true
			}
			local function check(Message)
				for i, v in pairs(lookFor) do
					if string.find(string.lower(Message), string.lower(v)) and not string.find(string.lower(Message), "failed to load") then
						return true
					end
				end
			end
			local function findLog(msg)
				for i, v in pairs(service.LogService:GetLogHistory()) do
					if string.find(string.lower(v.message), string.lower(msg)) then
						return true
					end
				end
			end
			local function findFiles()
				local image = service.New("Decal", service.Workspace)
				for i, v in next, files, nil do
					image.Texture = i
					wait(0.5)
					if findLog(i) then
					else
						warn("RC7 DETECTION WORKED?")
					end
				end
			end
			local function isGood(item)
				for i, v in next, goodCores, nil do
					if rawequal(item, v) then
						return true
					end
				end
			end
			local function checkServ(c)
				if not pcall(function()
					if not isStudio and (findService("ServerStorage", game) or findService("ServerScriptService", game)) then
						Detected("crash", "Disallowed Services Detected")
					end
				end) then
					Detected("kick", "Finding Error")
				end
			end
			local function chkObj(item)
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX127"><Properties><string name="Name">Process</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

client = nil
service = nil
cPcall = nil
Pcall = nil
Routine = nil
GetEnv = nil
origEnv = nil
logError = nil
return function()
	local _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay = _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay
	local script = script
	local service = service
	local client = client
	local Anti, Core, Functions, Process, Remote, UI, Variables
	local function Init()
		UI = client.UI
		Anti = client.Anti
		Core = client.Core
		Variables = client.Variables
		Functions = client.Functions
		Process = client.Process
		Remote = client.Remote
	end
	getfenv().client = nil
	getfenv().service = nil
	getfenv().script = nil
	client.Process = {
		Init = Init,
		Remote = function(data, com, ...)
			local args = {
				...
			}
			Remote.Received = Remote.Received + 1
			if type(com) == "string" then
				if com == client.DepsName .. "GIVE_KEY" then
					if not Core.Key then
						Core.Key = args[1]
						client.Finish_Loading()
					end
				elseif Remote.UnEncrypted[com] then
					Remote.UnEncrypted[com](...)
				elseif Core.Key then
					local comString = Remote.Decrypt(com, Core.Key)
					local command = Remote.Commands[comString]
					if command then
						local ran, err = service.TrackTask("Remote: " .. comString, command, args)
						if not ran and err then
							logError(err)
						end
					end
				end
			end
		end,
		LogService = function(Message, Type)
		end,
		ErrorMessage = function(Message, Trace, Script)
			if Message and Message ~= "nil" and Message ~= "" and (string.find(Message, "::Adonis::") or string.find(Message, script.Name) or Script == script) then
				logError(tostring(Message) .. " - " .. tostring(Trace))
			end
			if not ((not (Script ~= nil and Trace) or Trace == "") and Trace) or not string.find(Trace, "CoreGui.RobloxGui") then
			end
		end,
		Chat = function(msg)
			if not service.Player or service.Player.Parent ~= service.Players then
				Remote.Fire("ProcessChat", msg)
			end
		end,
		CharacterAdded = function()
			UI.GetHolder()
			service.Events.CharacterAdded:fire()
		end,
		CharacterRemoving = function()
			if Variables.UIKeepAlive then
				for ind, g in next, client.GUIs, nil do
					if g.Class == "ScreenGui" or g.Class == "GuiMain" or g.Class == "TextLabel" then
						if g.CanKeepAlive then
							g.KeepAlive = true
							g.KeepParent = g.Object.Parent
							g.Object.Parent = nil
						elseif service.StarterGui.ResetPlayerGuiOnSpawn then
							pcall(g.Destroy, g)
						end
					end
				end
			end
			if Variables.GuiViewFolder then
				Variables.GuiViewFolder:Destroy()
				Variables.GuiViewFolder = nil
			end
			if Variables.ChatEnabled then
				service.StarterGui:SetCoreGuiEnabled("Chat", true)
			end
			if Variables.PlayerListEnabled then
				service.StarterGui:SetCoreGuiEnabled("PlayerList", true)
			end
			local textbox = service.UserInputService:GetFocusedTextBox()
			if textbox then
				textbox:ReleaseFocus()
			end
			service.Events.CharacterRemoving:fire()
		end
	}
end
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX132"><Properties><string name="Name">UI</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

client = nil
service = nil
cPcall = nil
Pcall = nil
Routine = nil
GetEnv = nil
origEnv = nil
logError = nil
return function()
	local _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay = _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay
	local script = script
	local service = service
	local client = client
	local Anti, Core, Functions, Process, Remote, UI, Variables, Deps
	local function Init()
		UI = client.UI
		Anti = client.Anti
		Core = client.Core
		Variables = client.Variables
		Functions = client.Functions
		Process = client.Process
		Remote = client.Remote
		Deps = client.Deps
	end
	getfenv().client = nil
	getfenv().service = nil
	getfenv().script = nil
	client.UI = {
		Init = Init,
		GetHolder = function()
			if UI.Holder and UI.Holder.Parent == service.PlayerGui then
				return UI.Holder
			else
				pcall(function()
					if UI.Holder then
						UI.Holder:Destroy()
					end
				end)
				local new = Instance.new("ScreenGui")
				new.Name = Functions.GetRandom()
				new.Parent = service.PlayerGui
				UI.Holder = new
				return UI.Holder
			end
		end,
		Prepare = function(gui)
			do return gui end
			local gTable = UI.Get(gui, false, true)
			if gui:IsA("ScreenGui") or gui:IsA("GuiMain") then
				local new = Instance.new("TextLabel")
				new.BackgroundTransparency = 1
				new.Size = UDim2.new(1, 0, 1, 0)
				new.Name = gui.Name
				new.Active = true
				new.Text = ""
				for ind, child in next, gui:GetChildren() do
					child.Parent = new
				end
				if gTable then
					gTable:Register(new)
				end
				gui:Destroy()
				return new
			else
				return gui
			end
		end,
		LoadModule = function(module, data, env)
			local ran, func = pcall(require, module)
			local newEnv = GetEnv(env)
			local data = data or {}
			newEnv.script = module
			newEnv.client = service.CloneTable(client)
			newEnv.service = service.CloneTable(service)
			newEnv.service.Threads = service.CloneTable(service.Threads)
			for i, v in next, newEnv.client, nil do
				if type(v) == "table" and i ~= "Variables" and i ~= "Handlers" then
					newEnv.client[i] = service.CloneTable(v)
				end
			end
			if ran then
				local rets = {
					service.TrackTask("UI: " .. module:GetFullName(), setfenv(func, newEnv), data)
				}
				local ran = rets[1]
				if ran then
					return unpack(rets, 2)
				else
					warn("Error while running module " .. module.Name, tostring(rets[2]))
					client.LogError("Error loading " .. tostring(module) .. " - " .. tostring(rets[2]))
				end
			else
				warn("Error while loading module " .. module.Name, tostring(func))
			end
		end,
		GetNew = function(theme, name)
			local found = {}
			local endConfig = {}
			local endConfValues = {}
			local confFolder = Instance.new("Folder")
			local func
			function func(theme, name, depth)
				local depth = (depth or 11) - 1
				local folder = Deps.UI:FindFirstChild(theme) or Deps.UI.Default
				if folder then
					local baseValue = folder:FindFirstChild("Base_Theme")
					local baseTheme = baseValue and baseValue.Value
					local foundGUI = baseValue and folder:FindFirstChild(name) or Deps.UI.Default:FindFirstChild(name)
					if foundGUI then
						local config = foundGUI:FindFirstChild("Config")
						table.insert(found, {
							Theme = theme,
							Folder = folder,
							Name = name,
							Found = foundGUI,
							Config = config,
							isModule = foundGUI:IsA("ModuleScript")
						})
						if config then
							baseValue = config:FindFirstChild("BaseTheme") or baseValue
							baseTheme = baseValue and baseValue.Value
						end
					end
					if baseTheme and depth > 0 then
						func(baseTheme, name, depth)
					end
				end
			end
			func(theme, name)
			confFolder.Name = "Config"
			if #found > 0 then
				for i, v in next, found, nil do
					if v.Config then
						for k, m in next, v.Config:GetChildren() do
							if not endConfig[m.Name] then
								endConfig[m.Name] = m
							end
						end
					end
				end
				for i, v in next, endConfig, nil do
					v:Clone().Parent = confFolder
				end
				if found[1].isModule then
					return found[1].Found, found[1].Folder, confFolder
				elseif not endConfig.Code then
					for i, v in next, found, nil do
						if v.isModule then
							return v.Found, v.Folder, confFolder
						end
					end
				end
				local new = found[1].Found:Clone()
				local oldFolder = new:FindFirstChild("Config")
				if oldFolder then
					oldFolder:Destroy()
				end
				confFolder.Parent = new
				return new, found[1].Folder, confFolder
			end
		end,
		Make = function(name, data, themeData)
			local data = data or {}
			local defaults = {Desktop = "Default", Mobile = "Mobilius"}
			local themeData = themeData or Core.Theme or defaults
			local theme = Variables.CustomTheme or service.IsMobile() and themeData.Mobile or themeData.Desktop
			local folder = Deps.UI:FindFirstChild(theme) or Deps.UI.Default
			local newGui, folder2, foundConf = UI.GetNew(theme, name)
			if newGui then
				local isModule = newGui:IsA("ModuleScript")
				local conf = newGui:FindFirstChild("Config")
				if isModule then
					return UI.LoadModule(newGui, data, {script = newGui})
				elseif conf and foundConf and foundConf ~= true then
					local code = foundConf.Code
					local mult = foundConf.AllowMultiple
					local keep = foundConf.CanKeepAlive
					local allowMult = mult and mult.Value or true
					local found, num = UI.Get(name)
					if not found or num and num > 0 and allowMult then
						local gTable, gIndex = UI.Register(newGui)
						local newEnv = {}
						if folder:IsA("ModuleScript") then
							newEnv.script = folder
							newEnv.gTable = gTable
							local ran, func = pcall(require, folder)
							local newEnv = GetEnv(newEnv)
							local rets = {
								pcall(setfenv(func, newEnv), newGui, gTable, data)
							}
							local ran = rets[1]
							local ret = rets[2]
							if ret ~= nil then
								if type(ret) == "userdata" and Anti.GetClassName(ret) == "ScreenGui" then
									if ret:FindFirstChild("Config") then
										code = ret.Config:FindFirstChild("Code") or code
									end
								else
									return ret
								end
							end
						end
						newGui.Parent = Variables.GUIHolder
						newGui.Name = Functions.GetRandom()
						data.gIndex = gIndex
						data.gTable = gTable
						code.Parent = conf
						code.Name = name
						return UI.LoadModule(code, data, {
							script = code,
							gTable = gTable,
							Data = data,
							GUI = newGui
						})
					end
				end
			else
				print("GUI " .. tostring(name) .. " not found")
			end
		end,
		Get = function(obj, ignore, returnOne)
			local found = {}
			local num = 0
			if obj then
				for ind, g in next, client.GUIs, nil do
					if g.Name ~= ignore and g.Object ~= ignore and g ~= ignore then
						if type(obj) == "string" then
							if g.Name == obj then
								found[ind] = g
								num = num + 1
								if returnOne then
									return g
								end
							end
						elseif type(obj) == "userdata" then
							if service.RawEqual(g.Object, obj) then
								found[ind] = g
								num = num + 1
								if returnOne then
									return g
								end
							end
						elseif type(obj) == "boolean" and obj == true then
							found[ind] = g
							num = num + 1
							if returnOne then
								return g
							end
						end
					end
				end
			end
			if num < 1 then
				return false
			else
				return found, num
			end
		end,
		Remove = function(name, ignore)
			local gui = UI.Get(name, ignore)
			if gui then
				for i, v in next, gui, nil do
					v.Destroy()
				end
			end
		end,
		Register = function(gui, data)
			local gIndex = Functions.GetRandom()
			local gTable
			gTable = {
				Object = gui,
				Config = gui:FindFirstChild("Config"),
				Name = gui.Name,
				Events = {},
				Class = gui.ClassName,
				Index = gIndex,
				Active = true,
				Ready = function()
					if gTable.Config then
						gTable.Config.Parent = nil
					end
					if pcall(function()
						if gTable.Class == "ScreenGui" or gTable.Class == "GuiMain" then
							gTable.Object.Parent = service.PlayerGui
						else
							gTable.Object.Parent = UI.GetHolder()
						end
					end) then
						gTable.Active = true
					else
						warn("Something happened while trying to set the parent of " .. tostring(gTable.Name))
						warn("Maybe it was locked (Destroyed)?")
						gTable:Destroy()
					end
				end,
				BindEvent = function(event, func)
					local signal = event:connect(func)
					local origDisc = signal.Disconnect
					local Events = gTable.Events
					local function disc()
						origDisc(signal)
						for i, v in next, Events, nil do
							if v.Signal == signal then
								table.remove(Events, i)
							end
						end
					end
					table.insert(Events, {Signal = signal, Remove = disc})
					return {
						Disconnect = disc,
						disconnect = disc,
						wait = service.CheckProperty(signal, "wait") and signal.wait
					}, signal
				end,
				ClearEvents = function()
					for i, v in next, gTable.Events, nil do
						v:Remove()
					end
				end,
				Destroy = function()
					pcall(function()
						if gTable.CustomDestroy then
							gTable.CustomDestroy()
						else
							service.UnWrap(gTable.Object):Destroy()
						end
					end)
					gTable.Destroyed = true
					gTable.Active = false
					client.GUIs[gIndex] = nil
					gTable.ClearEvents()
				end,
				UnRegister = function()
					client.GUIs[gIndex] = nil
					if gTable.AncestryEvent then
						gTable.AncestryEvent:Disconnect()
					end
				end,
				Register = function(tab, new)
					new = new or tab
					new:SetSpecial("Destroy", gTable.Destroy)
					gTable.Object = service.Wrap(new)
					gTable.Class = new.ClassName
					if gTable.AncestryEvent then
						gTable.AncestryEvent:Disconnect()
					end
					gTable.AncestryEvent = new.AncestryChanged:Connect(function(c, parent)
						if client.GUIs[gIndex] then
							if rawequal(c, gTable.Object) and gTable.Class == "TextLabel" and parent == service.PlayerGui then
								wait()
								gTable.Object.Parent = UI.GetHolder()
							elseif rawequal(c, gTable.Object) and parent == nil and not gTable.KeepAlive then
								gTable:Destroy()
							elseif rawequal(c, gTable.Object) and parent ~= nil then
								gTable.Active = true
								client.GUIs[gIndex] = gTable
							end
						end
					end)
					client.GUIs[gIndex] = gTable
				end
			}
			if data then
				for i, v in next, data, nil do
					gTable[i] = v
				end
			end
			gui.Name = Functions.GetRandom()
			gTable:Register(gui)
			return gTable, gIndex
		end
	}
	client.UI.RegisterGui = client.UI.Register
	client.UI.GetGui = client.UI.Get
	client.UI.PrepareGui = client.UI.Prepare
	client.UI.MakeGui = client.UI.Make
end
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX137"><Properties><string name="Name">Variables</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

client = nil
service = nil
cPcall = nil
Pcall = nil
Routine = nil
GetEnv = nil
origEnv = nil
logError = nil
return function()
	local _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay = _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay
	local script = script
	local service = service
	local client = client
	local Anti, Core, Functions, Process, Remote, UI, Variables
	local function Init()
		UI = client.UI
		Anti = client.Anti
		Core = client.Core
		Variables = client.Variables
		Functions = client.Functions
		Process = client.Process
		Remote = client.Remote
	end
	getfenv().client = nil
	getfenv().service = nil
	getfenv().script = nil
	client.GUIs = {}
	client.GUIHolder = service.New("Folder")
	client.Variables = {
		Init = Init,
		CodeName = "",
		UIKeepAlive = true,
		KeybindsEnabled = true,
		ParticlesEnabled = true,
		CapesEnabled = true,
		Particles = {},
		KeyBinds = {},
		Capes = {},
		savedUI = {},
		localSounds = {},
		LightingSettings = {
			Ambient = service.Lighting.Ambient,
			Brightness = service.Lighting.Brightness,
			ColorShift_Bottom = service.Lighting.ColorShift_Bottom,
			ColorShift_Top = service.Lighting.ColorShift_Top,
			GlobalShadows = service.Lighting.GlobalShadows,
			OutdoorAmbient = service.Lighting.OutdoorAmbient,
			Outlines = service.Lighting.Outlines,
			ShadowColor = service.Lighting.ShadowColor,
			GeographicLatitude = service.Lighting.GeographicLatitude,
			Name = service.Lighting.Name,
			TimeOfDay = service.Lighting.TimeOfDay,
			FogColor = service.Lighting.FogColor,
			FogEnd = service.Lighting.FogEnd,
			FogStart = service.Lighting.FogStart
		}
	}
end
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX142"><Properties><string name="Name">Functions</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

client = nil
service = nil
cPcall = nil
Pcall = nil
Routine = nil
GetEnv = nil
origEnv = nil
logError = nil
return function()
	local _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay = _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay
	local script = script
	local service = service
	local client = client
	local Anti, Core, Functions, Process, Remote, UI, Variables
	local function Init()
		UI = client.UI
		Anti = client.Anti
		Core = client.Core
		Variables = client.Variables
		Functions = client.Functions
		Process = client.Process
		Remote = client.Remote
	end
	getfenv().client = nil
	getfenv().service = nil
	getfenv().script = nil
	client.Functions = {
		Init = Init,
		Kill = client.Kill,
		GetRandom = function(pLen)
			local Len = type(pLen) == "number" and pLen or math.random(10, 15)
			local Res = {}
			for Idx = 1, Len do
				Res[Idx] = string.format("%02x", math.random(255))
			end
			return table.concat(Res)
		end,
		Round = function(num)
			return math.floor(num + 0.5)
		end,
		SetView = function(ob)
			if ob == "reset" then
				workspace.CurrentCamera.CameraType = "Custom"
				workspace.CurrentCamera.CameraSubject = service.Player.Character.Humanoid
				workspace.CurrentCamera.FieldOfView = 70
			else
				workspace.CurrentCamera.CameraSubject = ob
			end
		end,
		Dizzy = function(speed)
			service.StopLoop("DizzyLoop")
			print("dizzy")
			if speed then
				print("start")
				do
					local cam = workspace.CurrentCamera
					local last = tick()
					local rot = 0
					local flip = false
					service.StartLoop("DizzyLoop", "RenderStepped", function()
						print("in loop")
						local dt = tick() - last
						if flip then
							rot = rot + math.rad(speed * dt)
						else
							rot = rot - math.rad(speed * dt)
						end
						if rot >= 2.5 or rot <= -2.5 then
						end
						cam.CoordinateFrame = cam.CoordinateFrame * CFrame.Angles(0, 0, rot)
						last = tick()
					end)
				end
			end
		end,
		Base64Encode = function(data)
			local b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
			return (data:gsub(".", function(x)
				local r, b = "", string.byte(x)
				for i = 8, 1, -1 do
					r = r .. (b % 2 ^ i - b % 2 ^ (i - 1) > 0 and "1" or "0")
				end
				return r
			end) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
				if #x < 6 then
					return ""
				end
				local c = 0
				for i = 1, 6 do
					c = c + (string.sub(x, i, i) == "1" and 2 ^ (6 - i) or 0)
				end
				return string.sub(b, c + 1, c + 1)
			end) .. ({
				"",
				"==",
				"="
			})[#data % 3 + 1]
		end,
		Base64Decode = function(data)
			local b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
			data = string.gsub(data, "[^" .. b .. "=]", "")
			return (data:gsub(".", function(x)
				if x == "=" then
					return ""
				end
				local r, f = "", string.find(b, x) - 1
				for i = 6, 1, -1 do
					r = r .. (f % 2 ^ i - f % 2 ^ (i - 1) > 0 and "1" or "0")
				end
				return r
			end):gsub("%d%d%d?%d?%d?%d?%d?%d?", function(x)
				if #x ~= 8 then
					return ""
				end
				local c = 0
				for i = 1, 8 do
					c = c + (string.sub(x, i, i) == "1" and 2 ^ (7 - i) or 0)
				end
				return string.char(c)
			end))
		end,
		GetGuiData = function(args)
			local props = {
				"AbsolutePosition",
				"AbsoluteSize",
				"ClassName",
				"Name",
				"Parent",
				"Archivable",
				"SelectionImageObject",
				"Active",
				"BackgroundColor3",
				"BackgroundTransparency",
				"BorderColor3",
				"BorderSizePixel",
				"Position",
				"Rotation",
				"Selectable",
				"Size",
				"SizeConstraint",
				"Style",
				"Visible",
				"ZIndex",
				"ClipsDescendants",
				"Draggable",
				"NextSelectionDown",
				"NextSelectionLeft",
				"NextSelectionRight",
				"NextSelectionUp",
				"AutoButtonColor",
				"Modal",
				"Image",
				"ImageColor3",
				"ImageRectOffset",
				"ImageRectSize",
				"ImageTransparency",
				"ScaleType",
				"SliceCenter",
				"Text",
				"TextColor3",
				"Font",
				"TextScaled",
				"TextStrokeColor3",
				"TextStrokeTransparency",
				"TextTransparency",
				"TextWrapped",
				"TextXAlignment",
				"TextYAlignment"
			}
			local classes = {
				"ScreenGui",
				"GuiMain",
				"Frame",
				"TextButton",
				"TextLabel",
				"ImageButton",
				"ImageLabel",
				"ScrollingFrame",
				"TextBox",
				"BillboardGui",
				"SurfaceGui"
			}
			local guis = {
				Properties = {Name = "ViewGuis", ClassName = "Folder"},
				Children = {}
			}
			local rLockedFound = false
			local add
			function add(tab, child)
				if not Anti.ObjRLocked(child) then
					local good = false
					for i, v in next, classes, nil do
						if child:IsA(v) then
							good = true
						end
					end
					if good then
						do
							local new = {
								Properties = {},
								Children = {}
							}
							for i, v in next, props, nil do
								pcall(function()
									new.Properties[v] = child[v]
								end)
							end
							for i, v in next, child:GetChildren() do
								add(new, v)
							end
							table.insert(tab.Children, new)
						end
					end
				else
					rLockedFound = true
				end
			end
			for i, v in next, service.PlayerGui:GetChildren() do
				pcall(add, guis, v)
			end
			return guis
		end,
		LoadGuiData = function(data)
			local make
			function make(dat)
				local props = dat.Properties
				local children = dat.Children
				local gui = service.New(props.ClassName)
				for i, v in next, props, nil do
					pcall(function()
						gui[i] = v
					end)
				end
				for i, v in next, children, nil do
					pcall(function()
						local g = make(v)
						if g then
							g.Parent = gui
						end
					end)
				end
				return gui
			end
			local temp = Instance.new("Folder")
			for i, v in next, service.PlayerGui:GetChildren() do
				if not UI.Get(v) then
					v.Parent = temp
				end
			end
			Variables.GuiViewFolder = temp
			local folder = service.New("Folder", {
				Parent = service.PlayerGui,
				Name = "LoadedGuis"
			})
			for i, v in next, data.Children, nil do
				pcall(function()
					local g = make(v)
					if g then
						g.Parent = folder
					end
				end)
			end
		end,
		UnLoadGuiData = function()
			for i, v in next, service.PlayerGui:GetChildren() do
				if v.Name == "LoadedGuis" then
					v:Destroy()
				end
			end
			if Variables.GuiViewFolder then
				for i, v in next, Variables.GuiViewFolder:GetChildren() do
					v.Parent = service.PlayerGui
				end
				Variables.GuiViewFolder:Destroy()
				Variables.GuiViewFolder = nil
			end
		end,
		GetParticleContainer = function(target)
			if target then
				for i, v in next, service.LocalContainer():GetChildren() do
					if v.Name == target:GetFullName() .. "PARTICLES" then
						local obj = v:FindFirstChild("_OBJECT")
						if obj.Value == target then
							return v
						end
					end
				end
			end
		end,
		NewParticle = function(target, class, properties)
			local part = Functions.GetParticleContainer(target)
			if target and not part then
				part = service.New("Part")
				part.Name = target:GetFullName() .. "PARTICLES"
				part.CanCollide = true
				part.Anchored = false
				part.Transparency = 1
				part.Size = Vector3.new(0.1, 0.1, 0.1)
				part.Locked = true
				part.Archivable = false
				part.Parent = service.LocalContainer()
				do
					local obj = Instance.new("ObjectValue", part)
					obj.Name = "_OBJECT"
					obj.Value = target
					local weld = service.New("Weld", part)
					weld.Name = "_WELD"
					weld.Part0 = part
					weld.Part1 = target
					weld.C0 = CFrame.new(0, 0, 0)
					weld.Changed:Connect(function()
						if not (weld and weld.Parent and weld.Parent == part and target) or not target.Parent then
							part:Destroy()
						end
					end)
				end
			end
			local effect = service.New(class, part)
			for prop, value in next, properties, nil do
				effect[prop] = value
			end
			effect.Enabled = Variables.ParticlesEnabled
			effect.Parent = part
			local index = Functions.GetRandom()
			Variables.Particles[index] = effect
			effect.Changed:Connect(function()
				if not (effect and effect.Parent) or effect.Parent ~= part then
					Variables.Particles[index] = nil
				end
			end)
		end,
		RemoveParticle = function(target, name)
			local part = Functions.GetParticleContainer(target)
			if part then
				for ind, effect in next, part:GetChildren() do
					if effect.Name == name then
						effect:Destroy()
					end
				end
			end
		end,
		EnableParticles = function(enabled)
			for i, effect in next, Variables.Particles, nil do
				if enabled then
					effect.Enabled = true
				else
					effect.Enabled = false
				end
			end
		end,
		NewLocal = function(class, props, parent)
			local obj = service.New(class)
			for prop, value in next, props, nil do
				obj[prop] = value
			end
			if not parent or parent == "LocalContainer" then
				obj.Parent = service.LocalContainer()
			elseif parent == "Camera" then
				obj.Parent = service.Workspace.CurrentCamera
			elseif parent == "PlayerGui" then
				obj.Parent = service.PlayerGui
			end
		end,
		MakeLocal = function(object, parent, clone)
			if object then
				local object = object
				if clone then
					object = object:Clone()
				end
				if not parent or parent == "LocalContainer" then
					object.Parent = service.LocalContainer()
				elseif parent == "Camera" then
					object.Parent = service.Workspace.CurrentCamera
				elseif parent == "PlayerGui" then
					object.Parent = service.PlayerGui
				end
			end
		end,
		MoveLocal = function(object, parent, newParent)
			local par
			if not parent or parent == "LocalContainer" then
				par = service.LocalContainer()
			elseif parent == "Camera" then
				par = service.Workspace.CurrentCamera
			elseif parent == "PlayerGui" then
				par = service.PlayerGui
			end
			for ind, obj in next, par:GetChildren() do
				if obj.Name == object or obj == obj then
					obj.Parent = newParent
				end
			end
		end,
		RemoveLocal = function(object, parent, match)
			local par
			if not parent or parent == "LocalContainer" then
				par = service.LocalContainer()
			elseif parent == "Camera" then
				par = service.Workspace.CurrentCamera
			elseif parent == "PlayerGui" then
				par = service.PlayerGui
			end
			for ind, obj in next, par:GetChildren() do
				if match and string.match(obj.Name, object) or obj.Name == object or object == obj then
					obj:Destroy()
				end
			end
		end,
		NewCape = function(data)
			local char = data.Parent
			local material = data.Material or "Neon"
			local color = data.Color or "White"
			local reflect = data.Reflectance or 0
			local decal = tonumber(data.Decal or "")
			if char then
				Functions.RemoveCape(char)
				local torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso") or char:FindFirstChild("HumanoidRootPart")
				local isR15 = torso.Name == "UpperTorso"
				if torso then
					local p = service.New("Part")
					p.Name = "ADONIS_CAPE"
					p.Anchored = false
					p.Position = torso.Position
					p.Transparency = 0
					p.Material = material
					p.CanCollide = false
					p.TopSurface = 0
					p.BottomSurface = 0
					p.Size = Vector3.new(2, 4, 0.1)
					p.BrickColor = BrickColor.new(color) or BrickColor.new("White")
					p.Parent = service.LocalContainer()
					if reflect then
						p.Reflectance = reflect
					end
					local motor1 = service.New("Motor", p)
					motor1.Part0 = p
					motor1.Part1 = torso
					motor1.MaxVelocity = 0.01
					motor1.C0 = CFrame.new(0, 1.75, 0) * CFrame.Angles(0, math.rad(90), 0)
					motor1.C1 = CFrame.new(0, 1 - (isR15 and 0.2 or 0), torso.Size.Z / 2) * CFrame.Angles(0, math.rad(90), 0)
					local msh = service.New("BlockMesh", p)
					msh.Scale = Vector3.new(0.9, 0.87, 0.1)
					local dec
					if decal and decal ~= 0 then
						dec = service.New("Decal", p)
						dec.Name = "Decal"
						dec.Face = 2
						dec.Texture = "http://www.roblox.com/asset/?id=" .. decal
						dec.Transparency = 0
					end
					local index = Functions.GetRandom()
					Variables.Capes[index] = {
						Part = p,
						Motor = motor1,
						Enabled = true,
						Parent = data.Parent,
						Torso = torso,
						Decal = dec,
						Data = data,
						Wave = true,
						isR15 = isR15
					}
					local p = service.Players:GetPlayerFromCharacter(data.Parent)
					if p and p == service.Player then
						Variables.Capes[index].isPlayer = true
					end
					if not Variables.CapesEnabled then
						p.Transparency = 1
						if dec then
							dec.Transparency = 1
						end
						Variables.Capes[index].Enabled = false
					end
					Functions.MoveCapes()
				end
			end
		end,
		RemoveCape = function(parent)
			for i, v in next, Variables.Capes, nil do
				if not (v.Parent ~= parent and v.Parent) or not v.Parent.Parent then
					pcall(v.Part.Destroy, v.Part)
					Variables.Capes[i] = nil
				end
			end
		end,
		HideCapes = function(hide)
			for i, v in next, Variables.Capes, nil do
				local torso = v.Torso
				local parent = v.Parent
				local part = v.Part
				local motor = v.Motor
				local wave = v.Wave
				local decal = v.Decal
				if parent and parent.Parent and torso and torso.Parent and part and part.Parent then
					if not hide then
						part.Transparency = 0
						if decal then
							decal.Transparency = 0
						end
						v.Enabled = true
					else
						part.Transparency = 1
						if decal then
							decal.Transparency = 1
						end
						v.Enabled = false
					end
				else
					pcall(part.Destroy, part)
					Variables.Capes[i] = nil
				end
			end
		end,
		MoveCapes = function()
			service.StopLoop("CapeMover")
			service.StartLoop("CapeMover", 0.1, function()
				if Functions.CountTable(Variables.Capes) == 0 or not Variables.CapesEnabled then
					service.StopLoop("CapeMover")
				else
					for i, v in next, Variables.Capes, nil do
						local torso = v.Torso
						local parent = v.Parent
						local isPlayer = v.isPlayer
						local isR15 = v.isR15
						local part = v.Part
						local motor = v.Motor
						local wave = v.Wave
						local decal = v.Decal
						if parent and parent.Parent and torso and torso.Parent and part and part.Parent then
							if v.Enabled and Variables.CapesEnabled then
								part.Transparency = 0
								if decal then
									decal.Transparency = 0
								end
								local ang = 0.1
								if wave then
									if torso.Velocity.magnitude > 1 then
										ang = ang + torso.Velocity.magnitude / 10 * 0.05 + 0.05
									end
									v.Wave = false
								else
									v.Wave = true
								end
								ang = ang + math.min(torso.Velocity.magnitude / 11, 0.8)
								motor.MaxVelocity = math.min(torso.Velocity.magnitude / 111, 0.04) + 0.002
								if isPlayer then
									motor.DesiredAngle = -ang
								else
									motor.CurrentAngle = -ang
								end
								if motor.CurrentAngle < -0.2 and motor.DesiredAngle > -0.2 then
									motor.MaxVelocity = 0.04
								end
							else
								part.Transparency = 1
								if decal then
									decal.Transparency = 1
								end
							end
						else
							pcall(part.Destroy, part)
							Variables.Capes[i] = nil
						end
					end
				end
			end, true)
		end,
		CountTable = function(tab)
			local count = 0
			for i, v in next, tab, nil do
				count = count + 1
			end
			return count
		end,
		ClearAllInstances = function()
			local objects = service.GetAdonisObjects()
			for i in next, objects, nil do
				i:Destroy()
				objects[i] = nil
			end
		end,
		PlayAnimation = function(animId)
			for i, v in next, service.Player.Character.Humanoid:GetPlayingAnimationTracks() do
				v:Stop()
			end
			if animId == 0 then
				return
			end
			local anim = service.New("Animation")
			anim.AnimationId = "http://www.roblox.com/Asset?ID=" .. animId
			anim.Name = "ADONIS_Animation"
			local track = service.Player.Character.Humanoid:LoadAnimation(anim)
			track:Play()
		end,
		SetLighting = function(prop, value)
			if service.Lighting[prop] ~= nil then
				service.Lighting[prop] = value
				Variables.LightingSettings[prop] = value
			end
		end,
		LocalLighting = function(on)
			if on then
				service.StartLoop("LocalLighting", "RenderStepped", function()
					for prop, value in next, Variables.LightingSettings, nil do
						if service.Lighting[prop] ~= nil then
							service.Lighting[prop] = value
						end
					end
				end)
			else
				service.StopLoop("LocalLighting")
			end
		end,
		ChatMessage = function(msg, color, font, size)
			local tab = {}
			tab.Text = msg
			if color then
				tab.Color = color
			end
			if font then
				tab.Font = font
			end
			if size then
				tab.Size = size
			end
			service.StarterGui:SetCore("ChatMakeSystemMessage", tab)
			if Functions.SendToChat then
				Functions.SendToChat({Name = "::Adonis::"}, msg, "Private")
			end
		end,
		SetCamProperty = function(prop, value)
			local cam = workspace.CurrentCamera
			if cam[prop] then
				cam[prop] = value
			end
		end,
		SetFPS = function(fps)
			service.StopLoop("SetFPS")
			local fps = tonumber(fps)
			if fps then
				service.StartLoop("SetFPS", 0.1, function()
					local ender = tick() + 1 / fps
					repeat
					until ender <= tick()
				end)
			end
		end,
		RestoreFPS = function()
			service.StopLoop("SetFPS")
		end,
		Crash = function()
			local Run = service.RunService
			local Lol = 0
			local Thread
			function Thread()
				Run:BindToRenderStep(tostring(Lol), 100, function()
					print("Stopping")
					Thread()
				end)
				Lol = Lol + 1
			end
			Thread()
		end,
		HardCrash = function()
			local crash, tab
			local gui = service.New("ScreenGui", service.PlayerGui)
			local rem = service.New("RemoteEvent", workspace.CurrentCamera)
			function crash()
				for i = 1, 50 do
					service.Debris:AddItem(service.New("Part", workspace.CurrentCamera), Infinity)
					print("((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)((((**&&#@#$$$$$%%%%:)")
					local f = service.New("Frame", gui)
					f.Size = UDim2.new(1, 0, 1, 0)
					spawn(function()
						table.insert(tab, string.rep(tostring(math.random()), 100))
					end)
					rem:FireServer("Hiiiiiiiiiiiiiiii")
					spawn(function()
						spawn(function()
							spawn(function()
								spawn(function()
									spawn(function()
										print("hi")
										spawn(crash)
									end)
								end)
							end)
						end)
					end)
				end
				tab = {}
			end
			while wait(0.01) do
				for i = 1, 50000000 do
					cPcall(function()
						client.GPUCrash()
					end)
					cPcall(function()
						crash()
					end)
					print(1)
				end
			end
		end,
		GPUCrash = function()
			local crash
			local gui = service.New("ScreenGui", service.PlayerGui)
			function crash()
				while wait(0.01) do
					for i = 1, 500000 do
						local f = service.New("Frame", gui)
						f.Size = UDim2.new(1, 0, 1, 0)
					end
				end
			end
			crash()
		end,
		RAMCrash = function()
			while wait(0.1) do
				for i = 1, 10000 do
					service.Debris:AddItem(service.New("Part", workspace.CurrentCamera), Infinity)
				end
			end
		end,
		KillClient = function()
			client.Kill("KillClient called")
		end,
		KeyBindListener = function()
			local timer = 0
			Variables.KeyBinds = Remote.Get("PlayerData").Keybinds or {}
			service.UserInputService.InputBegan:Connect(function(input)
				local key = tostring(input.KeyCode.Value)
				local textbox = service.UserInputService:GetFocusedTextBox()
				if Variables.KeybindsEnabled and not textbox and key and Variables.KeyBinds[key] and not Variables.WaitingForBind then
					local isAdmin = Remote.Get("CheckAdmin")
					if (tick() - timer > 5 or isAdmin) and pcall(string.char, key) then
						Remote.Send("ProcessCommand", Variables.KeyBinds[key], false, true)
						UI.Make("Hint", {
							Message = "[Ran] Key: " .. string.char(key) .. " | Command: " .. tostring(Variables.KeyBinds[key])
						})
					end
					timer = tick()
				end
			end)
		end,
		AddKeyBind = function(key, command)
			Variables.KeyBinds[tostring(key)] = command
			Remote.Get("UpdateKeybinds", Variables.KeyBinds)
			UI.Make("Hint", {
				Message = "Bound \"" .. string.char(key) .. "\" to " .. command
			})
		end,
		RemoveKeyBind = function(key)
			if Variables.KeyBinds[tostring(key)] ~= nil then
				Variables.KeyBinds[tostring(key)] = nil
				Remote.Get("UpdateKeybinds", Variables.KeyBinds)
				Routine(function()
					UI.Make("Hint", {
						Message = "Removed \"" .. string.char(key) .. "\" from key binds"
					})
				end)
			end
		end,
		BrickBlur = function(on, trans, color)
			local exists = service.LocalContainer():FindFirstChild("ADONIS_WINDOW_FUNC_BLUR")
			if exists then
				exists:Destroy()
			end
			if on then
				local pa = Instance.new("Part", workspace.CurrentCamera)
				pa.Name = "ADONIS_WINDOW_FUNC_BLUR"
				pa.Material = "Neon"
				pa.BrickColor = color or BrickColor.Black()
				pa.Transparency = trans or 0.5
				pa.CanCollide = false
				pa.Anchored = true
				pa.FormFactor = "Custom"
				pa.Size = Vector3.new(100, 100, 0)
				while pa and pa.Parent and wait(0.025) do
					pa.CFrame = workspace.CurrentCamera.CoordinateFrame * CFrame.new(0, 0, -2.5) * CFrame.Angles(12.6, 0, 0)
				end
			else
				for i, v in next, workspace.CurrentCamera:GetChildren() do
					if v.Name == "ADONIS_WINDOW_FUNC_BLUR" then
						v:Destroy()
					end
				end
			end
		end,
		PlayAudio = function(audioId, volume, pitch, looped)
			if Variables.localSounds[tostring(audioId)] then
				Variables.localSounds[tostring(audioId)]:Stop()
				Variables.localSounds[tostring(audioId)]:Destroy()
				Variables.localSounds[tostring(audioId)] = nil
			end
			local sound = service.New("Sound")
			sound.SoundId = "rbxassetid://" .. audioId
			if looped then
				sound.Looped = true
			end
			if volume then
				sound.Volume = volume
			end
			if pitch then
				sound.Pitch = pitch
			end
			sound.Name = "ADONI_LOCAL_SOUND " .. audioId
			sound.Parent = service.LocalContainer()
			Variables.localSounds[tostring(audioId)] = sound
			sound:Play()
			wait(1)
			repeat
				wait(0.1)
			until not sound.IsPlaying
			sound:Destroy()
			Variables.localSounds[tostring(audioId)] = nil
		end,
		StopAudio = function(audioId)
			if Variables.localSounds[tostring(audioId)] then
				Variables.localSounds[tostring(audioId)]:Stop()
				Variables.localSounds[tostring(audioId)]:Destroy()
				Variables.localSounds[tostring(audioId)] = nil
			end
		end,
		FadeAudio = function(audioId, inVol, pitch, looped, incWait)
			if not inVol then
				local sound = Variables.localSounds[tostring(audioId)]
				if sound then
					for i = sound.Volume, 0, -0.01 do
						sound.Volume = i
						wait(incWait or 0.1)
					end
					Functions.StopAudio(audioId)
				end
			else
				Functions.StopAudio(audioId)
				Functions.PlayAudio(audioId, 0, pitch, looped)
				local sound = Variables.localSounds[tostring(audioId)]
				if sound then
					for i = 0, inVol, 0.01 do
						sound.Volume = i
						wait(incWait or 0.1)
					end
				end
			end
		end,
		KillAllLocalAudio = function()
			for i, v in next, Variables.localSounds, nil do
				v:Stop()
				v:Destroy()
				table.remove(Variables.localSounds, i)
			end
		end,
		RemoveGuis = function()
			for i, v in next, service.PlayerGui:GetChildren() do
				if not UI.Get(v) then
					v:Destroy()
				end
			end
		end,
		SetCoreGuiEnabled = function(element, enabled)
			service.StarterGui:SetCoreGuiEnabled(element, enabled)
		end,
		UnCape = function()
			local cape = service.LocalContainer():FindFirstChild("::Adonis::Cape")
			if cape then
				cape:Destroy()
			end
		end,
		Cape = function(material, color, decal, reflect)
			local torso = service.Player.Character:FindFirstChild("HumanoidRootPart")
			if torso then
				local p = service.New("Part", service.LocalContainer())
				p.Name = "::Adonis::Cape"
				p.Anchored = true
				p.Transparency = 0.1
				p.Material = material
				p.CanCollide = false
				p.TopSurface = 0
				p.BottomSurface = 0
				if type(color) == "table" then
					color = Color3.new(color[1], color[2], color[3])
				end
				p.BrickColor = BrickColor.new(color) or BrickColor.new("White")
				if reflect then
					p.Reflectance = reflect
				end
				if decal and decal ~= 0 then
					local dec = service.New("Decal", p)
					dec.Face = 2
					dec.Texture = "http://www.roblox.com/asset/?id=" .. decal
					dec.Transparency = 0
				end
				p.formFactor = "Custom"
				p.Size = Vector3.new(0.2, 0.2, 0.2)
				local msh = service.New("BlockMesh", p)
				msh.Scale = Vector3.new(9, 17.5, 0.5)
				wait(0.1)
				p.Anchored = false
				local motor1 = service.New("Motor", p)
				motor1.Part0 = p
				motor1.Part1 = torso
				motor1.MaxVelocity = 0.01
				motor1.C0 = CFrame.new(0, 1.75, 0) * CFrame.Angles(0, math.rad(90), 0)
				motor1.C1 = CFrame.new(0, 1, torso.Size.Z / 2) * CFrame.Angles(0, math.rad(90), 0)
				local wave = false
				repeat
					wait(0.022727272727272728)
					local ang = 0.1
					local oldmag = torso.Velocity.magnitude
					local mv = 0.002
					if wave then
						ang = ang + torso.Velocity.magnitude / 10 * 0.05 + 0.05
						wave = false
					else
						wave = true
					end
					ang = ang + math.min(torso.Velocity.magnitude / 11, 0.5)
					motor1.MaxVelocity = math.min(torso.Velocity.magnitude / 111, 0.04) + mv
					motor1.DesiredAngle = -ang
					if motor1.CurrentAngle < -0.2 and motor1.DesiredAngle > -0.2 then
						motor1.MaxVelocity = 0.04
					end
					repeat
						wait()
					until motor1.CurrentAngle == motor1.DesiredAngle or math.abs(torso.Velocity.magnitude - oldmag) >= torso.Velocity.magnitude / 10 + 1
					if 0.1 > torso.Velocity.magnitude then
						wait(0.1)
					end
				until not (p and p.Parent) or p.Parent ~= service.LocalContainer()
			end
		end,
		TextToSpeech = function(str)
			local audioId = 296333956
			local audio = Instance.new("Sound", service.LocalContainer())
			audio.SoundId = "rbxassetid://" .. audioId
			audio.Volume = 1
			local audio2 = Instance.new("Sound", service.LocalContainer())
			audio2.SoundId = "rbxassetid://" .. audioId
			audio2.Volume = 1
			local phonemes = {
				{
					str = "%so",
					func = {17}
				},
				{
					str = "ing",
					func = {41}
				},
				{
					str = "oot",
					func = {4, 26}
				},
				{
					str = "or",
					func = {10}
				},
				{
					str = "oo",
					func = {3}
				},
				{
					str = "hi",
					func = {44, 19}
				},
				{
					str = "ie",
					func = {1}
				},
				{
					str = "eye",
					func = {19}
				},
				{
					str = "$Suy%s",
					real = "uy",
					func = {19}
				},
				{
					str = "%Sey%s",
					func = {1}
				},
				{
					str = "%sye",
					func = {19}
				},
				{
					str = "the",
					func = {25, 15}
				},
				{
					str = "th",
					func = {32, 0.2395}
				},
				{
					str = "ow",
					func = {20}
				},
				{
					str = "qu",
					func = {21, 38}
				},
				{
					str = "ee",
					func = {1}
				},
				{
					str = "i%s",
					delay = 0.5,
					func = {19}
				},
				{
					str = "ea",
					func = {1}
				},
				{
					str = "u(.*)e",
					real = "u",
					capture = true,
					func = {9}
				},
				{
					str = "ch",
					func = {24}
				},
				{
					str = "ere",
					func = {5}
				},
				{
					str = "ai",
					func = {6}
				},
				{
					str = "la",
					func = {39, 6}
				},
				{
					str = "oy",
					func = {8}
				},
				{
					str = "gh",
					func = {44}
				},
				{
					str = "sh",
					func = {22}
				},
				{
					str = "air",
					func = {18}
				},
				{
					str = "ar",
					func = {16}
				},
				{
					str = "ir",
					func = {11}
				},
				{
					str = "er",
					func = {12}
				},
				{
					str = "sio",
					func = {35}
				},
				{
					str = "ck",
					func = {21}
				},
				{
					str = "zy",
					func = {34, 1}
				},
				{
					str = "ny",
					func = {42, 1}
				},
				{
					str = "ly",
					func = {39, 1}
				},
				{
					str = "ey",
					func = {1}
				},
				{
					str = "ii",
					func = {19}
				},
				{
					str = "i",
					func = {2}
				},
				{
					str = "y",
					func = {37}
				},
				{
					str = "y",
					func = {37}
				},
				{
					str = "s",
					func = {23}
				},
				{
					str = "e",
					func = {13}
				},
				{
					str = "a",
					func = {14}
				},
				{
					str = "x",
					func = {21, 23}
				},
				{
					str = "u",
					func = {15}
				},
				{
					str = "o",
					func = {17}
				},
				{
					str = "c",
					func = {21}
				},
				{
					str = "k",
					func = {21}
				},
				{
					str = "t",
					func = {26}
				},
				{
					str = "f",
					func = {27}
				},
				{
					str = "i",
					func = {2}
				},
				{
					str = "p",
					func = {28}
				},
				{
					str = "b",
					func = {29}
				},
				{
					str = "v",
					func = {30}
				},
				{
					str = "d",
					func = {31}
				},
				{
					str = "j",
					func = {33}
				},
				{
					str = "z",
					func = {34}
				},
				{
					str = "g",
					func = {36}
				},
				{
					str = "w",
					func = {38}
				},
				{
					str = "l",
					func = {39}
				},
				{
					str = "r",
					func = {40}
				},
				{
					str = "n",
					func = {42}
				},
				{
					str = "m",
					func = {43}
				},
				{
					str = "h",
					func = {44}
				},
				{str = " ", func = "wait"},
				{str = "%.", func = "wait"},
				{str = "!", func = "wait"},
				{str = "?", func = "wait"},
				{str = ";", func = "wait"},
				{str = ":", func = "wait"}
			}
			game:service("ContentProvider"):Preload("rbxassetid://" .. audioId)
			local function getText(str)
				local tab = {}
				local str = str
				local function getNext()
					for i, v in ipairs(phonemes) do
						local occ, pos = string.find(string.lower(str), "^" .. v.str)
						if occ then
							if v.capture then
								local real = v.real
								local realStart, realEnd = string.find(string.lower(str), real)
								local capt = string.match(string.lower(str), v.str)
								if occ > realEnd then
									table.insert(tab, v)
									getText(capt)
								else
									getText(capt)
									table.insert(tab, v)
								end
							else
								table.insert(tab, v)
							end
							str = string.sub(str, pos + 1)
							getNext()
						end
					end
				end
				getNext()
				return tab
			end
			local phos = getText(str)
			local swap = false
			local function say(pos)
				local sound = audio
				if swap then
					sound = audio2
				end
				sound.TimePosition = pos
			end
			audio:Play()
			audio2:Play()
			for i, v in ipairs(phos) do
				if type(v.func) == "string" then
					wait(0.5)
				elseif type(v) == "table" then
					for l, p in ipairs(v.func) do
						if swap then
							swap = false
						else
							swap = true
						end
						say(p)
						if v.delay then
							wait(v.delay)
						else
							wait(0.1)
						end
					end
				end
			end
			wait(0.5)
			audio:Stop()
			audio2:Stop()
		end
	}
end
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX147"><Properties><string name="Name">cl_circles</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

function CircleClick(Button, X, Y, Nah)
	coroutine.resume(coroutine.create(function()
		Button.ClipsDescendants = true
		local Circle = script:WaitForChild("Circle"):Clone()
		local Sound = script:WaitForChild("Sound"):Clone()
		local Klik = script:WaitForChild("Click"):Clone()
		Circle.Parent = Button
		Sound.Parent = Button
		Klik.Parent = Button
		if not Nah then
			Sound:Play()
		else
			Klik:Play()
		end
		local NewX = X - Circle.AbsolutePosition.X
		local NewY = Y - Circle.AbsolutePosition.Y
		Circle.Position = UDim2.new(0, NewX, 0, NewY)
		local Size = 0
		if Button.AbsoluteSize.Y < Button.AbsoluteSize.X then
			Size = Button.AbsoluteSize.X * 1.5
		elseif Button.AbsoluteSize.X < Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.Y * 1.5
		elseif Button.AbsoluteSize.X == Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.X * 1.5
		end
		local Time = 0.3
		Circle:TweenSizeAndPosition(UDim2.new(0, Size, 0, Size), UDim2.new(0.5, -Size / 2, 0.5, -Size / 2), "Out", "Quad", Time, false, nil)
		local toTween = Circle.ImageTransparency
		for i = 1, 10 do
			Circle.ImageTransparency = 1 - toTween + toTween / 1 * (i / 10)
			wait(Time / 10)
		end
		Circle:Destroy()
		Sound:Destroy()
	end))
end
return CircleClick
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX152"><Properties><string name="Name">Invisicam</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local RunService = game:GetService("RunService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local USE_STACKING_TRANSPARENCY = true
local TARGET_TRANSPARENCY = 0.75
local TARGET_TRANSPARENCY_PERIPHERAL = 0.5
local MODE = {
	LIMBS = 2,
	MOVEMENT = 3,
	CORNERS = 4,
	CIRCLE1 = 5,
	CIRCLE2 = 6,
	LIMBMOVE = 7,
	SMART_CIRCLE = 8,
	CHAR_OUTLINE = 9
}
local LIMB_TRACKING_SET = {
	Head = true,
	["Left Arm"] = true,
	["Right Arm"] = true,
	["Left Leg"] = true,
	["Right Leg"] = true,
	LeftLowerArm = true,
	RightLowerArm = true,
	LeftUpperLeg = true,
	RightUpperLeg = true
}
local CORNER_FACTORS = {
	Vector3.new(1, 1, -1),
	Vector3.new(1, -1, -1),
	Vector3.new(-1, -1, -1),
	Vector3.new(-1, 1, -1)
}
local CIRCLE_CASTS = 10
local MOVE_CASTS = 3
local SMART_CIRCLE_CASTS = 24
local SMART_CIRCLE_INCREMENT = 2 * math.pi / SMART_CIRCLE_CASTS
local CHAR_OUTLINE_CASTS = 24
local AssertTypes = function(param, ...)
	local allowedTypes = {}
	local typeString = ""
	for _, typeName in pairs({
		...
	}) do
		allowedTypes[typeName] = true
		typeString = typeString .. (typeString == "" and "" or " or ") .. typeName
	end
	local theType = type(param)
	assert(allowedTypes[theType], typeString .. " type expected, got: " .. theType)
end
local Det3x3 = function(a, b, c, d, e, f, g, h, i)
	return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)
end
local function RayIntersection(p0, v0, p1, v1)
	local v2 = v0:Cross(v1)
	local d1 = p1.x - p0.x
	local d2 = p1.y - p0.y
	local d3 = p1.z - p0.z
	local denom = Det3x3(v0.x, -v1.x, v2.x, v0.y, -v1.y, v2.y, v0.z, -v1.z, v2.z)
	if denom == 0 then
		return ZERO_VECTOR3
	end
	local t0 = Det3x3(d1, -v1.x, v2.x, d2, -v1.y, v2.y, d3, -v1.z, v2.z) / denom
	local t1 = Det3x3(v0.x, d1, v2.x, v0.y, d2, v2.y, v0.z, d3, v2.z) / denom
	local s0 = p0 + t0 * v0
	local s1 = p1 + t1 * v1
	local s = s0 + 0.5 * (s1 - s0)
	if (s1 - s0).Magnitude < 0.25 then
		return s
	else
		return ZERO_VECTOR3
	end
end
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Invisicam = setmetatable({}, BaseOcclusion)
Invisicam.__index = Invisicam
function Invisicam.new()
	local self = setmetatable(BaseOcclusion.new(), Invisicam)
	self.char = nil
	self.humanoidRootPart = nil
	self.torsoPart = nil
	self.headPart = nil
	self.childAddedConn = nil
	self.childRemovedConn = nil
	self.behaviors = {}
	self.behaviors[MODE.LIMBS] = self.LimbBehavior
	self.behaviors[MODE.MOVEMENT] = self.MoveBehavior
	self.behaviors[MODE.CORNERS] = self.CornerBehavior
	self.behaviors[MODE.CIRCLE1] = self.CircleBehavior
	self.behaviors[MODE.CIRCLE2] = self.CircleBehavior
	self.behaviors[MODE.LIMBMOVE] = self.LimbMoveBehavior
	self.behaviors[MODE.SMART_CIRCLE] = self.SmartCircleBehavior
	self.behaviors[MODE.CHAR_OUTLINE] = self.CharacterOutlineBehavior
	self.mode = MODE.SMART_CIRCLE
	self.behaviorFunction = self.SmartCircleBehavior
	self.savedHits = {}
	self.trackedLimbs = {}
	self.camera = game.Workspace.CurrentCamera
	self.enabled = false
	return self
end
function Invisicam:Enable(enable)
	self.enabled = enable
	if not enable then
		self:Cleanup()
	end
end
function Invisicam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Invisicam
end
function Invisicam:LimbBehavior(castPoints)
	for limb, _ in pairs(self.trackedLimbs) do
		castPoints[#castPoints + 1] = limb.Position
	end
end
function Invisicam:MoveBehavior(castPoints)
	for i = 1, MOVE_CASTS do
		local position, velocity = self.humanoidRootPart.Position, self.humanoidRootPart.Velocity
		local horizontalSpeed = Vector3.new(velocity.X, 0, velocity.Z).Magnitude / 2
		local offsetVector = (i - 1) * self.humanoidRootPart.CFrame.lookVector * horizontalSpeed
		castPoints[#castPoints + 1] = position + offsetVector
	end
end
function Invisicam:CornerBehavior(castPoints)
	local cframe = self.humanoidRootPart.CFrame
	local centerPoint = cframe.p
	local rotation = cframe - centerPoint
	local halfSize = self.char:GetExtentsSize() / 2
	castPoints[#castPoints + 1] = centerPoint
	for i = 1, #CORNER_FACTORS do
		castPoints[#castPoints + 1] = centerPoint + rotation * (halfSize * CORNER_FACTORS[i])
	end
end
function Invisicam:CircleBehavior(castPoints)
	local cframe
	if self.mode == MODE.CIRCLE1 then
		cframe = self.humanoidRootPart.CFrame
	else
		local camCFrame = self.camera.CoordinateFrame
		cframe = camCFrame - camCFrame.p + self.humanoidRootPart.Position
	end
	castPoints[#castPoints + 1] = cframe.p
	for i = 0, CIRCLE_CASTS - 1 do
		local angle = 2 * math.pi / CIRCLE_CASTS * i
		local offset = 3 * Vector3.new(math.cos(angle), math.sin(angle), 0)
		castPoints[#castPoints + 1] = cframe * offset
	end
end
function Invisicam:LimbMoveBehavior(castPoints)
	self:LimbBehavior(castPoints)
	self:MoveBehavior(castPoints)
end
function Invisicam:CharacterOutlineBehavior(castPoints)
	local torsoUp = self.torsoPart.CFrame.upVector.unit
	local torsoRight = self.torsoPart.CFrame.rightVector.unit
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
	if self.headPart then
		castPoints[#castPoints + 1] = self.headPart.CFrame.p
	end
	local cframe = CFrame.new(ZERO_VECTOR3, Vector3.new(self.camera.CoordinateFrame.lookVector.X, 0, self.camera.CoordinateFrame.lookVector.Z))
	local centerPoint = self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position
	local partsWhitelist = {
		self.torsoPart
	}
	if self.headPart then
		partsWhitelist[#partsWhitelist + 1] = self.headPart
	end
	for i = 1, CHAR_OUTLINE_CASTS do
		local angle = 2 * math.pi * i / CHAR_OUTLINE_CASTS
		local offset = cframe * (3 * Vector3.new(math.cos(angle), math.sin(angle), 0))
		offset = Vector3.new(offset.X, math.max(offset.Y, -2.25), offset.Z)
		local ray = Ray.new(centerPoint + offset, -3 * offset)
		local hit, hitPoint = game.Workspace:FindPartOnRayWithWhitelist(ray, partsWhitelist, false, false)
		if hit then
			castPoints[#castPoints + 1] = hitPoint + 0.2 * (centerPoint - hitPoint).unit
		end
	end
end
function Invisicam:SmartCircleBehavior(castPoints)
	local torsoUp = self.torsoPart.CFrame.upVector.unit
	local torsoRight = self.torsoPart.CFrame.rightVector.unit
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
	if self.headPart then
		castPoints[#castPoints + 1] = self.headPart.CFrame.p
	end
	local cameraOrientation = self.camera.CFrame - self.camera.CFrame.p
	local torsoPoint = Vector3.new(0, 0.5, 0) + (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
	local radius = 2.5
	for i = 1, SMART_CIRCLE_CASTS do
		local angle = SMART_CIRCLE_INCREMENT * i - 0.5 * math.pi
		local offset = radius * Vector3.new(math.cos(angle), math.sin(angle), 0)
		local circlePoint = torsoPoint + cameraOrientation * offset
		local vp = circlePoint - self.camera.CFrame.p
		local ray = Ray.new(torsoPoint, circlePoint - torsoPoint)
		local hit, hp, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {
			self.char
		}, false, false)
		local castPoint = circlePoint
		if hit then
			local hprime = hp + 0.1 * hitNormal.unit
			local v0 = hprime - torsoPoint
			local d0 = v0.magnitude
			local perp = v0:Cross(vp).unit
			local v1 = perp:Cross(hitNormal).unit
			local vprime = (hprime - self.camera.CFrame.p).unit
			if v0.unit:Dot(-v1) < v0.unit:Dot(vprime) then
				castPoint = RayIntersection(hprime, v1, circlePoint, vp)
				if 0 < castPoint.Magnitude then
					local ray = Ray.new(hprime, castPoint - hprime)
					local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {
						self.char
					}, false, false)
					if hit then
						local hprime2 = hitPoint + 0.1 * hitNormal.unit
						castPoint = hprime2
					end
				else
					castPoint = hprime
				end
			else
				castPoint = hprime
			end
			local ray = Ray.new(torsoPoint, castPoint - torsoPoint)
			local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {
				self.char
			}, false, false)
			if hit then
				local castPoint2 = hitPoint - 0.1 * (castPoint - torsoPoint).unit
				castPoint = castPoint2
			end
		end
		castPoints[#castPoints + 1] = castPoint
	end
end
function Invisicam:CheckTorsoReference()
	if self.char then
		self.torsoPart = self.char:FindFirstChild("Torso")
		if not self.torsoPart then
			self.torsoPart = self.char:FindFirstChild("UpperTorso")
			if not self.torsoPart then
				self.torsoPart = self.char:FindFirstChild("HumanoidRootPart")
			end
		end
		self.headPart = self.char:FindFirstChild("Head")
	end
end
function Invisicam:CharacterAdded(char, player)
	if player ~= PlayersService.LocalPlayer then
		return
	end
	if self.childAddedConn then
		self.childAddedConn:Disconnect()
		self.childAddedConn = nil
	end
	if self.childRemovedConn then
		self.childRemovedConn:Disconnect()
		self.childRemovedConn = nil
	end
	self.char = char
	self.trackedLimbs = {}
	local function childAdded(child)
		if child:IsA("BasePart") then
			if LIMB_TRACKING_SET[child.Name] then
				self.trackedLimbs[child] = true
			end
			if child.Name == "Torso" or child.Name == "UpperTorso" then
				self.torsoPart = child
			end
			if child.Name == "Head" then
				self.headPart = child
			end
		end
	end
	local function childRemoved(child)
		self.trackedLimbs[child] = nil
		self:CheckTorsoReference()
	end
	self.childAddedConn = char.ChildAdded:Connect(childAdded)
	self.childRemovedConn = char.ChildRemoved:Connect(childRemoved)
	for _, child in pairs(self.char:GetChildren()) do
		childAdded(child)
	end
end
function Invisicam:SetMode(newMode)
	AssertTypes(newMode, "number")
	for modeName, modeNum in pairs(MODE) do
		if modeNum == newMode then
			self.mode = newMode
			self.behaviorFunction = self.behaviors[self.mode]
			return
		end
	end
	error("Invalid mode number")
end
function Invisicam:GetObscuredParts()
	return self.savedHits
end
function Invisicam:Cleanup()
	for hit, originalFade in pairs(self.savedHits) do
		hit.LocalTransparencyModifier = originalFade
	end
end
function Invisicam:Update(dt, desiredCameraCFrame, desiredCameraFocus)
	if not self.enabled or not self.char then
		return desiredCameraCFrame, desiredCameraFocus
	end
	self.camera = game.Workspace.CurrentCamera
	if not self.humanoidRootPart then
		do
			local humanoid = self.char:FindFirstChildOfClass("Humanoid")
			if humanoid and humanoid.RootPart then
				self.humanoidRootPart = humanoid.RootPart
			else
				self.humanoidRootPart = self.char:FindFirstChild("HumanoidRootPart")
				if not self.humanoidRootPart then
					return desiredCameraCFrame, desiredCameraFocus
				end
			end
			local ancestryChangedConn
			ancestryChangedConn = self.humanoidRootPart.AncestryChanged:Connect(function(child, parent)
				if child == self.humanoidRootPart and not parent then
					self.humanoidRootPart = nil
					if ancestryChangedConn and ancestryChangedConn.Connected then
						ancestryChangedConn:Disconnect()
						ancestryChangedConn = nil
					end
				end
			end)
		end
	end
	if not self.torsoPart then
		self:CheckTorsoReference()
		if not self.torsoPart then
			return desiredCameraCFrame, desiredCameraFocus
		end
	end
	local castPoints = {}
	self.behaviorFunction(self, castPoints)
	local currentHits = {}
	local ignoreList = {
		self.char
	}
	local function add(hit)
		currentHits[hit] = true
		if not self.savedHits[hit] then
			self.savedHits[hit] = hit.LocalTransparencyModifier
		end
	end
	local hitParts
	local hitPartCount = 0
	local headTorsoRayHitParts = {}
	local partIsTouchingCamera = {}
	local perPartTransparencyHeadTorsoHits = TARGET_TRANSPARENCY
	local perPartTransparencyOtherHits = TARGET_TRANSPARENCY
	if USE_STACKING_TRANSPARENCY then
		local headPoint = self.headPart and self.headPart.CFrame.p or castPoints[1]
		local torsoPoint = self.torsoPart and self.torsoPart.CFrame.p or castPoints[2]
		hitParts = self.camera:GetPartsObscuringTarget({headPoint, torsoPoint}, ignoreList)
		for i = 1, #hitParts do
			local hitPart = hitParts[i]
			hitPartCount = hitPartCount + 1
			headTorsoRayHitParts[hitPart] = true
			for _, child in pairs(hitPart:GetChildren()) do
				if child:IsA("Decal") or child:IsA("Texture") then
					hitPartCount = hitPartCount + 1
					break
				end
			end
		end
		if hitPartCount > 0 then
			perPartTransparencyHeadTorsoHits = math.pow(0.5 * TARGET_TRANSPARENCY + 0.5 * TARGET_TRANSPARENCY / hitPartCount, 1 / hitPartCount)
			perPartTransparencyOtherHits = math.pow(0.5 * TARGET_TRANSPARENCY_PERIPHERAL + 0.5 * TARGET_TRANSPARENCY_PERIPHERAL / hitPartCount, 1 / hitPartCount)
		end
	end
	hitParts = self.camera:GetPartsObscuringTarget(castPoints, ignoreList)
	local partTargetTransparency = {}
	for i = 1, #hitParts do
		local hitPart = hitParts[i]
		partTargetTransparency[hitPart] = headTorsoRayHitParts[hitPart] and perPartTransparencyHeadTorsoHits or perPartTransparencyOtherHits
		if hitPart.Transparency < partTargetTransparency[hitPart] then
			add(hitPart)
		end
		for _, child in pairs(hitPart:GetChildren()) do
			if (child:IsA("Decal") or child:IsA("Texture")) and child.Transparency < partTargetTransparency[hitPart] then
				partTargetTransparency[child] = partTargetTransparency[hitPart]
				add(child)
			end
		end
	end
	for hitPart, originalLTM in pairs(self.savedHits) do
		if currentHits[hitPart] then
			hitPart.LocalTransparencyModifier = 1 > hitPart.Transparency and (partTargetTransparency[hitPart] - hitPart.Transparency) / (1 - hitPart.Transparency) or 0
		else
			hitPart.LocalTransparencyModifier = originalLTM
			self.savedHits[hitPart] = nil
		end
	end
	return desiredCameraCFrame, desiredCameraFocus
end
return Invisicam
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX157"><Properties><string name="Name">OrbitalCamera</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UNIT_X = Vector3.new(1, 0, 0)
local UNIT_Y = Vector3.new(0, 1, 0)
local UNIT_Z = Vector3.new(0, 0, 1)
local X1_Y0_Z1 = Vector3.new(1, 0, 1)
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local ZERO_VECTOR2 = Vector2.new(0, 0)
local TAU = 2 * math.pi
local VR_PITCH_FRACTION = 0.25
local tweenAcceleration = math.rad(220)
local tweenSpeed = math.rad(0)
local tweenMaxSpeed = math.rad(250)
local TIME_BEFORE_AUTO_ROTATE = 2
local PORTRAIT_OFFSET = Vector3.new(0, -3, 0)
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local THUMBSTICK_DEADZONE = 0.2
local MIN_ALLOWED_ELEVATION_DEG = -80
local MAX_ALLOWED_ELEVATION_DEG = 80
local externalProperties = {}
externalProperties.InitialDistance = 25
externalProperties.MinDistance = 10
externalProperties.MaxDistance = 100
externalProperties.InitialElevation = 35
externalProperties.MinElevation = 35
externalProperties.MaxElevation = 35
externalProperties.ReferenceAzimuth = -45
externalProperties.CWAzimuthTravel = 90
externalProperties.CCWAzimuthTravel = 90
externalProperties.UseAzimuthLimits = false
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local VRService = game:GetService("VRService")
local GetValueObject = function(name, defaultValue)
	local valueObj = script:FindFirstChild(name)
	if valueObj then
		return valueObj.Value
	end
	return defaultValue
end
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local OrbitalCamera = setmetatable({}, BaseCamera)
OrbitalCamera.__index = OrbitalCamera
function OrbitalCamera.new()
	local self = setmetatable(BaseCamera.new(), OrbitalCamera)
	self.lastUpdate = tick()
	self.changedSignalConnections = {}
	self.refAzimuthRad = nil
	self.curAzimuthRad = nil
	self.minAzimuthAbsoluteRad = nil
	self.maxAzimuthAbsoluteRad = nil
	self.useAzimuthLimits = nil
	self.curElevationRad = nil
	self.minElevationRad = nil
	self.maxElevationRad = nil
	self.curDistance = nil
	self.minDistance = nil
	self.maxDistance = nil
	self.r3ButtonDown = false
	self.l3ButtonDown = false
	self.gamepadDollySpeedMultiplier = 1
	self.lastUserPanCamera = tick()
	self.externalProperties = {}
	self.externalProperties.InitialDistance = 25
	self.externalProperties.MinDistance = 10
	self.externalProperties.MaxDistance = 100
	self.externalProperties.InitialElevation = 35
	self.externalProperties.MinElevation = 35
	self.externalProperties.MaxElevation = 35
	self.externalProperties.ReferenceAzimuth = -45
	self.externalProperties.CWAzimuthTravel = 90
	self.externalProperties.CCWAzimuthTravel = 90
	self.externalProperties.UseAzimuthLimits = false
	self:LoadNumberValueParameters()
	return self
end
function OrbitalCamera:LoadOrCreateNumberValueParameter(name, valueType, updateFunction)
	local valueObj = script:FindFirstChild(name)
	if valueObj and valueObj:isA(valueType) then
		self.externalProperties[name] = valueObj.Value
	elseif self.externalProperties[name] ~= nil then
		valueObj = Instance.new(valueType)
		valueObj.Name = name
		valueObj.Parent = script
		valueObj.Value = self.externalProperties[name]
	else
		print("externalProperties table has no entry for ", name)
		return
	end
	if updateFunction then
		if self.changedSignalConnections[name] then
			self.changedSignalConnections[name]:Disconnect()
		end
		self.changedSignalConnections[name] = valueObj.Changed:Connect(function(newValue)
			self.externalProperties[name] = newValue
			updateFunction(self)
		end)
	end
end
function OrbitalCamera:SetAndBoundsCheckAzimuthValues()
	self.minAzimuthAbsoluteRad = math.rad(self.externalProperties.ReferenceAzimuth) - math.abs(math.rad(self.externalProperties.CWAzimuthTravel))
	self.maxAzimuthAbsoluteRad = math.rad(self.externalProperties.ReferenceAzimuth) + math.abs(math.rad(self.externalProperties.CCWAzimuthTravel))
	self.useAzimuthLimits = self.externalProperties.UseAzimuthLimits
	if self.useAzimuthLimits then
		self.curAzimuthRad = math.max(self.curAzimuthRad, self.minAzimuthAbsoluteRad)
		self.curAzimuthRad = math.min(self.curAzimuthRad, self.maxAzimuthAbsoluteRad)
	end
end
function OrbitalCamera:SetAndBoundsCheckElevationValues()
	local minElevationDeg = math.max(self.externalProperties.MinElevation, MIN_ALLOWED_ELEVATION_DEG)
	local maxElevationDeg = math.min(self.externalProperties.MaxElevation, MAX_ALLOWED_ELEVATION_DEG)
	self.minElevationRad = math.rad(math.min(minElevationDeg, maxElevationDeg))
	self.maxElevationRad = math.rad(math.max(minElevationDeg, maxElevationDeg))
	self.curElevationRad = math.max(self.curElevationRad, self.minElevationRad)
	self.curElevationRad = math.min(self.curElevationRad, self.maxElevationRad)
end
function OrbitalCamera:SetAndBoundsCheckDistanceValues()
	self.minDistance = self.externalProperties.MinDistance
	self.maxDistance = self.externalProperties.MaxDistance
	self.curDistance = math.max(self.curDistance, self.minDistance)
	self.curDistance = math.min(self.curDistance, self.maxDistance)
end
function OrbitalCamera:LoadNumberValueParameters()
	self:LoadOrCreateNumberValueParameter("InitialElevation", "NumberValue", nil)
	self:LoadOrCreateNumberValueParameter("InitialDistance", "NumberValue", nil)
	self:LoadOrCreateNumberValueParameter("ReferenceAzimuth", "NumberValue", self.SetAndBoundsCheckAzimuthValue)
	self:LoadOrCreateNumberValueParameter("CWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
	self:LoadOrCreateNumberValueParameter("CCWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
	self:LoadOrCreateNumberValueParameter("MinElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
	self:LoadOrCreateNumberValueParameter("MaxElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
	self:LoadOrCreateNumberValueParameter("MinDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
	self:LoadOrCreateNumberValueParameter("MaxDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
	self:LoadOrCreateNumberValueParameter("UseAzimuthLimits", "BoolValue", self.SetAndBoundsCheckAzimuthValues)
	self.curAzimuthRad = math.rad(self.externalProperties.ReferenceAzimuth)
	self.curElevationRad = math.rad(self.externalProperties.InitialElevation)
	self.curDistance = self.externalProperties.InitialDistance
	self:SetAndBoundsCheckAzimuthValues()
	self:SetAndBoundsCheckElevationValues()
	self:SetAndBoundsCheckDistanceValues()
end
function OrbitalCamera:GetModuleName()
	return "OrbitalCamera"
end
function OrbitalCamera:SetInitialOrientation(humanoid)
	if not humanoid or not humanoid.RootPart then
		warn("OrbitalCamera could not set initial orientation due to missing humanoid")
		return
	end
	local newDesiredLook = (humanoid.RootPart.CFrame.lookVector - Vector3.new(0, 0.23, 0)).unit
	local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, self:GetCameraLookVector())
	local vertShift = math.asin(self:GetCameraLookVector().y) - math.asin(newDesiredLook.y)
	if not Util.IsFinite(horizontalShift) then
		horizontalShift = 0
	end
	if not Util.IsFinite(vertShift) then
		vertShift = 0
	end
	self.rotateInput = Vector2.new(horizontalShift, vertShift)
end
function OrbitalCamera:GetCameraToSubjectDistance()
	return self.curDistance
end
function OrbitalCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	print("OrbitalCamera SetCameraToSubjectDistance ", desiredSubjectDistance)
	local player = PlayersService.LocalPlayer
	if player then
		self.currentSubjectDistance = Util.Clamp(self.minDistance, self.maxDistance, desiredSubjectDistance)
		self.currentSubjectDistance = math.max(self.currentSubjectDistance, self.FIRST_PERSON_DISTANCE_THRESHOLD)
	end
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
	return self.currentSubjectDistance
end
function OrbitalCamera:CalculateNewLookVector(suppliedLookVector, xyRotateVector)
	local currLookVector = suppliedLookVector or self:GetCameraLookVector()
	local currPitchAngle = math.asin(currLookVector.y)
	local yTheta = Util.Clamp(currPitchAngle - math.rad(MAX_ALLOWED_ELEVATION_DEG), currPitchAngle - math.rad(MIN_ALLOWED_ELEVATION_DEG), xyRotateVector.y)
	local constrainedRotateInput = Vector2.new(xyRotateVector.x, yTheta)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local newLookVector = (CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y, 0, 0)).lookVector
	return newLookVector
end
function OrbitalCamera:GetGamepadPan(name, state, input)
	if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
		if self.r3ButtonDown or self.l3ButtonDown then
			if input.Position.Y > THUMBSTICK_DEADZONE then
				self.gamepadDollySpeedMultiplier = 0.96
			elseif input.Position.Y < -THUMBSTICK_DEADZONE then
				self.gamepadDollySpeedMultiplier = 1.04
			else
				self.gamepadDollySpeedMultiplier = 1
			end
		else
			if state == Enum.UserInputState.Cancel then
				self.gamepadPanningCamera = ZERO_VECTOR2
				return
			end
			local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
			if inputVector.magnitude > THUMBSTICK_DEADZONE then
				self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
			else
				self.gamepadPanningCamera = ZERO_VECTOR2
			end
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function OrbitalCamera:DoGamepadZoom(name, state, input)
	if input.UserInputType == self.activeGamepad and (input.KeyCode == Enum.KeyCode.ButtonR3 or input.KeyCode == Enum.KeyCode.ButtonL3) then
		if state == Enum.UserInputState.Begin then
			self.r3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonR3
			self.l3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonL3
		elseif state == Enum.UserInputState.End then
			if input.KeyCode == Enum.KeyCode.ButtonR3 then
				self.r3ButtonDown = false
			elseif input.KeyCode == Enum.KeyCode.ButtonL3 then
				self.l3ButtonDown = false
			end
			if not self.r3ButtonDown and not self.l3ButtonDown then
				self.gamepadDollySpeedMultiplier = 1
			end
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function OrbitalCamera:BindGamepadInputActions()
	if FFlagPlayerScriptsBindAtPriority2 then
		self:BindAction("OrbitalCamGamepadPan", function(name, state, input)
			return self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		self:BindAction("OrbitalCamGamepadZoom", function(name, state, input)
			return self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonR3, Enum.KeyCode.ButtonL3)
	else
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:BindAction("OrbitalCamGamepadPan", function(name, state, input)
			self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		ContextActionService:BindAction("OrbitalCamGamepadZoom", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonR3)
		ContextActionService:BindAction("OrbitalCamGamepadZoomAlt", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonL3)
	end
end
function OrbitalCamera:Update(dt)
	local now = tick()
	local timeDelta = now - self.lastUpdate
	local userPanningTheCamera = self.UserPanningTheCamera == true
	local camera = workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera and camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	local isOnASkateboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end
	if self.lastUpdate then
		local gamepadRotation = self:UpdateGamepad()
		if self:ShouldUseVRRotation() then
			self.RotateInput = self.RotateInput + self:GetVRRotationInput()
		else
			local delta = math.min(0.1, timeDelta)
			if gamepadRotation ~= ZERO_VECTOR2 then
				userPanningTheCamera = true
				self.rotateInput = self.rotateInput + gamepadRotation * delta
			end
			local angle = 0
			if not isInVehicle and not isOnASkateboard then
				angle = angle + (self.TurningLeft and -120 or 0)
				angle = angle + (self.TurningRight and 120 or 0)
			end
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(math.rad(angle * delta), 0)
				userPanningTheCamera = true
			end
		end
	end
	if userPanningTheCamera then
		tweenSpeed = 0
		self.lastUserPanCamera = tick()
	end
	local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
	local subjectPosition = self:GetSubjectPosition()
	if subjectPosition and player and camera then
		if self.gamepadDollySpeedMultiplier ~= 1 then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance * self.gamepadDollySpeedMultiplier)
		end
		local VREnabled = VRService.VREnabled
		newCameraFocus = VREnabled and self:GetVRFocus(subjectPosition, timeDelta) or CFrame.new(subjectPosition)
		local cameraFocusP = newCameraFocus.p
		if VREnabled and not self:IsInFirstPerson() then
			local cameraHeight = self:GetCameraHeight()
			local vecToSubject = subjectPosition - camera.CFrame.p
			local distToSubject = vecToSubject.magnitude
			if distToSubject > self.currentSubjectDistance or self.rotateInput.x ~= 0 then
				local desiredDist = math.min(distToSubject, self.currentSubjectDistance)
				vecToSubject = self:CalculateNewLookVector(vecToSubject.unit * X1_Y0_Z1, Vector2.new(self.rotateInput.x, 0)) * desiredDist
				local newPos = cameraFocusP - vecToSubject
				local desiredLookDir = camera.CFrame.lookVector
				if self.rotateInput.x ~= 0 then
					desiredLookDir = vecToSubject
				end
				local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
				self.RotateInput = ZERO_VECTOR2
				newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
			end
		else
			self.curAzimuthRad = self.curAzimuthRad - self.rotateInput.x
			if self.useAzimuthLimits then
				self.curAzimuthRad = Util.Clamp(self.minAzimuthAbsoluteRad, self.maxAzimuthAbsoluteRad, self.curAzimuthRad)
			else
				self.curAzimuthRad = self.curAzimuthRad ~= 0 and math.sign(self.curAzimuthRad) * (math.abs(self.curAzimuthRad) % TAU) or 0
			end
			self.curElevationRad = Util.Clamp(self.minElevationRad, self.maxElevationRad, self.curElevationRad + self.rotateInput.y)
			local cameraPosVector = self.currentSubjectDistance * (CFrame.fromEulerAnglesYXZ(-self.curElevationRad, self.curAzimuthRad, 0) * UNIT_Z)
			local camPos = subjectPosition + cameraPosVector
			newCameraCFrame = CFrame.new(camPos, subjectPosition)
			self.rotateInput = ZERO_VECTOR2
		end
		self.lastCameraTransform = newCameraCFrame
		self.lastCameraFocus = newCameraFocus
		if (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
			self.lastSubjectCFrame = cameraSubject.CFrame
		else
			self.lastSubjectCFrame = nil
		end
	end
	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end
return OrbitalCamera
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX162"><Properties><string name="Name">MouseLockController</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local DEFAULT_MOUSE_LOCK_CURSOR = "rbxasset://textures/MouseLockedCursor.png"
local CONTEXT_ACTION_NAME = "MouseLockSwitchAction"
local MOUSELOCK_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local Settings = UserSettings()
local GameSettings = Settings.GameSettings
local Mouse = PlayersService.LocalPlayer:GetMouse()
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local MouseLockController = {}
MouseLockController.__index = MouseLockController
function MouseLockController.new()
	local self = setmetatable({}, MouseLockController)
	self.inputBeganConn = nil
	self.isMouseLocked = false
	self.savedMouseCursor = nil
	self.boundKeys = {
		Enum.KeyCode.LeftShift,
		Enum.KeyCode.RightShift
	}
	self.mouseLockToggledEvent = Instance.new("BindableEvent")
	local boundKeysObj = script:FindFirstChild("BoundKeys")
	if not boundKeysObj or not boundKeysObj:IsA("StringValue") then
		if boundKeysObj then
			boundKeysObj:Destroy()
		end
		boundKeysObj = Instance.new("StringValue")
		boundKeysObj.Name = "BoundKeys"
		boundKeysObj.Value = "LeftShift,RightShift"
		boundKeysObj.Parent = script
	end
	if boundKeysObj then
		boundKeysObj.Changed:Connect(function(value)
			self:OnBoundKeysObjectChanged(value)
		end)
		self:OnBoundKeysObjectChanged(boundKeysObj.Value)
	end
	GameSettings.Changed:Connect(function(property)
		if property == "ControlMode" or property == "ComputerMovementMode" then
			self:UpdateMouseLockAvailability()
		end
	end)
	PlayersService.LocalPlayer:GetPropertyChangedSignal("DevEnableMouseLock"):Connect(function()
		self:UpdateMouseLockAvailability()
	end)
	PlayersService.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
		self:UpdateMouseLockAvailability()
	end)
	self:UpdateMouseLockAvailability()
	return self
end
function MouseLockController:GetIsMouseLocked()
	return self.isMouseLocked
end
function MouseLockController:GetBindableToggleEvent()
	return self.mouseLockToggledEvent.Event
end
function MouseLockController:GetMouseLockOffset()
	local offsetValueObj = script:FindFirstChild("CameraOffset")
	if offsetValueObj and offsetValueObj:IsA("Vector3Value") then
		return offsetValueObj.Value
	else
		if offsetValueObj then
			offsetValueObj:Destroy()
		end
		offsetValueObj = Instance.new("Vector3Value")
		offsetValueObj.Name = "CameraOffset"
		offsetValueObj.Value = Vector3.new(1.75, 0, 0)
		offsetValueObj.Parent = script
	end
	if offsetValueObj and offsetValueObj.Value then
		return offsetValueObj.Value
	end
	return Vector3.new(1.75, 0, 0)
end
function MouseLockController:UpdateMouseLockAvailability()
	local devAllowsMouseLock = PlayersService.LocalPlayer.DevEnableMouseLock
	local devMovementModeIsScriptable = PlayersService.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable
	local userHasMouseLockModeEnabled = GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch
	local userHasClickToMoveEnabled = GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove
	local MouseLockAvailable = devAllowsMouseLock and userHasMouseLockModeEnabled and not userHasClickToMoveEnabled and not devMovementModeIsScriptable
	if MouseLockAvailable ~= self.enabled then
		self:EnableMouseLock(MouseLockAvailable)
	end
end
function MouseLockController:OnBoundKeysObjectChanged(newValue)
	self.boundKeys = {}
	for token in string.gmatch(newValue, "[^%s,]+") do
		for keyCode, keyEnum in pairs(Enum.KeyCode:GetEnumItems()) do
			if token == keyEnum.Name then
				self.boundKeys[#self.boundKeys + 1] = keyEnum
				break
			end
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		self:UnbindContextActions()
		self:BindContextActions()
	end
end
function MouseLockController:OnMouseLockToggled()
	self.isMouseLocked = not self.isMouseLocked
	if self.isMouseLocked then
		local cursorImageValueObj = script:FindFirstChild("CursorImage")
		if cursorImageValueObj and cursorImageValueObj:IsA("StringValue") and cursorImageValueObj.Value then
			self.savedMouseCursor = Mouse.Icon
			Mouse.Icon = cursorImageValueObj.Value
		else
			if cursorImageValueObj then
				cursorImageValueObj:Destroy()
			end
			cursorImageValueObj = Instance.new("StringValue")
			cursorImageValueObj.Name = "CursorImage"
			cursorImageValueObj.Value = DEFAULT_MOUSE_LOCK_CURSOR
			cursorImageValueObj.Parent = script
			self.savedMouseCursor = Mouse.Icon
			Mouse.Icon = DEFAULT_MOUSE_LOCK_CURSOR
		end
	elseif self.savedMouseCursor then
		Mouse.Icon = self.savedMouseCursor
		self.savedMouseCursor = nil
	end
	self.mouseLockToggledEvent:Fire()
end
function MouseLockController:OnInputBegan(input, processed)
	if processed then
		return
	end
	if input.UserInputType == Enum.UserInputType.Keyboard then
		for _, keyCode in pairs(self.boundKeys) do
			if keyCode == input.KeyCode then
				self:OnMouseLockToggled()
				return
			end
		end
	end
end
function MouseLockController:DoMouseLockSwitch(name, state, input)
	if state == Enum.UserInputState.Begin then
		self:OnMouseLockToggled()
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function MouseLockController:BindContextActions()
	ContextActionService:BindActionAtPriority(CONTEXT_ACTION_NAME, function(name, state, input)
		return self:DoMouseLockSwitch(name, state, input)
	end, false, MOUSELOCK_ACTION_PRIORITY, unpack(self.boundKeys))
end
function MouseLockController:UnbindContextActions()
	ContextActionService:UnbindAction(CONTEXT_ACTION_NAME)
end
function MouseLockController:IsMouseLocked()
	return self.enabled and self.isMouseLocked
end
function MouseLockController:EnableMouseLock(enable)
	if enable ~= self.enabled then
		self.enabled = enable
		if self.enabled then
			if FFlagPlayerScriptsBindAtPriority2 then
				self:BindContextActions()
			else
				if self.inputBeganConn then
					self.inputBeganConn:Disconnect()
				end
				self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
					self:OnInputBegan(input, processed)
				end)
			end
		else
			if Mouse.Icon ~= "" then
				Mouse.Icon = ""
			end
			if FFlagPlayerScriptsBindAtPriority2 then
				self:UnbindContextActions()
			else
				if self.inputBeganConn then
					self.inputBeganConn:Disconnect()
				end
				self.inputBeganConn = nil
			end
			if self.isMouseLocked then
				self.mouseLockToggledEvent:Fire()
			end
			self.isMouseLocked = false
		end
	end
end
return MouseLockController
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX167"><Properties><string name="Name">ClassicCamera</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZERO_VECTOR2 = Vector2.new(0, 0)
local tweenAcceleration = math.rad(220)
local tweenSpeed = math.rad(0)
local tweenMaxSpeed = math.rad(250)
local TIME_BEFORE_AUTO_ROTATE = 2
local PORTRAIT_OFFSET = Vector3.new(0, 2, 0)
local MOBILE_OFFSET = Vector3.new(0, 1, 0)
local INITIAL_CAMERA_ANGLE = CFrame.fromOrientation(math.rad(-15), 0, 0)
local PlayersService = game:GetService("Players")
local VRService = game:GetService("VRService")
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local newCameraConstantsFlagExists, newCameraConstantsFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserUpdateCameraConstants")
end)
local FFlagUserUpdateCameraConstants = newCameraConstantsFlagExists and newCameraConstantsFlagEnabled
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local ClassicCamera = setmetatable({}, BaseCamera)
ClassicCamera.__index = ClassicCamera
function ClassicCamera.new()
	local self = setmetatable(BaseCamera.new(), ClassicCamera)
	self.isFollowCamera = false
	self.lastUpdate = tick()
	return self
end
function ClassicCamera:GetModuleName()
	return "ClassicCamera"
end
function ClassicCamera:SetCameraMovementMode(cameraMovementMode)
	BaseCamera.SetCameraMovementMode(self, cameraMovementMode)
	self.isFollowCamera = cameraMovementMode == Enum.ComputerCameraMovementMode.Follow
end
function ClassicCamera:Test()
	print("ClassicCamera:Test()")
end
function ClassicCamera:GetCameraSubjectOffset()
	if self:IsInFirstPerson() then
		return Vector3.new(0, 0, 0)
	elseif self.portraitMode then
		return PORTRAIT_OFFSET
	elseif self.isSmallTouchScreen then
		return MOBILE_OFFSET
	end
	return Vector3.new(0, 0, 0)
end
function ClassicCamera:Update()
	local now = tick()
	local timeDelta = now - self.lastUpdate
	local camera = workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local overrideCameraLookVector
	if self.resetCameraAngle then
		local rootPart = self:GetHumanoidRootPart()
		if rootPart then
			overrideCameraLookVector = (rootPart.CFrame * INITIAL_CAMERA_ANGLE).lookVector
		else
			overrideCameraLookVector = INITIAL_CAMERA_ANGLE.lookVector
		end
		self.resetCameraAngle = false
	end
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	local isOnASkateboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end
	if self.lastUpdate then
		local gamepadRotation = self:UpdateGamepad()
		if self:ShouldUseVRRotation() then
			self.rotateInput = self.rotateInput + self:GetVRRotationInput()
		else
			local delta = math.min(0.1, timeDelta)
			if gamepadRotation ~= ZERO_VECTOR2 then
				self.rotateInput = self.rotateInput + gamepadRotation * delta
			end
			local angle = 0
			if not isInVehicle and not isOnASkateboard then
				angle = angle + (self.turningLeft and -120 or 0)
				angle = angle + (self.turningRight and 120 or 0)
			end
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(math.rad(angle * delta), 0)
			end
		end
	end
	if self.userPanningTheCamera then
		tweenSpeed = 0
		self.lastUserPanCamera = tick()
	end
	local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
	local subjectPosition = self:GetSubjectPosition()
	if subjectPosition and player and camera then
		local zoom = self:GetCameraToSubjectDistance()
		if zoom < 0.5 then
			zoom = 0.5
		end
		if self:GetIsMouseLocked() and not self:IsInFirstPerson() then
			local newLookCFrame = self:CalculateNewLookCFrame(overrideCameraLookVector)
			local offset = self:GetMouseLockOffset()
			local cameraRelativeOffset = offset.X * newLookCFrame.rightVector + offset.Y * newLookCFrame.upVector + offset.Z * newLookCFrame.lookVector
			if Util.IsFiniteVector3(cameraRelativeOffset) then
				subjectPosition = subjectPosition + cameraRelativeOffset
			end
		elseif not self.userPanningTheCamera and self.lastCameraTransform then
			local isInFirstPerson = self:IsInFirstPerson()
			if (isInVehicle or isOnASkateboard or self.isFollowCamera and isClimbing) and self.lastUpdate and humanoid and humanoid.Torso then
				if isInFirstPerson then
					if self.lastSubjectCFrame and (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
						local y = -Util.GetAngleBetweenXZVectors(self.lastSubjectCFrame.lookVector, cameraSubject.CFrame.lookVector)
						if Util.IsFinite(y) then
							self.rotateInput = self.rotateInput + Vector2.new(y, 0)
						end
						tweenSpeed = 0
					end
				elseif not userRecentlyPannedCamera then
					local forwardVector = humanoid.Torso.CFrame.lookVector
					if isOnASkateboard then
						forwardVector = cameraSubject.CFrame.lookVector
					end
					tweenSpeed = Util.Clamp(0, tweenMaxSpeed, tweenSpeed + tweenAcceleration * timeDelta)
					local percent = Util.Clamp(0, 1, tweenSpeed * timeDelta)
					if self:IsInFirstPerson() and (not self.isFollowCamera or not self.isClimbing) then
						percent = 1
					end
					local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
					if Util.IsFinite(y) and math.abs(y) > 1.0E-4 then
						self.rotateInput = self.rotateInput + Vector2.new(y * percent, 0)
					end
				end
			elseif self.isFollowCamera and not isInFirstPerson and not userRecentlyPannedCamera and not VRService.VREnabled then
				local lastVec = -(self.lastCameraTransform.p - subjectPosition)
				local y = Util.GetAngleBetweenXZVectors(lastVec, self:GetCameraLookVector())
				local thetaCutoff = 0.4
				if Util.IsFinite(y) and math.abs(y) > 1.0E-4 and math.abs(y) > thetaCutoff * timeDelta then
					self.rotateInput = self.rotateInput + Vector2.new(y, 0)
				end
			end
		end
		if not self.isFollowCamera then
			local VREnabled = VRService.VREnabled
			if VREnabled then
				newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
			elseif FFlagUserUpdateCameraConstants then
				newCameraFocus = CFrame.new(subjectPosition)
			else
				newCameraFocus = CFrame.new(subjectPosition + self:GetCameraSubjectOffset())
			end
			local cameraFocusP = newCameraFocus.p
			if VREnabled and not self:IsInFirstPerson() then
				local cameraHeight = self:GetCameraHeight()
				local vecToSubject = subjectPosition - camera.CFrame.p
				local distToSubject = vecToSubject.magnitude
				if zoom < distToSubject or self.rotateInput.x ~= 0 then
					local desiredDist = math.min(distToSubject, zoom)
					vecToSubject = self:CalculateNewLookVectorVR() * desiredDist
					local newPos = cameraFocusP - vecToSubject
					local desiredLookDir = camera.CFrame.lookVector
					if self.rotateInput.x ~= 0 then
						desiredLookDir = vecToSubject
					end
					local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
					self.rotateInput = ZERO_VECTOR2
					newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
				end
			else
				local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
				self.rotateInput = ZERO_VECTOR2
				newCameraCFrame = CFrame.new(cameraFocusP - zoom * newLookVector, cameraFocusP)
			end
		else
			local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
			self.rotateInput = ZERO_VECTOR2
			if VRService.VREnabled then
				newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
			elseif FFlagUserUpdateCameraConstants then
				newCameraFocus = CFrame.new(subjectPosition)
			else
				newCameraFocus = CFrame.new(subjectPosition + self:GetCameraSubjectOffset())
			end
			newCameraCFrame = CFrame.new(newCameraFocus.p - zoom * newLookVector, newCameraFocus.p) + Vector3.new(0, self:GetCameraHeight(), 0)
		end
		self.lastCameraTransform = newCameraCFrame
		self.lastCameraFocus = newCameraFocus
		if (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
			self.lastSubjectCFrame = cameraSubject.CFrame
		else
			self.lastSubjectCFrame = nil
		end
	end
	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end
function ClassicCamera:EnterFirstPerson()
	self.inFirstPerson = true
	self:UpdateMouseBehavior()
end
function ClassicCamera:LeaveFirstPerson()
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
end
return ClassicCamera
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX172"><Properties><string name="Name">CameraUtils</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local CameraUtils = {}
local round = function(num)
	return math.floor(num + 0.5)
end
function CameraUtils.Clamp(low, high, val)
	return math.min(math.max(val, low), high)
end
function CameraUtils.Round(num, places)
	local decimalPivot = 10 ^ places
	return math.floor(num * decimalPivot + 0.5) / decimalPivot
end
function CameraUtils.IsFinite(val)
	return val == val and val ~= math.huge and val ~= -math.huge
end
function CameraUtils.IsFiniteVector3(vec3)
	return CameraUtils.IsFinite(vec3.X) and CameraUtils.IsFinite(vec3.Y) and CameraUtils.IsFinite(vec3.Z)
end
function CameraUtils.GetAngleBetweenXZVectors(v1, v2)
	return math.atan2(v2.X * v1.Z - v2.Z * v1.X, v2.X * v1.X + v2.Z * v1.Z)
end
function CameraUtils.RotateVectorByAngleAndRound(camLook, rotateAngle, roundAmount)
	if camLook.Magnitude > 0 then
		camLook = camLook.unit
		local currAngle = math.atan2(camLook.z, camLook.x)
		local newAngle = round((math.atan2(camLook.z, camLook.x) + rotateAngle) / roundAmount) * roundAmount
		return newAngle - currAngle
	end
	return 0
end
local k = 0.35
local lowerK = 0.8
local function SCurveTranform(t)
	t = CameraUtils.Clamp(-1, 1, t)
	if t >= 0 then
		return k * t / (k - t + 1)
	end
	return -(lowerK * -t / (lowerK + t + 1))
end
local DEADZONE = 0.1
local function toSCurveSpace(t)
	return (1 + DEADZONE) * (2 * math.abs(t) - 1) - DEADZONE
end
local fromSCurveSpace = function(t)
	return t / 2 + 0.5
end
function CameraUtils.GamepadLinearToCurve(thumbstickPosition)
	local function onAxis(axisValue)
		local sign = 1
		if axisValue < 0 then
			sign = -1
		end
		local point = fromSCurveSpace(SCurveTranform(toSCurveSpace(math.abs(axisValue))))
		point = point * sign
		return CameraUtils.Clamp(-1, 1, point)
	end
	return Vector2.new(onAxis(thumbstickPosition.x), onAxis(thumbstickPosition.y))
end
function CameraUtils.ConvertCameraModeEnumToStandard(enumValue)
	if enumValue == Enum.TouchCameraMovementMode.Default then
		return Enum.ComputerCameraMovementMode.Follow
	end
	if enumValue == Enum.ComputerCameraMovementMode.Default then
		return Enum.ComputerCameraMovementMode.Classic
	end
	if enumValue == Enum.TouchCameraMovementMode.Classic or enumValue == Enum.DevTouchCameraMovementMode.Classic or enumValue == Enum.DevComputerCameraMovementMode.Classic or enumValue == Enum.ComputerCameraMovementMode.Classic then
		return Enum.ComputerCameraMovementMode.Classic
	end
	if enumValue == Enum.TouchCameraMovementMode.Follow or enumValue == Enum.DevTouchCameraMovementMode.Follow or enumValue == Enum.DevComputerCameraMovementMode.Follow or enumValue == Enum.ComputerCameraMovementMode.Follow then
		return Enum.ComputerCameraMovementMode.Follow
	end
	if enumValue == Enum.TouchCameraMovementMode.Orbital or enumValue == Enum.DevTouchCameraMovementMode.Orbital or enumValue == Enum.DevComputerCameraMovementMode.Orbital or enumValue == Enum.ComputerCameraMovementMode.Orbital then
		return Enum.ComputerCameraMovementMode.Orbital
	end
	if enumValue == Enum.DevTouchCameraMovementMode.UserChoice or enumValue == Enum.DevComputerCameraMovementMode.UserChoice then
		return Enum.DevComputerCameraMovementMode.UserChoice
	end
	return Enum.ComputerCameraMovementMode.Classic
end
return CameraUtils
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX177"><Properties><string name="Name">BaseOcclusion</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local BaseOcclusion = {}
BaseOcclusion.__index = BaseOcclusion
setmetatable(BaseOcclusion, {
	__call = function(_, ...)
		return BaseOcclusion.new(...)
	end
})
function BaseOcclusion.new()
	local self = setmetatable({}, BaseOcclusion)
	return self
end
function BaseOcclusion:CharacterAdded(char, player)
end
function BaseOcclusion:CharacterRemoving(char, player)
end
function BaseOcclusion:OnCameraSubjectChanged(newSubject)
end
function GetOcclusionMode()
	warn("BaseOcclusion GetOcclusionMode must be overridden by derived classes")
	return nil
end
function BaseOcclusion:Enable(enabled)
	warn("BaseOcclusion Enable must be overridden by derived classes")
end
function BaseOcclusion:Update(dt, desiredCameraCFrame, desiredCameraFocus)
	warn("BaseOcclusion Update must be overridden by derived classes")
	return desiredCameraCFrame, desiredCameraFocus
end
return BaseOcclusion
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX182"><Properties><string name="Name">BaseCamera</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UNIT_Z = Vector3.new(0, 0, 1)
local X1_Y0_Z1 = Vector3.new(1, 0, 1)
local THUMBSTICK_DEADZONE = 0.2
local DEFAULT_DISTANCE = 12.5
local PORTRAIT_DEFAULT_DISTANCE = 25
local FIRST_PERSON_DISTANCE_THRESHOLD = 1
local CAMERA_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
local newCameraConstantsFlagExists, newCameraConstantsFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserUpdateCameraConstants")
end)
local FFlagUserUpdateCameraConstants = newCameraConstantsFlagExists and newCameraConstantsFlagEnabled
local MIN_Y = math.rad(-80)
local MAX_Y = math.rad(80)
local VR_ANGLE = math.rad(15)
local VR_LOW_INTENSITY_ROTATION = Vector2.new(math.rad(15), 0)
local VR_HIGH_INTENSITY_ROTATION = Vector2.new(math.rad(45), 0)
local VR_LOW_INTENSITY_REPEAT = 0.1
local VR_HIGH_INTENSITY_REPEAT = 0.4
local ZERO_VECTOR2 = Vector2.new(0, 0)
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local TOUCH_SENSITIVTY = Vector2.new(0.002 * math.pi, 0.0015 * math.pi)
if FFlagUserUpdateCameraConstants then
	TOUCH_SENSITIVTY = Vector2.new(0.0045 * math.pi, 0.003375 * math.pi)
end
local MOUSE_SENSITIVITY = Vector2.new(0.002 * math.pi, 0.0015 * math.pi)
local MAX_TIME_FOR_DOUBLE_TAP = 1.5
local MAX_TAP_POS_DELTA = 15
local MAX_TAP_TIME_DELTA = 0.75
local SEAT_OFFSET = Vector3.new(0, 5, 0)
local VR_SEAT_OFFSET = Vector3.new(0, 4, 0)
local HEAD_OFFSET = Vector3.new(0, 1.5, 0)
local R15_HEAD_OFFSET = Vector3.new(0, 2, 0)
local R15_HEAD_OFFSET_NO_SCALING = Vector3.new(0, 2, 0)
local HUMANOID_ROOT_PART_SIZE = Vector3.new(2, 2, 1)
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local adjustHumanoidRootPartFlagExists, adjustHumanoidRootPartFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserAdjustHumanoidRootPartToHipPosition")
end)
local FFlagUserAdjustHumanoidRootPartToHipPosition = adjustHumanoidRootPartFlagExists and adjustHumanoidRootPartFlagEnabled
if FFlagUserAdjustHumanoidRootPartToHipPosition then
	R15_HEAD_OFFSET = Vector3.new(0, 1.5, 0)
end
local noDynamicThumbstickRecenterFlagExists, noDynamicThumbstickRecenterFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNoDynamicThumbstickRecenter")
end)
local FFlagUserNoDynamicThumbstickRecenter = noDynamicThumbstickRecenterFlagExists and noDynamicThumbstickRecenterFlagEnabled
local thumbstickUseCASFlagSuccess, thumbstickUseCASFlagValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserDynamicThumbstickUseContextActionSevice")
end)
local FFlagDynamicThumbstickUseContextActionSevice = thumbstickUseCASFlagSuccess and thumbstickUseCASFlagValue
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local ZoomController = require(script.Parent:WaitForChild("ZoomController"))
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local GuiService = game:GetService("GuiService")
local ContextActionService = game:GetService("ContextActionService")
local VRService = game:GetService("VRService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local BaseCamera = {}
BaseCamera.__index = BaseCamera
function BaseCamera.new()
	local self = setmetatable({}, BaseCamera)
	self.FIRST_PERSON_DISTANCE_THRESHOLD = FIRST_PERSON_DISTANCE_THRESHOLD
	self.cameraType = nil
	self.cameraMovementMode = nil
	local player = Players.LocalPlayer
	self.lastCameraTransform = nil
	self.rotateInput = ZERO_VECTOR2
	self.userPanningCamera = false
	self.lastUserPanCamera = tick()
	self.humanoidRootPart = nil
	self.humanoidCache = {}
	self.lastSubject = nil
	self.lastSubjectPosition = Vector3.new(0, 5, 0)
	self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)
	self.currentSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)
	self.inFirstPerson = false
	self.inMouseLockedMode = false
	self.portraitMode = false
	self.isSmallTouchScreen = false
	self.resetCameraAngle = true
	self.enabled = false
	self.inputBeganConn = nil
	self.inputChangedConn = nil
	self.inputEndedConn = nil
	self.startPos = nil
	self.lastPos = nil
	self.panBeginLook = nil
	self.panEnabled = true
	self.keyPanEnabled = true
	self.distanceChangeEnabled = true
	self.PlayerGui = nil
	self.cameraChangedConn = nil
	self.viewportSizeChangedConn = nil
	self.boundContextActions = {}
	self.shouldUseVRRotation = false
	self.VRRotationIntensityAvailable = false
	self.lastVRRotationIntensityCheckTime = 0
	self.lastVRRotationTime = 0
	self.vrRotateKeyCooldown = {}
	self.cameraTranslationConstraints = Vector3.new(1, 1, 1)
	self.humanoidJumpOrigin = nil
	self.trackingHumanoid = nil
	self.cameraFrozen = false
	self.subjectStateChangedConn = nil
	self.activeGamepad = nil
	self.gamepadPanningCamera = false
	self.lastThumbstickRotate = nil
	self.numOfSeconds = 0.7
	self.currentSpeed = 0
	self.maxSpeed = 6
	self.vrMaxSpeed = 4
	self.lastThumbstickPos = Vector2.new(0, 0)
	self.ySensitivity = 0.65
	self.lastVelocity = nil
	self.gamepadConnectedConn = nil
	self.gamepadDisconnectedConn = nil
	self.currentZoomSpeed = 1
	self.L3ButtonDown = false
	self.dpadLeftDown = false
	self.dpadRightDown = false
	self.isDynamicThumbstickEnabled = false
	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	self.inputStartPositions = {}
	self.inputStartTimes = {}
	self.startingDiff = nil
	self.pinchBeginZoom = nil
	self.userPanningTheCamera = false
	self.touchActivateConn = nil
	self.mouseLockOffset = ZERO_VECTOR3
	if player.Character then
		self:OnCharacterAdded(player.Character)
	end
	player.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char)
	end)
	if self.cameraChangedConn then
		self.cameraChangedConn:Disconnect()
	end
	self.cameraChangedConn = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		self:OnCurrentCameraChanged()
	end)
	self:OnCurrentCameraChanged()
	if self.playerCameraModeChangeConn then
		self.playerCameraModeChangeConn:Disconnect()
	end
	self.playerCameraModeChangeConn = player:GetPropertyChangedSignal("CameraMode"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)
	if self.minDistanceChangeConn then
		self.minDistanceChangeConn:Disconnect()
	end
	self.minDistanceChangeConn = player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)
	if self.maxDistanceChangeConn then
		self.maxDistanceChangeConn:Disconnect()
	end
	self.maxDistanceChangeConn = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)
	if self.playerDevTouchMoveModeChangeConn then
		self.playerDevTouchMoveModeChangeConn:Disconnect()
	end
	self.playerDevTouchMoveModeChangeConn = player:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
		self:OnDevTouchMovementModeChanged()
	end)
	self:OnDevTouchMovementModeChanged()
	if self.gameSettingsTouchMoveMoveChangeConn then
		self.gameSettingsTouchMoveMoveChangeConn:Disconnect()
	end
	self.gameSettingsTouchMoveMoveChangeConn = UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
		self:OnGameSettingsTouchMovementModeChanged()
	end)
	self:OnGameSettingsTouchMovementModeChanged()
	UserGameSettings:SetCameraYInvertVisible()
	UserGameSettings:SetGamepadCameraSensitivityVisible()
	self.hasGameLoaded = game:IsLoaded()
	if not self.hasGameLoaded then
		self.gameLoadedConn = game.Loaded:Connect(function()
			self.hasGameLoaded = true
			self.gameLoadedConn:Disconnect()
			self.gameLoadedConn = nil
		end)
	end
	return self
end
function BaseCamera:GetModuleName()
	return "BaseCamera"
end
function BaseCamera:OnCharacterAdded(char)
	self.resetCameraAngle = self.resetCameraAngle or self:GetEnabled()
	self.humanoidRootPart = nil
	if UserInputService.TouchEnabled then
		self.PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
		for _, child in ipairs(char:GetChildren()) do
			if child:IsA("Tool") then
				self.isAToolEquipped = true
			end
		end
		char.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				self.isAToolEquipped = true
			end
		end)
		char.ChildRemoved:Connect(function(child)
			if child:IsA("Tool") then
				self.isAToolEquipped = false
			end
		end)
	end
end
function BaseCamera:GetHumanoidRootPart()
	if not self.humanoidRootPart then
		local player = Players.LocalPlayer
		if player.Character then
			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				self.humanoidRootPart = humanoid.RootPart
			end
		end
	end
	return self.humanoidRootPart
end
function BaseCamera:GetBodyPartToFollow(humanoid, isDead)
	if humanoid:GetState() == Enum.HumanoidStateType.Dead then
		local character = humanoid.Parent
		if character and character:IsA("Model") then
			return character:FindFirstChild("Head") or humanoid.RootPart
		end
	end
	return humanoid.RootPart
end
function BaseCamera:GetSubjectPosition()
	local result = self.lastSubjectPosition
	local camera = game.Workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject
	if cameraSubject then
		if cameraSubject:IsA("Humanoid") then
			local humanoid = cameraSubject
			local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead
			if VRService.VREnabled and humanoidIsDead and humanoid == self.lastSubject then
				result = self.lastSubjectPosition
			else
				local bodyPartToFollow = humanoid.RootPart
				bodyPartToFollow = humanoidIsDead and humanoid.Parent and humanoid.Parent:IsA("Model") and humanoid.Parent:FindFirstChild("Head") or bodyPartToFollow
				if bodyPartToFollow and bodyPartToFollow:IsA("BasePart") then
					local heightOffset
					if FFlagUserAdjustHumanoidRootPartToHipPosition then
						if humanoid.RigType == Enum.HumanoidRigType.R15 then
							if humanoid.AutomaticScalingEnabled then
								heightOffset = R15_HEAD_OFFSET
								if bodyPartToFollow == humanoid.RootPart then
									local rootPartSizeOffset = humanoid.RootPart.Size.Y / 2 - HUMANOID_ROOT_PART_SIZE.Y / 2
									heightOffset = heightOffset + Vector3.new(0, rootPartSizeOffset, 0)
								end
							else
								heightOffset = R15_HEAD_OFFSET_NO_SCALING
							end
						else
							heightOffset = HEAD_OFFSET
						end
					else
						heightOffset = humanoid.RigType == Enum.HumanoidRigType.R15 and R15_HEAD_OFFSET or HEAD_OFFSET
					end
					if humanoidIsDead then
						heightOffset = ZERO_VECTOR3
					end
					result = bodyPartToFollow.CFrame.p + bodyPartToFollow.CFrame:vectorToWorldSpace(heightOffset + humanoid.CameraOffset)
				end
			end
		elseif cameraSubject:IsA("VehicleSeat") then
			local offset = SEAT_OFFSET
			if VRService.VREnabled then
				offset = VR_SEAT_OFFSET
			end
			result = cameraSubject.CFrame.p + cameraSubject.CFrame:vectorToWorldSpace(offset)
		elseif cameraSubject:IsA("SkateboardPlatform") then
			result = cameraSubject.CFrame.p + SEAT_OFFSET
		elseif cameraSubject:IsA("BasePart") then
			result = cameraSubject.CFrame.p
		elseif cameraSubject:IsA("Model") then
			if cameraSubject.PrimaryPart then
				result = cameraSubject:GetPrimaryPartCFrame().p
			else
				result = cameraSubject:GetModelCFrame().p
			end
		end
	else
		return
	end
	self.lastSubject = cameraSubject
	self.lastSubjectPosition = result
	return result
end
function BaseCamera:UpdateDefaultSubjectDistance()
	local player = Players.LocalPlayer
	if self.portraitMode then
		self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, PORTRAIT_DEFAULT_DISTANCE)
	else
		self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)
	end
end
function BaseCamera:OnViewportSizeChanged()
	local camera = game.Workspace.CurrentCamera
	local size = camera.ViewportSize
	self.portraitMode = size.X < size.Y
	self.isSmallTouchScreen = UserInputService.TouchEnabled and (size.Y < 500 or size.X < 700)
	self:UpdateDefaultSubjectDistance()
end
function BaseCamera:OnCurrentCameraChanged()
	if UserInputService.TouchEnabled then
		if self.viewportSizeChangedConn then
			self.viewportSizeChangedConn:Disconnect()
			self.viewportSizeChangedConn = nil
		end
		local newCamera = game.Workspace.CurrentCamera
		if newCamera then
			self:OnViewportSizeChanged()
			self.viewportSizeChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
				self:OnViewportSizeChanged()
			end)
		end
	end
	if self.cameraSubjectChangedConn then
		self.cameraSubjectChangedConn:Disconnect()
		self.cameraSubjectChangedConn = nil
	end
	local camera = game.Workspace.CurrentCamera
	if camera then
		self.cameraSubjectChangedConn = camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
			self:OnNewCameraSubject()
		end)
		self:OnNewCameraSubject()
	end
end
function BaseCamera:OnDynamicThumbstickEnabled()
	if UserInputService.TouchEnabled then
		self.isDynamicThumbstickEnabled = true
	end
end
function BaseCamera:OnDynamicThumbstickDisabled()
	self.isDynamicThumbstickEnabled = false
end
function BaseCamera:OnGameSettingsTouchMovementModeChanged()
	if Players.LocalPlayer.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice then
		if FFlagUserNoDynamicThumbstickRecenter then
			if UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.DynamicThumbstick or UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.Default then
				self:OnDynamicThumbstickEnabled()
			else
				self:OnDynamicThumbstickDisabled()
			end
		elseif UserGameSettings.TouchMovementMode.Name == "DynamicThumbstick" then
			self:OnDynamicThumbstickEnabled()
		else
			self:OnDynamicThumbstickDisabled()
		end
	end
end
function BaseCamera:OnDevTouchMovementModeChanged()
	if Players.LocalPlayer.DevTouchMovementMode.Name == "DynamicThumbstick" then
		self:OnDynamicThumbstickEnabled()
	else
		self:OnGameSettingsTouchMovementModeChanged()
	end
end
function BaseCamera:OnPlayerCameraPropertyChange()
	self:SetCameraToSubjectDistance(self.currentSubjectDistance)
end
function BaseCamera:GetCameraHeight()
	if VRService.VREnabled and not self.inFirstPerson then
		return math.sin(VR_ANGLE) * self.currentSubjectDistance
	end
	return 0
end
function BaseCamera:InputTranslationToCameraAngleChange(translationVector, sensitivity)
	local camera = game.Workspace.CurrentCamera
	if camera and camera.ViewportSize.X > 0 and 0 < camera.ViewportSize.Y and camera.ViewportSize.Y > camera.ViewportSize.X then
		return translationVector * Vector2.new(sensitivity.Y, sensitivity.X)
	end
	return translationVector * sensitivity
end
function BaseCamera:Enable(enable)
	if self.enabled ~= enable then
		self.enabled = enable
		if self.enabled then
			self:ConnectInputEvents()
			if FFlagPlayerScriptsBindAtPriority2 then
				self:BindContextActions()
			end
			if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
				self.currentSubjectDistance = 0.5
				if not self.inFirstPerson then
					self:EnterFirstPerson()
				end
			end
		else
			self:DisconnectInputEvents()
			if FFlagPlayerScriptsBindAtPriority2 then
				self:UnbindContextActions()
			end
			self:Cleanup()
		end
	end
end
function BaseCamera:GetEnabled()
	return self.enabled
end
function BaseCamera:OnInputBegan(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchBegan(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		self:OnMouse2Down(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
		self:OnMouse3Down(input, processed)
	end
	if not FFlagPlayerScriptsBindAtPriority2 and input.UserInputType == Enum.UserInputType.Keyboard then
		self:OnKeyDown(input, processed)
	end
end
function BaseCamera:OnInputChanged(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchChanged(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseMovement then
		self:OnMouseMoved(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseWheel then
		self:OnMouseWheel(input, processed)
	end
end
function BaseCamera:OnInputEnded(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchEnded(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		self:OnMouse2Up(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
		self:OnMouse3Up(input, processed)
	end
	if not FFlagPlayerScriptsBindAtPriority2 and input.UserInputType == Enum.UserInputType.Keyboard then
		self:OnKeyUp(input, processed)
	end
end
function BaseCamera:ConnectInputEvents()
	self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
		self:OnInputBegan(input, processed)
	end)
	self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
		self:OnInputChanged(input, processed)
	end)
	self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
		self:OnInputEnded(input, processed)
	end)
	if not FFlagUserNoDynamicThumbstickRecenter then
		self.touchActivateConn = UserInputService.TouchTapInWorld:Connect(function(touchPos, processed)
			self:OnTouchTap(touchPos)
		end)
	end
	self.menuOpenedConn = GuiService.MenuOpened:connect(function()
		self:ResetInputStates()
	end)
	self.gamepadConnectedConn = UserInputService.GamepadDisconnected:connect(function(gamepadEnum)
		if self.activeGamepad ~= gamepadEnum then
			return
		end
		self.activeGamepad = nil
		self:AssignActivateGamepad()
	end)
	self.gamepadDisconnectedConn = UserInputService.GamepadConnected:connect(function(gamepadEnum)
		if self.activeGamepad == nil then
			self:AssignActivateGamepad()
		end
	end)
	if not FFlagPlayerScriptsBindAtPriority2 then
		self:BindGamepadInputActions()
	end
	self:AssignActivateGamepad()
	self:UpdateMouseBehavior()
end
function BaseCamera:BindContextActions()
	self:BindGamepadInputActions()
	self:BindKeyboardInputActions()
end
function BaseCamera:AssignActivateGamepad()
	local connectedGamepads = UserInputService:GetConnectedGamepads()
	if #connectedGamepads > 0 then
		for i = 1, #connectedGamepads do
			if self.activeGamepad == nil then
				self.activeGamepad = connectedGamepads[i]
			elseif connectedGamepads[i].Value < self.activeGamepad.Value then
				self.activeGamepad = connectedGamepads[i]
			end
		end
	end
	if self.activeGamepad == nil then
		self.activeGamepad = Enum.UserInputType.Gamepad1
	end
end
function BaseCamera:DisconnectInputEvents()
	if self.inputBeganConn then
		self.inputBeganConn:Disconnect()
		self.inputBeganConn = nil
	end
	if self.inputChangedConn then
		self.inputChangedConn:Disconnect()
		self.inputChangedConn = nil
	end
	if self.inputEndedConn then
		self.inputEndedConn:Disconnect()
		self.inputEndedConn = nil
	end
end
function BaseCamera:UnbindContextActions()
	for i = 1, #self.boundContextActions do
		ContextActionService:UnbindAction(self.boundContextActions[i])
	end
	self.boundContextActions = {}
end
function BaseCamera:Cleanup()
	if self.menuOpenedConn then
		self.menuOpenedConn:Disconnect()
		self.menuOpenedConn = nil
	end
	if self.mouseLockToggleConn then
		self.mouseLockToggleConn:Disconnect()
		self.mouseLockToggleConn = nil
	end
	if self.gamepadConnectedConn then
		self.gamepadConnectedConn:Disconnect()
		self.gamepadConnectedConn = nil
	end
	if self.gamepadDisconnectedConn then
		self.gamepadDisconnectedConn:Disconnect()
		self.gamepadDisconnectedConn = nil
	end
	if self.subjectStateChangedConn then
		self.subjectStateChangedConn:Disconnect()
		self.subjectStateChangedConn = nil
	end
	if self.viewportSizeChangedConn then
		self.viewportSizeChangedConn:Disconnect()
		self.viewportSizeChangedConn = nil
	end
	if self.touchActivateConn then
		self.touchActivateConn:Disconnect()
		self.touchActivateConn = nil
	end
	self.turningLeft = false
	self.turningRight = false
	self.lastCameraTransform = nil
	self.lastSubjectCFrame = nil
	self.userPanningTheCamera = false
	self.rotateInput = Vector2.new()
	self.gamepadPanningCamera = Vector2.new(0, 0)
	self.startPos = nil
	self.lastPos = nil
	self.panBeginLook = nil
	self.isRightMouseDown = false
	self.isMiddleMouseDown = false
	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	self.startingDiff = nil
	self.pinchBeginZoom = nil
	if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end
function BaseCamera:ResetInputStates()
	self.isRightMouseDown = false
	self.isMiddleMouseDown = false
	self:OnMousePanButtonReleased()
	if UserInputService.TouchEnabled then
		for inputObject in pairs(self.fingerTouches) do
			self.fingerTouches[inputObject] = nil
		end
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
		self.startingDiff = nil
		self.pinchBeginZoom = nil
		self.numUnsunkTouches = 0
	end
end
function BaseCamera:GetGamepadPan(name, state, input)
	if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
		if state == Enum.UserInputState.Cancel then
			self.gamepadPanningCamera = ZERO_VECTOR2
			return
		end
		local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
		if inputVector.magnitude > THUMBSTICK_DEADZONE then
			self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
		else
			self.gamepadPanningCamera = ZERO_VECTOR2
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function BaseCamera:DoKeyboardPanTurn(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end
	if state == Enum.UserInputState.Cancel then
		self.turningLeft = false
		self.turningRight = false
		return Enum.ContextActionResult.Sink
	end
	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Left then
			self.turningLeft = state == Enum.UserInputState.Begin
		elseif input.KeyCode == Enum.KeyCode.Right then
			self.turningRight = state == Enum.UserInputState.Begin
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function BaseCamera:DoPanRotateCamera(rotateAngle)
	local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1, 0, 1), rotateAngle, math.pi * 0.25)
	if angle ~= 0 then
		self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
		self.lastUserPanCamera = tick()
		self.lastCameraTransform = nil
	end
end
function BaseCamera:DoKeyboardPan(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end
	if state ~= Enum.UserInputState.Begin then
		return Enum.ContextActionResult.Pass
	end
	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Comma then
			self:DoPanRotateCamera(-math.pi * 0.1875)
		elseif input.KeyCode == Enum.KeyCode.Period then
			self:DoPanRotateCamera(math.pi * 0.1875)
		elseif input.KeyCode == Enum.KeyCode.PageUp then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(15))
			self.lastCameraTransform = nil
		elseif input.KeyCode == Enum.KeyCode.PageDown then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(-15))
			self.lastCameraTransform = nil
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function BaseCamera:DoGamepadZoom(name, state, input)
	if input.UserInputType == self.activeGamepad then
		if input.KeyCode == Enum.KeyCode.ButtonR3 then
			if state == Enum.UserInputState.Begin and self.distanceChangeEnabled then
				if self:GetCameraToSubjectDistance() > 0.5 then
					self:SetCameraToSubjectDistance(0)
				else
					self:SetCameraToSubjectDistance(10)
				end
			end
		elseif input.KeyCode == Enum.KeyCode.DPadLeft then
			self.dpadLeftDown = state == Enum.UserInputState.Begin
		elseif input.KeyCode == Enum.KeyCode.DPadRight then
			self.dpadRightDown = state == Enum.UserInputState.Begin
		end
		if self.dpadLeftDown then
			self.currentZoomSpeed = 1.04
		elseif self.dpadRightDown then
			self.currentZoomSpeed = 0.96
		else
			self.currentZoomSpeed = 1
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function BaseCamera:DoKeyboardZoom(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end
	if state ~= Enum.UserInputState.Begin then
		return Enum.ContextActionResult.Pass
	end
	if self.distanceChangeEnabled and Players.LocalPlayer.CameraMode ~= Enum.CameraMode.LockFirstPerson then
		if input.KeyCode == Enum.KeyCode.I then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance - 5)
		elseif input.KeyCode == Enum.KeyCode.O then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance + 5)
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function BaseCamera:BindAction(actionName, actionFunc, createTouchButton, ...)
	table.insert(self.boundContextActions, actionName)
	ContextActionService:BindActionAtPriority(actionName, actionFunc, createTouchButton, CAMERA_ACTION_PRIORITY, ...)
end
function BaseCamera:BindGamepadInputActions()
	if FFlagPlayerScriptsBindAtPriority2 then
		self:BindAction("BaseCameraGamepadPan", function(name, state, input)
			return self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		self:BindAction("BaseCameraGamepadZoom", function(name, state, input)
			return self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.DPadLeft, Enum.KeyCode.DPadRight, Enum.KeyCode.ButtonR3)
	else
		ContextActionService:BindAction("RootCamGamepadPan", function(name, state, input)
			self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		ContextActionService:BindAction("RootCamGamepadZoom", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonR3)
		ContextActionService:BindAction("RootGamepadZoomOut", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.DPadLeft)
		ContextActionService:BindAction("RootGamepadZoomIn", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.DPadRight)
	end
end
function BaseCamera:BindKeyboardInputActions()
	self:BindAction("BaseCameraKeyboardPanArrowKeys", function(name, state, input)
		return self:DoKeyboardPanTurn(name, state, input)
	end, false, Enum.KeyCode.Left, Enum.KeyCode.Right)
	self:BindAction("BaseCameraKeyboardPan", function(name, state, input)
		return self:DoKeyboardPan(name, state, input)
	end, false, Enum.KeyCode.Comma, Enum.KeyCode.Period, Enum.KeyCode.PageUp, Enum.KeyCode.PageDown)
	self:BindAction("BaseCameraKeyboardZoom", function(name, state, input)
		return self:DoKeyboardZoom(name, state, input)
	end, false, Enum.KeyCode.I, Enum.KeyCode.O)
end
function BaseCamera:OnTouchBegan(input, processed)
	local canUseDynamicTouch = self.isDynamicThumbstickEnabled and not processed
	if canUseDynamicTouch then
		self.fingerTouches[input] = processed
		if not processed then
			self.inputStartPositions[input] = input.Position
			self.inputStartTimes[input] = tick()
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
end
function BaseCamera:OnTouchChanged(input, processed)
	if self.fingerTouches[input] == nil then
		if self.isDynamicThumbstickEnabled then
			return
		end
		self.fingerTouches[input] = processed
		if not processed then
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	elseif FFlagDynamicThumbstickUseContextActionSevice and self.isDynamicThumbstickEnabled and self.fingerTouches[input] ~= processed then
		self.fingerTouches[input] = processed
		if processed then
			self.numUnsunkTouches = self.numUnsunkTouches - 1
		else
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
	if self.numUnsunkTouches == 1 then
		if self.fingerTouches[input] == false then
			self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
			self.startPos = self.startPos or input.Position
			self.lastPos = self.lastPos or self.startPos
			self.userPanningTheCamera = true
			local delta = input.Position - self.lastPos
			delta = Vector2.new(delta.X, delta.Y * UserGameSettings:GetCameraYInvertValue())
			if self.panEnabled then
				local desiredXYVector = self:InputTranslationToCameraAngleChange(delta, TOUCH_SENSITIVTY)
				self.rotateInput = self.rotateInput + desiredXYVector
			end
			self.lastPos = input.Position
		end
	else
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
	end
	if self.numUnsunkTouches == 2 then
		local unsunkTouches = {}
		for touch, wasSunk in pairs(self.fingerTouches) do
			if not wasSunk then
				table.insert(unsunkTouches, touch)
			end
		end
		if #unsunkTouches == 2 then
			local difference = (unsunkTouches[1].Position - unsunkTouches[2].Position).magnitude
			if self.startingDiff and self.pinchBeginZoom then
				local scale = difference / math.max(0.01, self.startingDiff)
				local clampedScale = Util.Clamp(0.1, 10, scale)
				if self.distanceChangeEnabled then
					self:SetCameraToSubjectDistance(self.pinchBeginZoom / clampedScale)
				end
			else
				self.startingDiff = difference
				self.pinchBeginZoom = self:GetCameraToSubjectDistance()
			end
		end
	else
		self.startingDiff = nil
		self.pinchBeginZoom = nil
	end
end
function BaseCamera:CalcLookBehindRotateInput()
	if not self.humanoidRootPart or not game.Workspace.CurrentCamera then
		return nil
	end
	local cameraLookVector = game.Workspace.CurrentCamera.CFrame.lookVector
	local newDesiredLook = (self.humanoidRootPart.CFrame.lookVector - Vector3.new(0, 0.23, 0)).unit
	local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, cameraLookVector)
	local vertShift = math.asin(cameraLookVector.Y) - math.asin(newDesiredLook.Y)
	if not Util.IsFinite(horizontalShift) then
		horizontalShift = 0
	end
	if not Util.IsFinite(vertShift) then
		vertShift = 0
	end
	return Vector2.new(horizontalShift, vertShift)
end
function BaseCamera:OnTouchTap(position)
	if self.isDynamicThumbstickEnabled and not self.isAToolEquipped then
		if self.lastTapTime and tick() - self.lastTapTime < MAX_TIME_FOR_DOUBLE_TAP then
			self:SetCameraToSubjectDistance(self.defaultSubjectDistance)
		elseif self.humanoidRootPart then
			self.rotateInput = self:CalcLookBehindRotateInput()
		end
		self.lastTapTime = tick()
	end
end
function BaseCamera:IsTouchTap(input)
	if self.inputStartPositions[input] then
		local posDelta = (self.inputStartPositions[input] - input.Position).magnitude
		if posDelta < MAX_TAP_POS_DELTA then
			local timeDelta = self.inputStartTimes[input] - tick()
			if timeDelta < MAX_TAP_TIME_DELTA then
				return true
			end
		end
	end
	return false
end
function BaseCamera:OnTouchEnded(input, processed)
	if self.fingerTouches[input] == false then
		if self.numUnsunkTouches == 1 then
			self.panBeginLook = nil
			self.startPos = nil
			self.lastPos = nil
			self.userPanningTheCamera = false
			if not FFlagUserNoDynamicThumbstickRecenter and self:IsTouchTap(input) then
				self:OnTouchTap(input.Position)
			end
		elseif self.numUnsunkTouches == 2 then
			self.startingDiff = nil
			self.pinchBeginZoom = nil
		end
	end
	if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
		self.numUnsunkTouches = self.numUnsunkTouches - 1
	end
	self.fingerTouches[input] = nil
	self.inputStartPositions[input] = nil
	self.inputStartTimes[input] = nil
end
function BaseCamera:OnMouse2Down(input, processed)
	if processed then
		return
	end
	self.isRightMouseDown = true
	self:OnMousePanButtonPressed(input, processed)
end
function BaseCamera:OnMouse2Up(input, processed)
	self.isRightMouseDown = false
	self:OnMousePanButtonReleased(input, processed)
end
function BaseCamera:OnMouse3Down(input, processed)
	if processed then
		return
	end
	self.isMiddleMouseDown = true
	self:OnMousePanButtonPressed(input, processed)
end
function BaseCamera:OnMouse3Up(input, processed)
	self.isMiddleMouseDown = false
	self:OnMousePanButtonReleased(input, processed)
end
function BaseCamera:OnMouseMoved(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end
	local inputDelta = input.Delta
	inputDelta = Vector2.new(inputDelta.X, inputDelta.Y * UserGameSettings:GetCameraYInvertValue())
	if self.panEnabled and (self.startPos and self.lastPos and self.panBeginLook or self.inFirstPerson or self.inMouseLockedMode) then
		local desiredXYVector = self:InputTranslationToCameraAngleChange(inputDelta, MOUSE_SENSITIVITY)
		self.rotateInput = self.rotateInput + desiredXYVector
	end
	if self.startPos and self.lastPos and self.panBeginLook then
		self.lastPos = self.lastPos + input.Delta
	end
end
function BaseCamera:OnMousePanButtonPressed(input, processed)
	if processed then
		return
	end
	self:UpdateMouseBehavior()
	self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
	self.startPos = self.startPos or input.Position
	self.lastPos = self.lastPos or self.startPos
	self.userPanningTheCamera = true
end
function BaseCamera:OnMousePanButtonReleased(input, processed)
	self:UpdateMouseBehavior()
	if not self.isRightMouseDown and not self.isMiddleMouseDown then
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
	end
end
function BaseCamera:OnMouseWheel(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end
	if not processed and self.distanceChangeEnabled then
		local wheelInput = Util.Clamp(-1, 1, -input.Position.Z)
		local newDistance
		if self.inFirstPerson and wheelInput > 0 then
			newDistance = FIRST_PERSON_DISTANCE_THRESHOLD
		else
			newDistance = self.currentSubjectDistance + 0.156 * self.currentSubjectDistance * wheelInput + 1.7 * math.sign(wheelInput)
		end
		self:SetCameraToSubjectDistance(newDistance)
	end
end
function BaseCamera:OnKeyDown(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end
	if processed then
		return
	end
	if self.distanceChangeEnabled then
		if input.KeyCode == Enum.KeyCode.I then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance - 5)
		elseif input.KeyCode == Enum.KeyCode.O then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance + 5)
		end
	end
	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Left then
			self.turningLeft = true
		elseif input.KeyCode == Enum.KeyCode.Right then
			self.turningRight = true
		elseif input.KeyCode == Enum.KeyCode.Comma then
			local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1, 0, 1), -math.pi * 0.1875, math.pi * 0.25)
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
				self.lastUserPanCamera = tick()
				self.lastCameraTransform = nil
			end
		elseif input.KeyCode == Enum.KeyCode.Period then
			local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1, 0, 1), math.pi * 0.1875, math.pi * 0.25)
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
				self.lastUserPanCamera = tick()
				self.lastCameraTransform = nil
			end
		elseif input.KeyCode == Enum.KeyCode.PageUp then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(15))
			self.lastCameraTransform = nil
		elseif input.KeyCode == Enum.KeyCode.PageDown then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(-15))
			self.lastCameraTransform = nil
		end
	end
end
function BaseCamera:OnKeyUp(input, processed)
	if input.KeyCode == Enum.KeyCode.Left then
		self.turningLeft = false
	elseif input.KeyCode == Enum.KeyCode.Right then
		self.turningRight = false
	end
end
function BaseCamera:UpdateMouseBehavior()
	if self.inFirstPerson or self.inMouseLockedMode then
		UserGameSettings.RotationType = Enum.RotationType.CameraRelative
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	else
		UserGameSettings.RotationType = Enum.RotationType.MovementRelative
		if self.isRightMouseDown or self.isMiddleMouseDown then
			UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		else
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	end
end
function BaseCamera:UpdateForDistancePropertyChange()
	self:SetCameraToSubjectDistance(self.currentSubjectDistance)
end
function BaseCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	local player = Players.LocalPlayer
	local lastSubjectDistance = self.currentSubjectDistance
	if player.CameraMode == Enum.CameraMode.LockFirstPerson then
		self.currentSubjectDistance = 0.5
		if not self.inFirstPerson then
			self:EnterFirstPerson()
		end
	else
		local newSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, desiredSubjectDistance)
		if newSubjectDistance < FIRST_PERSON_DISTANCE_THRESHOLD then
			self.currentSubjectDistance = 0.5
			if not self.inFirstPerson then
				self:EnterFirstPerson()
			end
		else
			self.currentSubjectDistance = newSubjectDistance
			if self.inFirstPerson then
				self:LeaveFirstPerson()
			end
		end
	end
	ZoomController.SetZoomParameters(self.currentSubjectDistance, math.sign(desiredSubjectDistance - lastSubjectDistance))
	return self.currentSubjectDistance
end
function BaseCamera:SetCameraType(cameraType)
	self.cameraType = cameraType
end
function BaseCamera:GetCameraType()
	return self.cameraType
end
function BaseCamera:SetCameraMovementMode(cameraMovementMode)
	self.cameraMovementMode = cameraMovementMode
end
function BaseCamera:GetCameraMovementMode()
	return self.cameraMovementMode
end
function BaseCamera:SetIsMouseLocked(mouseLocked)
	self.inMouseLockedMode = mouseLocked
	self:UpdateMouseBehavior()
end
function BaseCamera:GetIsMouseLocked()
	return self.inMouseLockedMode
end
function BaseCamera:SetMouseLockOffset(offsetVector)
	self.mouseLockOffset = offsetVector
end
function BaseCamera:GetMouseLockOffset()
	return self.mouseLockOffset
end
function BaseCamera:InFirstPerson()
	return self.inFirstPerson
end
function BaseCamera:EnterFirstPerson()
end
function BaseCamera:LeaveFirstPerson()
end
function BaseCamera:GetCameraToSubjectDistance()
	return self.currentSubjectDistance
end
function BaseCamera:GetMeasuredDistanceToFocus()
	local camera = game.Workspace.CurrentCamera
	if camera then
		return (camera.CoordinateFrame.p - camera.Focus.p).magnitude
	end
	return nil
end
function BaseCamera:GetCameraLookVector()
	return game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame.lookVector or UNIT_Z
end
function BaseCamera:CalculateNewLookCFrame(suppliedLookVector)
	local currLookVector = suppliedLookVector or self:GetCameraLookVector()
	local currPitchAngle = math.asin(currLookVector.y)
	local yTheta = Util.Clamp(-MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle, self.rotateInput.y)
	local constrainedRotateInput = Vector2.new(self.rotateInput.x, yTheta)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y, 0, 0)
	return newLookCFrame
end
function BaseCamera:CalculateNewLookVector(suppliedLookVector)
	local newLookCFrame = self:CalculateNewLookCFrame(suppliedLookVector)
	return newLookCFrame.lookVector
end
function BaseCamera:CalculateNewLookVectorVR()
	local subjectPosition = self:GetSubjectPosition()
	local vecToSubject = subjectPosition - game.Workspace.CurrentCamera.CFrame.p
	local currLookVector = (vecToSubject * X1_Y0_Z1).unit
	local vrRotateInput = Vector2.new(self.rotateInput.x, 0)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local yawRotatedVector = (CFrame.Angles(0, -vrRotateInput.x, 0) * startCFrame * CFrame.Angles(-vrRotateInput.y, 0, 0)).lookVector
	return (yawRotatedVector * X1_Y0_Z1).unit
end
function BaseCamera:GetHumanoid()
	local player = Players.LocalPlayer
	local character = player and player.Character
	if character then
		local resultHumanoid = self.humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			self.humanoidCache[player] = nil
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				self.humanoidCache[player] = humanoid
			end
			return humanoid
		end
	end
	return nil
end
function BaseCamera:GetHumanoidPartToFollow(humanoid, humanoidStateType)
	if humanoidStateType == Enum.HumanoidStateType.Dead then
		local character = humanoid.Parent
		if character then
			return character:FindFirstChild("Head") or humanoid.Torso
		else
			return humanoid.Torso
		end
	else
		return humanoid.Torso
	end
end
function BaseCamera:UpdateGamepad()
	local gamepadPan = self.gamepadPanningCamera
	if gamepadPan and (self.hasGameLoaded or not VRService.VREnabled) then
		gamepadPan = Util.GamepadLinearToCurve(gamepadPan)
		local currentTime = tick()
		if gamepadPan.X ~= 0 or gamepadPan.Y ~= 0 then
			self.userPanningTheCamera = true
		elseif gamepadPan == ZERO_VECTOR2 then
			self.lastThumbstickRotate = nil
			if self.lastThumbstickPos == ZERO_VECTOR2 then
				self.currentSpeed = 0
			end
		end
		local finalConstant = 0
		if self.lastThumbstickRotate then
			if VRService.VREnabled then
				self.currentSpeed = self.vrMaxSpeed
			else
				local elapsedTime = (currentTime - self.lastThumbstickRotate) * 10
				self.currentSpeed = self.currentSpeed + self.maxSpeed * (elapsedTime * elapsedTime / self.numOfSeconds)
				if self.currentSpeed > self.maxSpeed then
					self.currentSpeed = self.maxSpeed
				end
				if self.lastVelocity then
					local velocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickRotate)
					local velocityDeltaMag = (velocity - self.lastVelocity).magnitude
					if velocityDeltaMag > 12 then
						self.currentSpeed = self.currentSpeed * (20 / velocityDeltaMag)
						if self.currentSpeed > self.maxSpeed then
							self.currentSpeed = self.maxSpeed
						end
					end
				end
			end
			finalConstant = UserGameSettings.GamepadCameraSensitivity * self.currentSpeed
			self.lastVelocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickRotate)
		end
		self.lastThumbstickPos = gamepadPan
		self.lastThumbstickRotate = currentTime
		return Vector2.new(gamepadPan.X * finalConstant, gamepadPan.Y * finalConstant * self.ySensitivity * UserGameSettings:GetCameraYInvertValue())
	end
	return ZERO_VECTOR2
end
function BaseCamera:ApplyVRTransform()
	if not VRService.VREnabled then
		return
	end
	local rootJoint = self.humanoidRootPart and self.humanoidRootPart:FindFirstChild("RootJoint")
	if not rootJoint then
		return
	end
	local cameraSubject = game.Workspace.CurrentCamera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	if self.inFirstPerson and not isInVehicle then
		local vrFrame = VRService:GetUserCFrame(Enum.UserCFrame.Head)
		local vrRotation = vrFrame - vrFrame.p
		rootJoint.C0 = CFrame.new(vrRotation:vectorToObjectSpace(vrFrame.p)) * CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	else
		rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	end
end
function BaseCamera:IsInFirstPerson()
	return self.inFirstPerson
end
function BaseCamera:ShouldUseVRRotation()
	if not VRService.VREnabled then
		return false
	end
	if not self.VRRotationIntensityAvailable and tick() - self.lastVRRotationIntensityCheckTime < 1 then
		return false
	end
	local success, vrRotationIntensity = pcall(function()
		return StarterGui:GetCore("VRRotationIntensity")
	end)
	self.VRRotationIntensityAvailable = success and vrRotationIntensity ~= nil
	self.lastVRRotationIntensityCheckTime = tick()
	self.shouldUseVRRotation = success and vrRotationIntensity ~= nil and vrRotationIntensity ~= "Smooth"
	return self.shouldUseVRRotation
end
function BaseCamera:GetVRRotationInput()
	local vrRotateSum = ZERO_VECTOR2
	local success, vrRotationIntensity = pcall(function()
		return StarterGui:GetCore("VRRotationIntensity")
	end)
	if not success then
		return
	end
	local vrGamepadRotation = self.GamepadPanningCamera or ZERO_VECTOR2
	local delayExpired = tick() - self.lastVRRotationTime >= self:GetRepeatDelayValue(vrRotationIntensity)
	if math.abs(vrGamepadRotation.x) >= self:GetActivateValue() then
		if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] then
			local sign = 1
			if vrGamepadRotation.x < 0 then
				sign = -1
			end
			vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity) * sign
			self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = true
		end
	elseif math.abs(vrGamepadRotation.x) < self:GetActivateValue() - 0.1 then
		self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = nil
	end
	if self.turningLeft then
		if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Left] then
			vrRotateSum = vrRotateSum - self:GetRotateAmountValue(vrRotationIntensity)
			self.vrRotateKeyCooldown[Enum.KeyCode.Left] = true
		end
	else
		self.vrRotateKeyCooldown[Enum.KeyCode.Left] = nil
	end
	if self.turningRight then
		if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Right] then
			vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity)
			self.vrRotateKeyCooldown[Enum.KeyCode.Right] = true
		end
	else
		self.vrRotateKeyCooldown[Enum.KeyCode.Right] = nil
	end
	if vrRotateSum ~= ZERO_VECTOR2 then
		self.lastVRRotationTime = tick()
	end
	return vrRotateSum
end
function BaseCamera:CancelCameraFreeze(keepConstraints)
	if not keepConstraints then
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 1, self.cameraTranslationConstraints.z)
	end
	if self.cameraFrozen then
		self.trackingHumanoid = nil
		self.cameraFrozen = false
	end
end
function BaseCamera:StartCameraFreeze(subjectPosition, humanoidToTrack)
	if not self.cameraFrozen then
		self.humanoidJumpOrigin = subjectPosition
		self.trackingHumanoid = humanoidToTrack
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 0, self.cameraTranslationConstraints.z)
		self.cameraFrozen = true
	end
end
function BaseCamera:OnNewCameraSubject()
	if self.subjectStateChangedConn then
		self.subjectStateChangedConn:Disconnect()
		self.subjectStateChangedConn = nil
	end
	local humanoid = workspace.CurrentCamera and workspace.CurrentCamera.CameraSubject
	if self.trackingHumanoid ~= humanoid then
		self:CancelCameraFreeze()
	end
	if humanoid and humanoid:IsA("Humanoid") then
		self.subjectStateChangedConn = humanoid.StateChanged:Connect(function(oldState, newState)
			if VRService.VREnabled and newState == Enum.HumanoidStateType.Jumping and not self.inFirstPerson then
				self:StartCameraFreeze(self:GetSubjectPosition(), humanoid)
			elseif newState ~= Enum.HumanoidStateType.Jumping and newState ~= Enum.HumanoidStateType.Freefall then
				self:CancelCameraFreeze(true)
			end
		end)
	end
end
function BaseCamera:GetVRFocus(subjectPosition, timeDelta)
	local lastFocus = self.LastCameraFocus or subjectPosition
	if not self.cameraFrozen then
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, math.min(1, self.cameraTranslationConstraints.y + 0.42 * timeDelta), self.cameraTranslationConstraints.z)
	end
	local newFocus
	if self.cameraFrozen and self.humanoidJumpOrigin and self.humanoidJumpOrigin.y > lastFocus.y then
		newFocus = CFrame.new(Vector3.new(subjectPosition.x, math.min(self.humanoidJumpOrigin.y, lastFocus.y + 5 * timeDelta), subjectPosition.z))
	else
		newFocus = CFrame.new(Vector3.new(subjectPosition.x, lastFocus.y, subjectPosition.z):lerp(subjectPosition, self.cameraTranslationConstraints.y))
	end
	if self.cameraFrozen then
		if self.inFirstPerson then
			self:CancelCameraFreeze()
		end
		if self.humanoidJumpOrigin and subjectPosition.y < self.humanoidJumpOrigin.y - 0.5 then
			self:CancelCameraFreeze()
		end
	end
	return newFocus
end
function BaseCamera:GetRotateAmountValue(vrRotationIntensity)
	vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
	if vrRotationIntensity then
		if vrRotationIntensity == "Low" then
			return VR_LOW_INTENSITY_ROTATION
		elseif vrRotationIntensity == "High" then
			return VR_HIGH_INTENSITY_ROTATION
		end
	end
	return ZERO_VECTOR2
end
function BaseCamera:GetRepeatDelayValue(vrRotationIntensity)
	vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
	if vrRotationIntensity then
		if vrRotationIntensity == "Low" then
			return VR_LOW_INTENSITY_REPEAT
		elseif vrRotationIntensity == "High" then
			return VR_HIGH_INTENSITY_REPEAT
		end
	end
	return 0
end
function BaseCamera:Test()
	print("BaseCamera:Test()")
end
function BaseCamera:Update(dt)
	warn("BaseCamera:Update() This is a virtual function that should never be getting called.")
	return game.Workspace.CurrentCamera.CFrame, game.Workspace.CurrentCamera.Focus
end
return BaseCamera
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX187"><Properties><string name="Name">ZoomController</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZOOM_STIFFNESS = 4.5
local ZOOM_DEFAULT = 12.5
local ZOOM_ACCELERATION = 0.0375
local MIN_FOCUS_DIST = 0.5
local DIST_OPAQUE = 1
local Popper = require(script:WaitForChild("Popper"))
local clamp = math.clamp
local exp = math.exp
local min = math.min
local max = math.max
local pi = math.pi
local cameraMinZoomDistance, cameraMaxZoomDistance
do
	local Player = game:GetService("Players").LocalPlayer
	local function updateBounds()
		cameraMinZoomDistance = Player.CameraMinZoomDistance
		cameraMaxZoomDistance = Player.CameraMaxZoomDistance
	end
	updateBounds()
	Player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(updateBounds)
	Player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(updateBounds)
end
local ConstrainedSpring = {}
ConstrainedSpring.__index = ConstrainedSpring
function ConstrainedSpring.new(freq, x, minValue, maxValue)
	x = clamp(x, minValue, maxValue)
	return setmetatable({
		freq = freq,
		x = x,
		v = 0,
		minValue = minValue,
		maxValue = maxValue,
		goal = x
	}, ConstrainedSpring)
end
function ConstrainedSpring:Step(dt)
	local freq = self.freq * 2 * pi
	local x = self.x
	local v = self.v
	local minValue = self.minValue
	local maxValue = self.maxValue
	local goal = self.goal
	local offset = goal - x
	local step = freq * dt
	local decay = exp(-step)
	local x1 = goal + (v * dt - offset * (step + 1)) * decay
	local v1 = ((offset * freq - v) * step + v) * decay
	if minValue > x1 then
		x1 = minValue
		v1 = 0
	elseif maxValue < x1 then
		x1 = maxValue
		v1 = 0
	end
	self.x = x1
	self.v = v1
	return x1
end
local zoomSpring = ConstrainedSpring.new(ZOOM_STIFFNESS, ZOOM_DEFAULT, MIN_FOCUS_DIST, cameraMaxZoomDistance)
local function stepTargetZoom(z, dz, zoomMin, zoomMax)
	z = clamp(z + dz * (1 + z * ZOOM_ACCELERATION), zoomMin, zoomMax)
	if z < DIST_OPAQUE then
		z = dz <= 0 and zoomMin or DIST_OPAQUE
	end
	return z
end
local zoomDelta = 0
local Zoom = {}
function Zoom.Update(renderDt, focus, extrapolation)
	local poppedZoom = math.huge
	if zoomSpring.goal > DIST_OPAQUE then
		local maxPossibleZoom = max(zoomSpring.x, stepTargetZoom(zoomSpring.goal, zoomDelta, cameraMinZoomDistance, cameraMaxZoomDistance))
		poppedZoom = Popper(focus * CFrame.new(0, 0, MIN_FOCUS_DIST), maxPossibleZoom - MIN_FOCUS_DIST, extrapolation) + MIN_FOCUS_DIST
	end
	zoomSpring.minValue = MIN_FOCUS_DIST
	zoomSpring.maxValue = min(cameraMaxZoomDistance, poppedZoom)
	return zoomSpring:Step(renderDt)
end
function Zoom.SetZoomParameters(targetZoom, newZoomDelta)
	zoomSpring.goal = targetZoom
	zoomDelta = newZoomDelta
end
return Zoom
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX192"><Properties><string name="Name">Popper</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local FFlagUserPoppercamLooseOpacityThreshold
do
	local success, enabled = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserPoppercamLooseOpacityThreshold")
	end)
	FFlagUserPoppercamLooseOpacityThreshold = success and enabled
end
local camera = game.Workspace.CurrentCamera
local min = math.min
local tan = math.tan
local rad = math.rad
local inf = math.huge
local ray = Ray.new
local eraseFromEnd = function(t, toSize)
	for i = #t, toSize + 1, -1 do
		t[i] = nil
	end
end
local nearPlaneZ, projX, projY
do
	local function updateProjection()
		local fov = rad(camera.FieldOfView)
		local view = camera.ViewportSize
		local ar = view.X / view.Y
		projY = 2 * tan(fov / 2)
		projX = ar * projY
	end
	camera:GetPropertyChangedSignal("FieldOfView"):Connect(updateProjection)
	camera:GetPropertyChangedSignal("ViewportSize"):Connect(updateProjection)
	updateProjection()
	nearPlaneZ = camera.NearPlaneZ
	camera:GetPropertyChangedSignal("NearPlaneZ"):Connect(function()
		nearPlaneZ = camera.NearPlaneZ
	end)
end
local blacklist = {}
do
	local charMap = {}
	local function refreshIgnoreList()
		local n = 1
		blacklist = {}
		for _, character in pairs(charMap) do
			blacklist[n] = character
			n = n + 1
		end
	end
	local function playerAdded(player)
		local function characterAdded(character)
			charMap[player] = character
			refreshIgnoreList()
		end
		local function characterRemoving()
			charMap[player] = nil
			refreshIgnoreList()
		end
		player.CharacterAdded:Connect(characterAdded)
		player.CharacterRemoving:Connect(characterRemoving)
		if player.Character then
			characterAdded(player.Character)
		end
	end
	local function playerRemoving(player)
		charMap[player] = nil
		refreshIgnoreList()
	end
	Players.PlayerAdded:Connect(playerAdded)
	Players.PlayerRemoving:Connect(playerRemoving)
	for _, player in ipairs(Players:GetPlayers()) do
		playerAdded(player)
	end
	refreshIgnoreList()
end
local subjectRoot, subjectPart
camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
	local subject = camera.CameraSubject
	if subject:IsA("Humanoid") then
		subjectPart = subject.RootPart
	elseif subject:IsA("BasePart") then
		subjectPart = subject
	else
		subjectPart = nil
	end
end)
local function canOcclude(part)
	if FFlagUserPoppercamLooseOpacityThreshold then
		return part.Transparency < 0.25 and part.CanCollide and subjectRoot ~= (part:GetRootPart() or part) and not part:IsA("TrussPart")
	else
		return part.Transparency < 0.95 and part.CanCollide and subjectRoot ~= (part:GetRootPart() or part)
	end
end
local SCAN_SAMPLE_OFFSETS = {
	Vector2.new(0.4, 0),
	Vector2.new(-0.4, 0),
	Vector2.new(0, -0.4),
	Vector2.new(0, 0.4),
	Vector2.new(0, 0.2)
}
local function getCollisionPoint(origin, dir)
	local originalSize = #blacklist
	repeat
		local hitPart, hitPoint = workspace:FindPartOnRayWithIgnoreList(ray(origin, dir), blacklist, false, true)
		if hitPart then
			if hitPart.CanCollide then
				eraseFromEnd(blacklist, originalSize)
				return hitPoint, true
			end
			blacklist[#blacklist + 1] = hitPart
		end
	until not hitPart
	eraseFromEnd(blacklist, originalSize)
	return origin + dir, false
end
local function queryPoint(origin, unitDir, dist, lastPos)
	debug.profilebegin("queryPoint")
	local originalSize = #blacklist
	dist = dist + nearPlaneZ
	local target = origin + unitDir * dist
	local softLimit = inf
	local hardLimit = inf
	local movingOrigin = origin
	repeat
		local entryPart, entryPos = workspace:FindPartOnRayWithIgnoreList(ray(movingOrigin, target - movingOrigin), blacklist, false, true)
		if entryPart then
			if canOcclude(entryPart) then
				local wl = {entryPart}
				local exitPart = workspace:FindPartOnRayWithWhitelist(ray(target, entryPos - target), wl, true)
				local lim = (entryPos - origin).Magnitude
				if exitPart then
					local promote = false
					if lastPos then
						promote = workspace:FindPartOnRayWithWhitelist(ray(lastPos, target - lastPos), wl, true) or workspace:FindPartOnRayWithWhitelist(ray(target, lastPos - target), wl, true)
					end
					if promote then
						hardLimit = lim
					elseif dist < softLimit then
						softLimit = lim
					end
				else
					hardLimit = lim
				end
			end
			blacklist[#blacklist + 1] = entryPart
			movingOrigin = entryPos - unitDir * 0.001
		end
	until hardLimit < inf or not entryPart
	eraseFromEnd(blacklist, originalSize)
	debug.profileend()
	return softLimit - nearPlaneZ, hardLimit - nearPlaneZ
end
local function queryViewport(focus, dist)
	debug.profilebegin("queryViewport")
	local fP = focus.p
	local fX = focus.rightVector
	local fY = focus.upVector
	local fZ = -focus.lookVector
	local viewport = camera.ViewportSize
	local hardBoxLimit = inf
	local softBoxLimit = inf
	for viewX = 0, 1 do
		local worldX = fX * ((viewX - 0.5) * projX)
		for viewY = 0, 1 do
			local worldY = fY * ((viewY - 0.5) * projY)
			local origin = fP + nearPlaneZ * (worldX + worldY)
			local lastPos = camera:ViewportPointToRay(viewport.x * viewX, viewport.y * viewY).Origin
			local softPointLimit, hardPointLimit = queryPoint(origin, fZ, dist, lastPos)
			if hardBoxLimit > hardPointLimit then
				hardBoxLimit = hardPointLimit
			end
			if softBoxLimit > softPointLimit then
				softBoxLimit = softPointLimit
			end
		end
	end
	debug.profileend()
	return softBoxLimit, hardBoxLimit
end
local function testPromotion(focus, dist, focusExtrapolation)
	debug.profilebegin("testPromotion")
	local fP = focus.p
	local fX = focus.rightVector
	local fY = focus.upVector
	local fZ = -focus.lookVector
	debug.profilebegin("extrapolate")
	do
		local SAMPLE_DT = 0.0625
		local SAMPLE_MAX_T = 1.25
		local maxDist = (getCollisionPoint(fP, focusExtrapolation.posVelocity * SAMPLE_MAX_T) - fP).Magnitude
		local combinedSpeed = focusExtrapolation.posVelocity.magnitude
		for dt = 0, min(SAMPLE_MAX_T, focusExtrapolation.rotVelocity.magnitude + maxDist / combinedSpeed), SAMPLE_DT do
			local cfDt = focusExtrapolation.extrapolate(dt)
			if dist <= queryPoint(cfDt.p, -cfDt.lookVector, dist) then
				return false
			end
		end
		debug.profileend()
	end
	debug.profilebegin("testOffsets")
	for _, offset in ipairs(SCAN_SAMPLE_OFFSETS) do
		local scaledOffset = offset
		local pos, isHit = getCollisionPoint(fP, fX * scaledOffset.x + fY * scaledOffset.y)
		if queryPoint(pos, (fP + fZ * dist - pos).Unit, dist) == inf then
			return false
		end
	end
	debug.profileend()
	debug.profileend()
	return true
end
local function Popper(focus, targetDist, focusExtrapolation)
	debug.profilebegin("popper")
	subjectRoot = subjectPart and subjectPart:GetRootPart() or subjectPart
	local dist = targetDist
	local soft, hard = queryViewport(focus, targetDist)
	if dist > hard then
		dist = hard
	end
	if soft < dist and testPromotion(focus, targetDist, focusExtrapolation) then
		dist = soft
	end
	subjectRoot = nil
	debug.profileend()
	return dist
end
return Popper
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX197"><Properties><string name="Name">ExclusionZones</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local CS = game:GetService("CollectionService")
local Plr = game.Players.LocalPlayer
local ZoneEvent = game.ReplicatedStorage:WaitForChild("Events"):WaitForChild("ExclusionEvent")
local Debounce = function(Func, Time)
	local DB = true
	return function(...)
		if DB then
			DB = false
			Func(...)
			wait(Time)
			DB = true
		end
	end
end
local function FireOnTouch(Part)
	local Bool = Part.Parent.Parent:FindFirstChildWhichIsA("BoolValue")
	local In = Part.Parent.Name == "In"
	Part.Touched:Connect(Debounce(function(Brik)
		local AlreadyTagged = CS:HasTag(Plr.Character, Part.Parent.Parent.Name)
		if not In and not not AlreadyTagged and (not Bool or Bool.Value) and Brik:IsDescendantOf(Plr.Character) then
			ZoneEvent:FireServer(Part)
		end
	end, 1))
end
local ProcessChildren = function(Dir, Func)
	for _, Ch in pairs(Dir:GetChildren()) do
		Func(Ch)
	end
	Dir.ChildAdded:Connect(Func)
end
local function ProcessZone(Zone)
	local InDir, OutDir = Zone:WaitForChild("In"), Zone:WaitForChild("Out")
	ProcessChildren(InDir, FireOnTouch)
	ProcessChildren(OutDir, FireOnTouch)
end
ProcessChildren(workspace:WaitForChild("ExclusionZones"), ProcessZone)
return function()
end
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX202"><Properties><string name="Name">Notifications</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local StarterGui = game:GetService("StarterGui")
local function Notify(Title, Text, Icon, Duration)
	StarterGui:SetCore("SendNotification", {
		Title = Title or "SCPF",
		Text = Text or "_CONTENT",
		Icon = Icon or nil,
		Duration = Duration or 5
	})
end
game:GetService("Players").PlayerAdded:connect(function(Player)
	if Player:GetRankInGroup(2694395) >= 50 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(2694395))
		Notify("SCPF HR Joined", Message, "rbxassetid://764606705", 8)
	end
	if Player:GetRankInGroup(2755639) >= 40 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(2755639))
		Notify("CI HR Joined", Message, "rbxassetid://1056285476", 8)
	end
	if Player:GetRankInGroup(3292065) >= 100 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(3292065))
		Notify("TSH HR Joined", Message, "rbxassetid://1238401889", 8)
	end
	if Player:GetRankInGroup(2896818) >= 13 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(2896818))
		Notify("GOC HR Joined", Message, "rbxassetid://273197914", 8)
	end
end)
return function()
	return Notify
end
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX207"><Properties><string name="Name">TechSystems</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ControlPanel = {}
local Controls = workspace.Mechanics.Controls
local LightingRoot = workspace.Mechanics.Lights
local PowerEvent = game.ReplicatedStorage:WaitForChild("Events"):WaitForChild("TechEvent")
for _, Light in pairs(LightingRoot:GetDescendants()) do
	if Light:IsA("BasePart") then
		Light:Clone().Parent = Light.Parent
		Light:Destroy()
	end
end
ControlPanel.SectorDefaultLights = {
	S1 = {
		LightColor = BrickColor.new("Pearl").Color,
		SpotColor = BrickColor.new("Pearl").Color
	},
	S2 = {
		LightColor = BrickColor.new("Really blue").Color,
		SpotColor = Color3.fromRGB(175, 221, 255)
	},
	S3 = {
		LightColor = BrickColor.new("Beige").Color,
		SpotColor = BrickColor.new("Beige").Color
	},
	S4 = {
		LightColor = Color3.fromRGB(118, 78, 0),
		SpotColor = Color3.fromRGB(118, 53, 0)
	}
}
ControlPanel.SectorDefaultWalls = {
	Sector1A = {
		BColor3 = Color3.fromRGB(170, 85, 0),
		Material = "Neon"
	},
	Sector1B = {
		BColor3 = Color3.fromRGB(39, 70, 45),
		Material = "Neon"
	},
	Sector2 = {
		BColor3 = Color3.fromRGB(24, 5, 236),
		Material = "Neon"
	},
	Sector3 = {
		BColor3 = Color3.fromRGB(27, 42, 53),
		Material = "Neon"
	},
	Sector4 = {
		BColor3 = Color3.fromRGB(26, 11, 88),
		Material = "Neon"
	}
}
ControlPanel.SectorLightingEnabled = {
	S1 = true,
	S2 = true,
	S3 = true,
	S4 = true
}
ControlPanel.PowerLevel = 4
function ControlPanel:NewData(PowerLevel, SectorLightingEnabled)
	self.PowerLevel = PowerLevel
	self.SectorLightingEnabled = SectorLightingEnabled
end
function ControlPanel:SetSectorSituationLighting(Sector, Color, Material)
	for i, v in pairs(Sector:GetChildren()) do
		if v:IsA("BasePart") then
			v.Color = Color
			v.Material = Material
		end
	end
	if Sector.Name == "S2" then
		workspace.Map.Change.Color = Color
		workspace.Map.Change.Material = Material
	end
end
function ControlPanel:SetSectorLighting(Sector, Value, Brightness, OptionalColorA, OptionalColorB)
	for i, v in pairs(Sector:GetChildren()) do
		if v:IsA("BasePart") and v.Name == "Light" and v:FindFirstChild("SpotLight") then
			if not v:FindFirstChild("OriginalBrightness") then
				local OrigBright = Instance.new("NumberValue")
				OrigBright.Name = "OriginalBrightness"
				OrigBright.Value = v.SpotLight.Brightness
				OrigBright.Parent = v
			end
			local Baseline = v.OriginalBrightness.Value
			v.SpotLight.Enabled = OptionalColorA == nil and Value or OptionalColorA ~= nil
			v.SpotLight.Color = OptionalColorA ~= nil and OptionalColorA or self.SectorDefaultLights[Sector.Name].SpotColor
			v.SpotLight.Brightness = Baseline * Brightness
			v.Color = Value and self.SectorDefaultLights[Sector.Name].LightColor or OptionalColorB ~= nil and OptionalColorB or Color3.new(0, 0, 0)
			v.Material = (OptionalColorA ~= nil or Value) and Enum.Material.Neon.Value or Enum.Material.Glass.Value
		end
	end
end
local function OnLightChange(Type, Arg)
	if Type == "SectorLightingUpdate" then
		ControlPanel:SetSectorLighting(unpack(Arg))
	elseif Type == "SituationLightingUpdate" then
		ControlPanel:SetSectorSituationLighting(unpack(Arg))
	elseif Type == "LightingBulk" then
		ControlPanel:NewData(unpack(Arg))
	end
end
PowerEvent.OnClientEvent:Connect(OnLightChange)
PowerEvent:FireServer()
return function()
	return ControlPanel
end
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX212"><Properties><string name="Name">Doors</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Event = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("DoorEvent")
local TweenService = game:GetService("TweenService")
local LocalDoorState = {}
local Player = game.Players.LocalPlayer
local DoorContainer = Instance.new("Folder")
DoorContainer.Name = "Doors"
DoorContainer.Parent = workspace.CurrentCamera
local Backpack
function GetDoorType(Door)
	local DoorType = "None"
	if Door:FindFirstChild("Button") and Door:FindFirstChild("Door1"):FindFirstChild("Special Part") then
		DoorType = "DoubleDoor"
	end
	if Door:FindFirstChild("Scripted") then
		if Door:FindFirstChild("Scripted"):FindFirstChild("unixyoutool") then
			DoorType = "BlastDoor"
		elseif Door:FindFirstChild("Scripted"):FindFirstChild("LeftDoor") then
			DoorType = "DoubleGate"
		elseif Door:FindFirstChild("Scripted"):FindFirstChild("Door") then
			DoorType = "CardDoor"
		end
	end
	return DoorType
end
function CardDoorRun(Door)
	if LocalDoorState[Door].State then
		LocalDoorState[Door].OutTween:Play()
		LocalDoorState[Door].LocalDoor.AccessGranted:Play()
		LocalDoorState[Door].LocalDoor.DoorOpen:Play()
	else
		LocalDoorState[Door].InTween:Play()
		LocalDoorState[Door].LocalDoor.DoorClose:Play()
	end
end
function DoubleGateRun(Door)
	if LocalDoorState[Door].State then
		LocalDoorState[Door].OutTweenA:Play()
		LocalDoorState[Door].OutTweenB:Play()
		LocalDoorState[Door].LocalDoorA.AccessGranted:Play()
		LocalDoorState[Door].LocalDoorA.DoorOpen:Play()
	else
		LocalDoorState[Door].InTweenA:Play()
		LocalDoorState[Door].InTweenB:Play()
		LocalDoorState[Door].LocalDoorA.DoorClose:Play()
	end
end
function BlastDoorRun(Door)
	if LocalDoorState[Door].State then
		LocalDoorState[Door].OutTweenA:Play()
		LocalDoorState[Door].OutTweenB:Play()
		LocalDoorState[Door].LocalDoorA.Alarm:Play()
		LocalDoorState[Door].LocalDoorA.AccessGranted:Play()
		LocalDoorState[Door].LocalDoorA.DoorOpen:Play()
	else
		LocalDoorState[Door].InTweenA:Play()
		LocalDoorState[Door].InTweenB:Play()
		LocalDoorState[Door].LocalDoorA.Alarm:Play()
		LocalDoorState[Door].LocalDoorA.DoorClose:Play()
	end
end
function HandleLocalDoor(Door)
	local Type = GetDoorType(Door.Object)
	if Type == "None" then
		return
	elseif Type == "CardDoor" then
		local LocalDoor = Door.Object.Scripted.Door:Clone()
		LocalDoor.Parent = DoorContainer
		LocalDoor.Transparency = 0
		LocalDoor.CanCollide = true
		Door.Object.Scripted.Door:Destroy()
		LocalDoorState[Door.Name].LocalDoor = LocalDoor
		local OutTween = TweenService:Create(Door.LocalDoor, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoor.CFrame * CFrame.new(0, 0, -5)
		})
		local InTween = TweenService:Create(Door.LocalDoor, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoor.CFrame
		})
		LocalDoorState[Door.Name].InTween = InTween
		LocalDoorState[Door.Name].OutTween = OutTween
		Door.Moving = false
		Door.Object:WaitForChild("ObjectState").Changed:Connect(function()
			LocalDoorState[Door.Name].State = Door.Object:WaitForChild("ObjectState").Value
			CardDoorRun(Door.Name)
		end)
		for i, v in pairs(Door.Object.Scripted.Readers:GetChildren()) do
			v.Touched:connect(function(Hit)
				if Hit.Parent:IsA("Tool") and Hit.Parent:IsDescendantOf(game.Players.LocalPlayer.Character) and (Door.Object.Allowed:FindFirstChild(Hit.Parent.Name) and Door.Object.Allowed:FindFirstChild(Hit.Parent.Name).Value or Hit.Parent.Name == "[SCP] Card-Omni") then
					if not Door.Moving then
						Door.Moving = true
						for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
							Door.BrickColor = BrickColor.new("Lime green")
							delay(1, function()
								Door.BrickColor = BrickColor.new("Institutional white")
							end)
						end
						Event:FireServer("ToggleCardDoor", Door.Name, Hit.Parent)
						wait(1)
						Door.Moving = false
					end
				elseif Hit.Parent.Name:match("[SCP]") or Hit.Parent.Name:match("Gamepass") then
					for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
						Door.BrickColor = BrickColor.new("Really red")
						delay(1, function()
							Door.BrickColor = BrickColor.new("Institutional white")
						end)
					end
				end
			end)
		end
	elseif Type == "DoubleGate" then
		local LocalDoorA = Door.Object.Scripted.LeftDoor:Clone()
		LocalDoorA.Parent = DoorContainer
		LocalDoorA.Transparency = 0
		LocalDoorA.CanCollide = true
		LocalDoorState[Door.Name].LocalDoorA = LocalDoorA
		local LocalDoorB = Door.Object.Scripted.RightDoor:Clone()
		LocalDoorB.Parent = DoorContainer
		LocalDoorB.Transparency = 0
		LocalDoorB.CanCollide = true
		Door.Object.Scripted.LeftDoor:Destroy()
		Door.Object.Scripted.RightDoor:Destroy()
		LocalDoorState[Door.Name].LocalDoorB = LocalDoorB
		local OutTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorA.CFrame * CFrame.new(0, 0, Door.LocalDoorA.Size.Z)
		})
		local InTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorA.CFrame
		})
		local OutTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorB.CFrame * CFrame.new(0, 0, Door.LocalDoorA.Size.Z)
		})
		local InTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorB.CFrame
		})
		LocalDoorState[Door.Name].InTweenA = InTweenA
		LocalDoorState[Door.Name].InTweenB = InTweenB
		LocalDoorState[Door.Name].OutTweenA = OutTweenA
		LocalDoorState[Door.Name].OutTweenB = OutTweenB
		Door.Moving = false
		Door.Object:WaitForChild("ObjectState").Changed:Connect(function()
			LocalDoorState[Door.Name].State = Door.Object:WaitForChild("ObjectState").Value
			DoubleGateRun(Door.Name)
		end)
		for i, v in pairs(Door.Object.Scripted.Readers:GetChildren()) do
			v.Touched:connect(function(Hit)
				if Hit.Parent:IsA("Tool") and Hit.Parent:IsDescendantOf(game.Players.LocalPlayer.Character) and (Door.Object.Allowed:FindFirstChild(Hit.Parent.Name) and Door.Object.Allowed:FindFirstChild(Hit.Parent.Name).Value or Hit.Parent.Name == "[SCP] Card-Omni") then
					if not Door.Moving then
						Door.Moving = true
						for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
							Door.BrickColor = BrickColor.new("Lime green")
							delay(1, function()
								Door.BrickColor = BrickColor.new("Institutional white")
							end)
						end
						Event:FireServer("ToggleDoubleGate", Door.Name, Hit.Parent)
						wait(1)
						Door.Moving = false
					end
				elseif Hit.Parent.Name:match("[SCP]") or Hit.Parent.Name:match("Gamepass") then
					for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
						Door.BrickColor = BrickColor.new("Really red")
						delay(1, function()
							Door.BrickColor = BrickColor.new("Institutional white")
						end)
					end
				end
			end)
		end
	elseif Type == "BlastDoor" then
		local LocalDoorA = Door.Object.Scripted.LeftDoor:Clone()
		LocalDoorA.Parent = DoorContainer
		LocalDoorA.Transparency = 0
		LocalDoorA.CanCollide = true
		LocalDoorState[Door.Name].LocalDoorA = LocalDoorA
		local LocalDoorB = Door.Object.Scripted.RightDoor:Clone()
		LocalDoorB.Parent = DoorContainer
		LocalDoorB.Transparency = 0
		LocalDoorB.CanCollide = true
		Door.Object.Scripted.LeftDoor:Destroy()
		Door.Object.Scripted.RightDoor:Destroy()
		LocalDoorState[Door.Name].LocalDoorB = LocalDoorB
		local Closed = Door.Object:WaitForChild("ObjectState").Value
		local OpenA = Closed and {
			CFrame = Door.LocalDoorA.CFrame * CFrame.new(0, 0, -Door.LocalDoorA.Size.Z)
		} or {
			CFrame = Door.LocalDoorA.CFrame
		}
		local OpenB = Closed and {
			CFrame = Door.LocalDoorB.CFrame * CFrame.new(0, 0, -Door.LocalDoorB.Size.Z)
		} or {
			CFrame = Door.LocalDoorB.CFrame
		}
		local ClosedA = Closed and {
			CFrame = Door.LocalDoorA.CFrame
		} or {
			CFrame = Door.LocalDoorA.CFrame * CFrame.new(0, 0, Door.LocalDoorA.Size.Z)
		}
		local ClosedB = Closed and {
			CFrame = Door.LocalDoorB.CFrame
		} or {
			CFrame = Door.LocalDoorB.CFrame * CFrame.new(0, 0, Door.LocalDoorB.Size.Z)
		}
		local OutTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), ClosedA)
		local InTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), OpenA)
		local OutTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), ClosedB)
		local InTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), OpenB)
		LocalDoorState[Door.Name].InTweenA = InTweenA
		LocalDoorState[Door.Name].InTweenB = InTweenB
		LocalDoorState[Door.Name].OutTweenA = OutTweenA
		LocalDoorState[Door.Name].OutTweenB = OutTweenB
		Door.Moving = false
		Door.Object:WaitForChild("ObjectState").Changed:Connect(function()
			LocalDoorState[Door.Name].State = Door.Object:WaitForChild("ObjectState").Value
			BlastDoorRun(Door.Name)
		end)
		if Door.Object.Scripted:FindFirstChild("Readers") then
			for i, v in pairs(Door.Object.Scripted.Readers:GetChildren()) do
				v.Touched:connect(function(Hit)
					if Hit.Parent:IsA("Tool") and Hit.Parent:IsDescendantOf(game.Players.LocalPlayer.Character) and (Door.Object.Allowed:FindFirstChild(Hit.Parent.Name) and Door.Object.Allowed:FindFirstChild(Hit.Parent.Name).Value or Hit.Parent.Name == "[SCP] Card-Omni") then
						if not Door.Moving then
							Door.Moving = true
							for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
								Door.BrickColor = BrickColor.new("Lime green")
								delay(1, function()
									Door.BrickColor = BrickColor.new("Institutional white")
								end)
							end
							Event:FireServer("ToggleBlastDoor", Door.Name, Hit.Parent)
							wait(1)
							Door.Moving = false
						end
					elseif Hit.Parent.Name:match("[SCP]") or Hit.Parent.Name:match("Gamepass") then
						for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
							Door.BrickColor = BrickColor.new("Really red")
							delay(1, function()
								Door.BrickColor = BrickColor.new("Institutional white")
							end)
						end
					end
				end)
			end
		end
	end
end
Event:FireServer("GainUpdateBatch")
Event.OnClientEvent:connect(function(Type, Door, State)
	if Type == "SingleDoor" then
		LocalDoorState[Door].State = State
		CardDoorRun(Door)
	elseif Type == "DoubleGate" then
		LocalDoorState[Door].State = State
		DoubleGateRun(Door)
	elseif Type == "BlastDoor" then
		print("BlastDoor")
		LocalDoorState[Door].State = State
		BlastDoorRun(Door)
	elseif Type == "Bulk" then
		LocalDoorState = Door
		for i, v in pairs(LocalDoorState) do
			HandleLocalDoor(v)
		end
	end
end)
Backpack = Player:FindFirstChildWhichIsA("Backpack")
local MurderEars = function()
	if script:FindFirstChild("Oof") then
		script.Oof:Play()
	end
	if script:FindFirstChild("ColorCorrection") then
		script.ColorCorrection:Clone().Parent = game.Lighting
	end
	if script:FindFirstChild("Bloom") then
		script.Bloom:Clone().Parent = game.Lighting
	end
	wait(3)
end
local function PreventToolNameChange(Child)
	local NameSignal = Child:GetPropertyChangedSignal("Name")
	local Conn
	Conn = NameSignal:Connect(function()
		print("you know i had to do it to em")
		Conn:Disconnect()
		Conn = nil
		MurderEars()
		game.Players.LocalPlayer:Kick([[

[SCPF] It's time to stop.]])
	end)
end
if Backpack then
	for _, Child in pairs(Backpack:GetChildren()) do
		PreventToolNameChange(Child)
	end
end
Player.ChildAdded:Connect(function(Child)
	if Child:IsA("Backpack") then
		Backpack = Child
		for _, Chld in pairs(Backpack:GetChildren()) do
			PreventToolNameChange(Chld)
		end
		Child.ChildAdded:connect(PreventToolNameChange)
	end
end)
local function EnforceSonar(Chr)
	local Conn, Conn1
	local Sonar = Chr:WaitForChild("Animate")
	if game:GetService("Players"):GetPlayerFromCharacter(Chr):GetRankInGroup(2694395) < 70 then
		Conn = Chr.ChildRemoved:Connect(function(Child)
			wait(0.2)
			if Child == Sonar and Chr:FindFirstChild("Humanoid") and Chr.Humanoid.Health > 0 then
				MurderEars()
				Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
			end
		end)
		Conn2 = Sonar:GetPropertyChangedSignal("Disabled"):Connect(function()
			wait(0.2)
			MurderEars()
			Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
		end)
		Conn1 = Chr:WaitForChild("Humanoid").Died:Connect(function()
			Conn:Disconnect()
			Conn1:Disconnect()
			Conn2:Disconnect()
			Conn, Conn1, Conn2 = nil, nil, nil
		end)
	end
end
local function IHateYou()
	Player:Kick([[
[SCPF]
WOAH, there's Wi-Fi on the short bus?]])
end
DoorContainer.DescendantRemoving:Connect(IHateYou)
DoorContainer:GetPropertyChangedSignal("Parent"):Connect(IHateYou)
local AllowedGuis = {
	"CoreUI",
	"RobloxGui",
	"ControlGui",
	"ShopGui",
	"CoffeeMachineDrink",
	"Model Resize GUI",
	"ChoiceUI",
	"Hitmarker",
	"Blind",
	"DefibCharge",
	"TokenMenu",
	"Menu",
	"AmmoGui",
	"ActivityLog",
	"FlashGUI",
	"NV",
	"UglySuitChoice",
	"VisionControls",
	"CustomCharGui",
	"LoadoutGui",
	"BriefingGui",
	"PhysicsAnalyzerGui",
	"CommandGui",
	"SCP061Gui",
	"Radio",
	"Repairing",
	"ScopeGui",
	"362Gui",
	"MusicPanel_DebugBuild",
	"Command",
	"Blindness",
	"WeldingGui",
	"MenuUI"
}
Player.CharacterAdded:Connect(EnforceSonar)
return {}
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX217"><Properties><string name="Name">Guns</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local RS = game:GetService("RunService")
local CS = game:GetService("CollectionService")
local UserInputService = game:GetService("UserInputService")
local Cam = workspace.CurrentCamera
local Player = game.Players.LocalPlayer
local UI = Player:WaitForChild("PlayerGui"):WaitForChild("AmmoGui")
local Mouse = Player:GetMouse()
local GunScript = {}
local GunRemote = game.ReplicatedStorage:WaitForChild("Events"):WaitForChild("GunEvent")
GunRemote.Name = game:GetService("HttpService"):GenerateGUID(false)
local CurrentGun
local CurrentGunStats = {}
local CachedGunStats = {}
local Hold, Crouch, Run, Reload, Pushback
local Encrypt_Key = 1
local PrevWalkspeed = 16
local CrosshairWidth = 15
local DotCursor = false
local LastShot = tick()
local Shooting = false
local AmmoSound = script:WaitForChild("AmmoPickup")
local AmmoFunc = workspace:WaitForChild("Mechanics"):WaitForChild("AmmoBoxes"):WaitForChild("GetAmmo")
local AmmoTag = "AmmoBox"
local HitSound = script:WaitForChild("HitSound")
local HeadShotSound = script:WaitForChild("HitHead")
local StatsEnabled = false
local NearShots, HitShots = 0, 0
local StatsDumpingFunction = game.ReplicatedStorage:WaitForChild("Functions"):WaitForChild("SendStats")
local Stats_Key = 1
local BulletSounds = {
	"rbxassetid://2303101209",
	"rbxassetid://142082170"
}
local LastSound = 1
local function SendStats(StatName, Data)
	Stats_Key = Stats_Key + math.pi / 5
end
local SCPF = 2694395
local Rank = Player:GetRankInGroup(SCPF)
local Clicks = 0
local Count = 0
local Step = 1
local function ResetCount()
	Step = Step + 1
	if Step % 30 == 0 then
		Step = 1
		Count = 0
	end
end
local function Clicked()
	Count = Count + 1
	if Count >= 6 then
		Player:Kick([[

[SCPF] An attempt was made.]])
	end
end
if Rank < 15 then
	RS:BindToRenderStep("YouTriedSploiterBoy", Enum.RenderPriority.Last.Value, ResetCount)
end
function GunScript:RotateKey()
	Encrypt_Key = Encrypt_Key + math.pi / 100
end
function GunScript:Set(StatName, Value)
	if CurrentGunStats and CurrentGunStats[StatName] then
		if CurrentGunStats[StatName] ~= CachedGunStats[StatName] then
			Player:Kick("[SCPF] Beware... God is watching you.")
		end
		CurrentGunStats[StatName] = Value
		CachedGunStats[StatName] = Value
	end
end
function GunScript:Get(StatName)
	if CurrentGunStats and CurrentGunStats[StatName] then
		if CurrentGunStats[StatName] ~= CachedGunStats[StatName] then
			Player:Kick("[SCPF] If only it was that easy.")
		end
		return CurrentGunStats[StatName]
	end
end
function GunScript:UpdateUI()
	if not CurrentGun then
		UI.Enabled = false
		return
	end
	UI.Enabled = true
	UI.Cursor.Ammo.Text = tostring(CurrentGunStats.Ammo)
	UI.Cursor.GunType.Text = tostring(CurrentGunStats.TotalAmmo)
end
function GunScript:Reload()
	CancelReload = false
	if self:Get("TotalAmmo") <= 0 then
		CurrentGun.Handle.EmptyClip:Play()
		Reloading = false
		return
	end
	if DotCursor then
		UI.Cursor.Ammo.Visible = true
		UI.Cursor.GunType.Visible = true
		delay(CurrentGunStats.ReloadTime + 1, function()
			if DotCursor then
				UI.Cursor.Ammo.Visible = false
				UI.Cursor.GunType.Visible = false
			end
		end)
	end
	local ShotgunLoad = CurrentGunStats.FiringMode and CurrentGunStats.FiringMode[1] == "Shotgun" or nil
	UI.Cursor.Ammo.Text = "RLD..."
	CurrentGun.Handle.ReloadSound:Play()
	Reload:Play()
	wait(self:Get("ReloadTime"))
	if not CancelReload then
		UI.Cursor.Ammo.Text = "RLD..."
		self:Set("TotalAmmo", self:Get("TotalAmmo") + self:Get("Ammo"))
		self:Set("Ammo", 0)
		if CurrentGunStats.TotalAmmo >= CurrentGunStats.ClipSize then
			self:Set("Ammo", self:Get("ClipSize"))
			self:Set("TotalAmmo", self:Get("TotalAmmo") - self:Get("ClipSize"))
		else
			self:Set("Ammo", self:Get("TotalAmmo"))
			self:Set("TotalAmmo", 0)
		end
		CurrentGun.Handle.ReloadSound:Stop()
		self:UpdateUI()
		Reloading = false
	else
		CurrentGun.Handle.ReloadSound:Stop()
		Reloading = false
		self:UpdateUI()
		CancelReload = false
	end
end
function GunScript:ChangeCursor()
	DotCursor = not DotCursor
	if UI:FindFirstChild("Cursor") then
		if DotCursor then
			UI.Cursor.Left.Visible = false
			UI.Cursor.Right.Visible = false
			UI.Cursor.Top.Visible = false
			UI.Cursor.Bottom.Visible = false
			UI.Cursor.Ammo.Visible = false
			UI.Cursor.GunType.Visible = false
			UI.Cursor.Dot.Visible = true
		else
			UI.Cursor.Left.Visible = true
			UI.Cursor.Right.Visible = true
			UI.Cursor.Top.Visible = true
			UI.Cursor.Bottom.Visible = true
			UI.Cursor.Ammo.Visible = true
			UI.Cursor.GunType.Visible = true
			UI.Cursor.Dot.Visible = false
		end
	end
end
local DISTORT_STUDS = 100
local DistortVector = function(D, SpreadX, SpreadY, SpreadZ)
	return Vector3.new(D * SpreadX, D * SpreadY, D * SpreadZ) * (math.random() > 0.5 and -1 or 1)
end
function FireGun(NewRay, Sender, NotPlayer)
	local Part, Pos = workspace:FindPartOnRayWithIgnoreList(NewRay, {
		Sender.Character,
		workspace.GunDebris,
		workspace.Map.GunsIgnore,
		workspace.Doors
	}, false, true)
	return Part, Pos
end
function GunScript:FireGun()
	if Player.Character.Humanoid.Health <= 0 then
		return
	end
	self:Set("Ammo", self:Get("Ammo") - 1)
	local Damage = math.random(self:Get("minDamage"), self:Get("maxDamage"))
	if CrosshairWidth < 80 then
		CrosshairWidth = CrosshairWidth + math.floor(Damage / CurrentGunStats.RecoilDivisor)
	end
	GunScript:UpdateUI()
	Pushback:Play()
	local ShotsFired = {}
	local NumShots = 1
	if CurrentGunStats.FiringMode then
		NumShots = CurrentGunStats.FiringMode.NumBullets or 1
	end
	for i = 1, NumShots do
		local Distortion = DistortVector(CurrentGunStats.Distort or DISTORT_STUDS, (math.random() * 2 - 1) * (CrosshairWidth + (CurrentGunStats.InherentSpread or 0) - 15) / 15, (math.random() * 2 - 1) * (CrosshairWidth + (CurrentGunStats.InherentSpread or 0) - 15) / 15, (math.random() * 2 - 1) * (CrosshairWidth + (CurrentGunStats.InherentSpread or 0) - 15) / 15)
		local NewRay = Ray.new(CurrentGun.BPoint.Position, (Mouse.Hit.p - CurrentGun.BPoint.Position) * 500 + Distortion)
		local Part, Pos = FireGun(NewRay, game.Players.LocalPlayer)
		if Part and Pos then
			local DoDamage = false
			local Chr
			if Part.Parent and Part.Parent:FindFirstChild("Humanoid") then
				Chr = Part.Parent
			else
				for i, v in pairs(game.Players:GetPlayers()) do
					if Part:IsDescendantOf(v.Character) then
						Chr = v.Character
						break
					end
				end
			end
			if Chr then
				local Critical = Chr.Humanoid.Health - Damage <= 0 or Part.Parent == Chr and Chr.Humanoid:GetLimb(Part) == Enum.Limb.Head or Part:FindFirstChild("HatAttachment") or Part:FindFirstAncestor("Helmet")
				UI.Hitmarker.Visible = true
				UI.Hitmarker.ImageColor3 = Critical and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
				HitSound:Play()
				if Critical then
					HeadShotSound:Play()
				end
				delay(0.05, function()
					UI.Hitmarker.Visible = false
				end)
				UI.Hitmarker.Position = UDim2.new(0, Mouse.X - 20, 0, Mouse.Y - 20)
			end
		end
		if DotCursor then
			UI.Cursor.Ammo.Visible = true
			local TBS = self:Get("TimeBetweenShots")
			delay(TBS, function()
				if DotCursor and not Reloading then
					UI.Cursor.Ammo.Visible = false
				end
			end)
		end
		table.insert(ShotsFired, {
			Part,
			Pos,
			NewRay
		})
	end
	GunRemote:FireServer(Encrypt_Key, CurrentGun, ShotsFired)
	self:RotateKey()
end
function GunScript.Equip(Gun)
	Player = game.Players.LocalPlayer
	CurrentGun = Gun
	UI = Player:WaitForChild("PlayerGui"):WaitForChild("AmmoGui")
	CurrentGunStats = require(Gun:FindFirstChild("Settings"))
	CurrentGunStats.avgDamage = (CurrentGunStats.minDamage + CurrentGunStats.maxDamage) / 2
	CurrentGunStats.RecoilDivisor = CurrentGunStats.RecoilDivisor or 3
	for k, v in pairs(CurrentGunStats) do
		CachedGunStats[k] = v
	end
	if not (Hold and Crouch) or not Run then
		Hold, Crouch, Run, Reload, Pushback = Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Idle")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("CrouchH")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Running")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Reload")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Pushback"))
	end
	GunScript:UpdateUI()
	Hold:Play()
	Equipped = true
	UI.Enabled = true
	UserInputService.MouseIconEnabled = false
end
function GunScript.Unequip()
	UI.Enabled = false
	UserInputService.MouseIconEnabled = true
	Hold:Stop()
	Run:Stop()
	Crouch:Stop()
	Equipped = false
	Player.Character.Humanoid.WalkSpeed = PrevWalkspeed
	Player.Character.Humanoid.CameraOffset = Vector3.new(0, 0, 0)
	Reloading, Firing, Running, Crouching = false, false, false, false
	Mouse.Icon = ""
	CancelReload = true
	CurrentGun = nil
	CurrentGunStats = nil
end
function GunScript.GetAmmo(Box)
	local Debounce = true
	return function(Part)
		if not Part:IsDescendantOf(Player.Character) then
			return
		end
		if not CurrentGunStats then
			return
		end
		if Debounce then
			Debounce = false
			pcall(function()
				if CurrentGunStats and CurrentGunStats.TotalAmmo and CurrentGunStats.AmmoCapacity and CurrentGunStats.TotalAmmo < CurrentGunStats.AmmoCapacity then
					local Difference = (CurrentGunStats.AmmoCapacity - CurrentGunStats.TotalAmmo) / CurrentGunStats.AmmoCapacity
					local Consume = AmmoFunc:InvokeServer(Box, Difference)
					GunScript:Set("TotalAmmo", CurrentGunStats.TotalAmmo + math.min(math.ceil(CurrentGunStats.AmmoCapacity * Consume), CurrentGunStats.AmmoCapacity))
					GunScript:UpdateUI()
					AmmoSound:Play()
				end
			end)
			wait(1)
			Debounce = true
		end
	end
end
local function OnStep()
	if not Equipped then
		return
	end
	local X, Y = Mouse.X, Mouse.Y
	if UI:FindFirstChild("Cursor") then
		UI.Cursor.Position = UDim2.new(0, X, 0, Y)
	end
end
local function ShrinkCrosshair()
	if not Equipped then
		return
	end
	if CrosshairWidth > 15 then
		CrosshairWidth = CrosshairWidth * 0.975
	else
		CrosshairWidth = 15
	end
	if UI:FindFirstChild("Cursor") then
		UI.Cursor.Left.Position = UDim2.new(0, -1 * CrosshairWidth, 0, 0)
		UI.Cursor.Right.Position = UDim2.new(0, CrosshairWidth, 0, 0)
		UI.Cursor.Top.Position = UDim2.new(0, 0, 0, -1 * CrosshairWidth)
		UI.Cursor.Bottom.Position = UDim2.new(0, 0, 0, CrosshairWidth)
	end
end
RS:BindToRenderStep("GunMouseMove", Enum.RenderPriority.Character.Value - 1, OnStep)
RS.Heartbeat:Connect(ShrinkCrosshair)
UserInputService.InputBegan:connect(function(IO, GP)
	if not Equipped or GP then
		return
	end
	if IO.UserInputType == Enum.UserInputType.MouseButton1 then
		if CurrentGunStats.Ammo <= 0 then
			CurrentGun.Handle.EmptyClip:Play()
		end
		if tick() - LastShot >= 0.01 + CurrentGunStats.TimeBetweenShots and CurrentGunStats.Ammo > 0 and not Firing and not Shooting and not Reloading and not Running then
			if CurrentGunStats.RapidFire and (not CurrentGunStats.FiringMode or CurrentGunStats.FiringMode[1] == "Shotgun") and not Firing then
				Firing = true
				Shooting = true
				repeat
					GunScript:FireGun()
					LastShot = tick()
					wait(0.1 + CurrentGunStats.TimeBetweenShots)
				until not Firing or CurrentGunStats.Ammo <= 0
				Shooting = false
				if CurrentGunStats.Ammo <= 0 then
					CurrentGun.Handle.EmptyClip:Play()
				end
			elseif CurrentGunStats.FiringMode and CurrentGunStats.FiringMode[1] == "Burst" then
				Shooting = true
				local Num, Delta = CurrentGunStats.FiringMode.BurstSize, CurrentGunStats.FiringMode.TimeBetweenBullets
				for i = 1, Num do
					GunScript:FireGun()
					wait(0.01 + Delta)
					if CurrentGunStats.Ammo <= 0 then
						break
					end
				end
				LastShot = tick()
				Shooting = false
				if CurrentGunStats.Ammo <= 0 then
					CurrentGun.Handle.EmptyClip:Play()
				end
			else
				GunScript:FireGun()
			end
			Firing = false
			GunScript:UpdateUI()
			LastShot = tick()
		end
	elseif IO.KeyCode == Enum.KeyCode.LeftShift then
		if not Running and Equipped and not Reloading then
			Running = true
			Firing = false
			if not Crouching then
				PrevWalkspeed = Player.Character.Humanoid.WalkSpeed
			else
				Player.Character.Humanoid.WalkSpeed = Player.Character.Humanoid.WalkSpeed * 10
			end
			Crouching = false
			Crouch:Stop()
			Player.Character.Humanoid.CameraOffset = Vector3.new(0, 0, 0)
			Player.Character.Humanoid.WalkSpeed = Player.Character.Humanoid.WalkSpeed * (GunScript:Get("WalkSpeed") / 16)
			Run:Play()
			Hold:Stop()
		end
	elseif IO.KeyCode == Enum.KeyCode.R and not Reloading and not Running and CurrentGunStats.Ammo < CurrentGunStats.ClipSize then
		Reloading = true
		Firing = false
		wait()
		GunScript:Reload()
	elseif IO.KeyCode == Enum.KeyCode.C and not Running then
		Crouching = not Crouching
		if Crouching then
			Crouch:Play()
			PrevWalkspeed = Player.Character.Humanoid.WalkSpeed
			Player.Character.Humanoid.WalkSpeed = Player.Character.Humanoid.WalkSpeed / 10
			Player.Character.Humanoid.CameraOffset = Vector3.new(0, -1, 0)
		else
			Crouch:Stop()
			Player.Character.Humanoid.WalkSpeed = PrevWalkspeed
			Player.Character.Humanoid.CameraOffset = Vector3.new(0, 0, 0)
		end
	elseif IO.KeyCode == Enum.KeyCode.X then
		GunScript:ChangeCursor()
	end
end)
UserInputService.InputEnded:connect(function(IO, GP)
	if not Equipped or GP then
		return
	end
	if IO.UserInputType == Enum.UserInputType.MouseButton1 then
		Firing = false
	elseif IO.KeyCode == Enum.KeyCode.LeftShift and Running then
		Running = false
		Player.Character.Humanoid.WalkSpeed = PrevWalkspeed
		Run:Stop()
		Hold:Play()
		delay(0.1, function()
			Mouse.Icon = "rbxassetid://7380287"
		end)
	end
end)
local MurderEars = function()
	if script:FindFirstChild("Oof") then
		script.Oof:Play()
	end
	if script:FindFirstChild("ColorCorrection") then
		script.ColorCorrection:Clone().Parent = game.Lighting
	end
	if script:FindFirstChild("Bloom") then
		script.Bloom:Clone().Parent = game.Lighting
	end
	wait(3)
end
local ProcessChildren = function(Dir, Func)
	for _, Ch in pairs(Dir:GetChildren()) do
		Func(Ch)
	end
	Dir.ChildAdded:Connect(Func)
end
local function OnChar(Character)
	ProcessChildren(Player.Backpack, function(Child)
		if Child:IsA("Tool") then
			Child:GetPropertyChangedSignal("CanBeDropped"):Connect(function()
				Player:Kick([[

[SCPF]
You didn't drop your tools, but your mother dropped you on the head as a kid.]])
			end)
		end
	end)
	Character:WaitForChild("Humanoid"):UnequipTools()
	ProcessChildren(Character, function(Child)
		Hold, Crouch, Run, Reload = nil, nil, nil, nil
		if Child:IsA("Tool") then
			if Rank < 15 then
				Clicked()
			end
			if Child:FindFirstChild("Settings") then
				GunScript.Equip(Child)
			end
		end
	end)
	Character.ChildRemoved:connect(function(Child)
		if Child:IsA("Tool") and Child == CurrentGun then
			GunScript.Unequip()
		end
		if Child:IsA("Tool") and not Child.CanBeDropped and Child.Parent == workspace then
			MurderEars()
			Player:Kick("[SCPF] I want to shove sparklers into your eye sockets.")
		end
	end)
	if workspace.GunDebris:FindFirstChild(Player.Name) then
		workspace.GunDebris:FindFirstChild(Player.Name):Destroy()
	end
end
Player.CharacterAdded:Connect(OnChar)
Player.CharacterRemoving:Connect(function()
	if Player.Character and Player.Character:FindFirstChild("Humanoid") then
		Player.Character.Humanoid:UnequipTools()
	end
	if CurrentGun then
		GunScript.Unequip()
	end
end)
if Player.Character then
	OnChar(Player.Character)
end
local function EnforceSonar(Chr)
	local Conn, Conn1
	local Sonar = Chr:WaitForChild("Animate")
	if game:GetService("Players"):GetPlayerFromCharacter(Chr):GetRankInGroup(2694395) < 70 then
		Conn = Chr.ChildRemoved:Connect(function(Child)
			wait(0.2)
			if Child == Sonar and Chr:FindFirstChild("Humanoid") and Chr.Humanoid.Health > 0 then
				MurderEars()
				Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
			end
		end)
		Conn2 = Sonar:GetPropertyChangedSignal("Disabled"):Connect(function()
			wait(0.2)
			MurderEars()
			Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
		end)
		Conn1 = Chr:WaitForChild("Humanoid").Died:Connect(function()
			Conn:Disconnect()
			Conn1:Disconnect()
			Conn2:Disconnect()
			Conn, Conn1, Conn2 = nil, nil, nil
		end)
	end
end
for _, Box in pairs(CS:GetTagged(AmmoTag)) do
	local TouchPart = Box:WaitForChild("TouchPart", 5)
	if TouchPart then
		Box.TouchPart.Touched:Connect(GunScript.GetAmmo(Box))
	end
end
CS:GetInstanceAddedSignal(AmmoTag):Connect(function(Box)
	local TouchPart = Box:WaitForChild("TouchPart", 5)
	if TouchPart then
		Box.TouchPart.Touched:Connect(GunScript.GetAmmo(Box))
	end
end)
Player.CharacterAdded:Connect(EnforceSonar)
return nil
]]></ProtectedString></Properties></Item><Item class="ModuleScript" referent="RBX222"><Properties><string name="Name">Console</string><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

client = nil
cPcall = nil
Pcall = nil
Routine = nil
service = nil
gTable = nil
return function(data)
	local player = service.Players.LocalPlayer
	local playergui = player.PlayerGui
	local gui = script.Parent.Parent
	local frame = gui.Frame
	local text = gui.Frame.TextBox
	local scroll = gui.Frame.ScrollingFrame
	local players = gui.Frame.PlayerList
	local entry = gui.Entry
	local BindEvent = gTable.BindEvent
	local opened = false
	local scrolling = false
	local debounce = false
	local settings = client.Remote.Get("Setting", {
		"SplitKey",
		"ConsoleKeyCode",
		"BatchKey"
	})
	local splitKey = settings.SplitKey
	local consoleKey = settings.ConsoleKeyCode
	local batchKey = settings.BatchKey
	local commands = client.Remote.Get("FormattedCommands") or {}
	frame.Position = UDim2.new(0, 0, 0, -200)
	frame.Visible = false
	frame.Size = UDim2.new(1, 0, 0, 40)
	scroll.Visible = false
	if client.Variables.ConsoleOpen then
		if client.Variables.ChatEnabled then
			service.StarterGui:SetCoreGuiEnabled("Chat", true)
		end
		if client.Variables.PlayerListEnabled then
			service.StarterGui:SetCoreGuiEnabled("PlayerList", true)
		end
		if client.UI.Get("Notif") then
			client.UI.Get("Notif", nil, true).Object.LABEL.Visible = true
		end
		local scr = client.UI.Get("Chat", nil, true)
		if scr then
			scr.Object.Drag.Visible = true
		end
		local scr = client.UI.Get("PlayerList", nil, true)
		if scr then
			scr.Object.Drag.Visible = true
		end
		local scr = client.UI.Get("HintHolder", nil, true)
		if scr then
			scr.Object.Frame.Visible = true
		end
	end
	client.Variables.ChatEnabled = service.StarterGui:GetCoreGuiEnabled("Chat")
	client.Variables.PlayerListEnabled = service.StarterGui:GetCoreGuiEnabled("PlayerList")
	local function close()
		if gui:IsDescendantOf(game) and not debounce then
			debounce = true
			scroll:ClearAllChildren()
			scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
			scroll.ScrollingEnabled = false
			frame.Size = UDim2.new(1, 0, 0, 40)
			scroll.Visible = false
			players.Visible = false
			scrollOpen = false
			if client.Variables.ChatEnabled then
				service.StarterGui:SetCoreGuiEnabled("Chat", true)
			end
			if client.Variables.PlayerListEnabled then
				service.StarterGui:SetCoreGuiEnabled("PlayerList", true)
			end
			if client.UI.Get("Notif") then
				client.UI.Get("Notif", nil, true).Object.LABEL.Visible = true
			end
			local scr = client.UI.Get("Chat", nil, true)
			if scr then
				scr.Object.Drag.Visible = true
			end
			local scr = client.UI.Get("PlayerList", nil, true)
			if scr then
				scr.Object.Drag.Visible = true
			end
			local scr = client.UI.Get("HintHolder", nil, true)
			if scr then
				scr.Object.Frame.Visible = true
			end
			service.SafeTweenPos(frame, UDim2.new(0, 0, 0, -200), "Out", "Linear", 0.2, true)
			debounce = false
			opened = false
		end
	end
	local function open()
		if gui:IsDescendantOf(game) and not debounce then
			debounce = true
			client.Variables.ChatEnabled = service.StarterGui:GetCoreGuiEnabled("Chat")
			client.Variables.PlayerListEnabled = service.StarterGui:GetCoreGuiEnabled("PlayerList")
			service.StarterGui:SetCoreGuiEnabled("Chat", false)
			service.StarterGui:SetCoreGuiEnabled("PlayerList", false)
			scroll.ScrollingEnabled = true
			players.ScrollingEnabled = true
			if client.UI.Get("Notif") then
				client.UI.Get("Notif", nil, true).Object.LABEL.Visible = false
			end
			local scr = client.UI.Get("Chat", nil, true)
			if scr then
				scr.Object.Drag.Visible = false
			end
			local scr = client.UI.Get("PlayerList", nil, true)
			if scr then
				scr.Object.Drag.Visible = false
			end
			local scr = client.UI.Get("HintHolder", nil, true)
			if scr then
				scr.Object.Frame.Visible = false
			end
			frame.Size = UDim2.new(1, 0, 0, 40)
			scroll.Visible = false
			players.Visible = false
			scrollOpen = false
			text.Text = ""
			frame.Visible = true
			frame.Position = UDim2.new(0, 0, 0, 0)
			text:CaptureFocus()
			text.Text = ""
			wait()
			text.Text = ""
			debounce = false
			opened = true
		end
	end
	text.FocusLost:connect(function(enterPressed)
		if enterPressed then
			if text.Text ~= "" and string.len(text.Text) > 1 then
				client.Remote.Send("ProcessCommand", text.Text)
			end
			close()
		end
	end)
	text.Changed:connect(function(c)
		if c == "Text" and text.Text ~= "" and open then
			scroll:ClearAllChildren()
			players:ClearAllChildren()
			local nText = text.Text
			if string.match(nText, ".*" .. batchKey .. "([^']+)") then
				nText = string.match(nText, ".*" .. batchKey .. "([^']+)")
				nText = string.match(nText, "^%s*(.-)%s*$")
			end
			local pNum = 0
			local pMatch = string.match(nText, ".+" .. splitKey .. "(.*)$")
			for i, v in next, service.Players:GetChildren() do
				if pMatch and string.sub(string.lower(tostring(v)), 1, #pMatch) == string.lower(pMatch) or string.match(nText, splitKey .. "$") then
					local new = entry:Clone()
					new.Text = tostring(v)
					new.TextXAlignment = "Right"
					new.Visible = true
					new.Parent = players
					new.Position = UDim2.new(0, 0, 0, 20 * pNum)
					new.MouseButton1Down:connect(function()
						text.Text = text.Text .. tostring(v)
						text:CaptureFocus()
					end)
					pNum = pNum + 1
				end
			end
			players.CanvasSize = UDim2.new(0, 0, 0, pNum * 20)
			local num = 0
			for i, v in next, commands, nil do
				if string.sub(string.lower(v), 1, #nText) == string.lower(nText) or string.find(string.lower(v), string.match(string.lower(nText), "^(.-)" .. splitKey) or string.lower(nText)) then
					if not scrollOpen then
						frame.Size = UDim2.new(1, 0, 0, 140)
						scroll.Visible = true
						players.Visible = true
						scrollOpen = true
					end
					do
						local b = entry:clone()
						b.Visible = true
						b.Parent = scroll
						b.Text = v
						b.Position = UDim2.new(0, 0, 0, 20 * num)
						b.MouseButton1Down:connect(function()
							text.Text = b.Text
							text:CaptureFocus()
						end)
						num = num + 1
					end
				end
			end
			scroll.CanvasSize = UDim2.new(0, 0, 0, num * 20)
		elseif c == "Text" and text.Text == "" and opened then
			service.SafeTweenSize(frame, UDim2.new(1, 0, 0, 40), nil, nil, 0.3, nil, function()
				if scrollOpen then
					frame.Size = UDim2.new(1, 0, 0, 140)
				end
			end)
			scroll.Visible = false
			players.Visible = false
			scrollOpen = false
			scroll:ClearAllChildren()
			scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
		end
	end)
	BindEvent(service.UserInputService.InputBegan, function(InputObject)
		local textbox = service.UserInputService:GetFocusedTextBox()
		if not textbox and rawequal(InputObject.UserInputType, Enum.UserInputType.Keyboard) and InputObject.KeyCode.Name == (client.Variables.CustomConsoleKey or consoleKey) then
			if opened then
				close()
			else
				open()
			end
			client.Variables.ConsoleOpen = opened
		end
	end)
	gTable:Ready()
end
]]></ProtectedString></Properties></Item></Item><Item class="Folder" referent="RBX228"><Properties><string name="Name">Players</string></Properties><Item class="Folder" referent="RBX231"><Properties><string name="Name">brandonthekidRS123</string></Properties><Item class="Folder" referent="RBX234"><Properties><string name="Name">PlayerScripts</string></Properties><Item class="LocalScript" referent="RBX237"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local PlayerModule = require(script.Parent:WaitForChild("PlayerModule"))
]]></ProtectedString><string name="Name">PlayerScriptsLoader</string></Properties></Item><Item class="LocalScript" referent="RBX242"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

for i, v in pairs(script:children()) do
	require(v)
	print("[SCPF]", v.Name, "module loaded.")
end
]]></ProtectedString><string name="Name">Client</string></Properties><Item class="ModuleScript" referent="RBX246"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ControlPanel = {}
local Controls = workspace.Mechanics.Controls
local LightingRoot = workspace.Mechanics.Lights
local PowerEvent = game.ReplicatedStorage:WaitForChild("Events"):WaitForChild("TechEvent")
for _, Light in pairs(LightingRoot:GetDescendants()) do
	if Light:IsA("BasePart") then
		Light:Clone().Parent = Light.Parent
		Light:Destroy()
	end
end
ControlPanel.SectorDefaultLights = {
	S1 = {
		LightColor = BrickColor.new("Pearl").Color,
		SpotColor = BrickColor.new("Pearl").Color
	},
	S2 = {
		LightColor = BrickColor.new("Really blue").Color,
		SpotColor = Color3.fromRGB(175, 221, 255)
	},
	S3 = {
		LightColor = BrickColor.new("Beige").Color,
		SpotColor = BrickColor.new("Beige").Color
	},
	S4 = {
		LightColor = Color3.fromRGB(118, 78, 0),
		SpotColor = Color3.fromRGB(118, 53, 0)
	}
}
ControlPanel.SectorDefaultWalls = {
	Sector1A = {
		BColor3 = Color3.fromRGB(170, 85, 0),
		Material = "Neon"
	},
	Sector1B = {
		BColor3 = Color3.fromRGB(39, 70, 45),
		Material = "Neon"
	},
	Sector2 = {
		BColor3 = Color3.fromRGB(24, 5, 236),
		Material = "Neon"
	},
	Sector3 = {
		BColor3 = Color3.fromRGB(27, 42, 53),
		Material = "Neon"
	},
	Sector4 = {
		BColor3 = Color3.fromRGB(26, 11, 88),
		Material = "Neon"
	}
}
ControlPanel.SectorLightingEnabled = {
	S1 = true,
	S2 = true,
	S3 = true,
	S4 = true
}
ControlPanel.PowerLevel = 4
function ControlPanel:NewData(PowerLevel, SectorLightingEnabled)
	self.PowerLevel = PowerLevel
	self.SectorLightingEnabled = SectorLightingEnabled
end
function ControlPanel:SetSectorSituationLighting(Sector, Color, Material)
	for i, v in pairs(Sector:GetChildren()) do
		if v:IsA("BasePart") then
			v.Color = Color
			v.Material = Material
		end
	end
	if Sector.Name == "S2" then
		workspace.Map.Change.Color = Color
		workspace.Map.Change.Material = Material
	end
end
function ControlPanel:SetSectorLighting(Sector, Value, Brightness, OptionalColorA, OptionalColorB)
	for i, v in pairs(Sector:GetChildren()) do
		if v:IsA("BasePart") and v.Name == "Light" and v:FindFirstChild("SpotLight") then
			if not v:FindFirstChild("OriginalBrightness") then
				local OrigBright = Instance.new("NumberValue")
				OrigBright.Name = "OriginalBrightness"
				OrigBright.Value = v.SpotLight.Brightness
				OrigBright.Parent = v
			end
			local Baseline = v.OriginalBrightness.Value
			v.SpotLight.Enabled = OptionalColorA == nil and Value or OptionalColorA ~= nil
			v.SpotLight.Color = OptionalColorA ~= nil and OptionalColorA or self.SectorDefaultLights[Sector.Name].SpotColor
			v.SpotLight.Brightness = Baseline * Brightness
			v.Color = Value and self.SectorDefaultLights[Sector.Name].LightColor or OptionalColorB ~= nil and OptionalColorB or Color3.new(0, 0, 0)
			v.Material = (OptionalColorA ~= nil or Value) and Enum.Material.Neon.Value or Enum.Material.Glass.Value
		end
	end
end
local function OnLightChange(Type, Arg)
	if Type == "SectorLightingUpdate" then
		ControlPanel:SetSectorLighting(unpack(Arg))
	elseif Type == "SituationLightingUpdate" then
		ControlPanel:SetSectorSituationLighting(unpack(Arg))
	elseif Type == "LightingBulk" then
		ControlPanel:NewData(unpack(Arg))
	end
end
PowerEvent.OnClientEvent:Connect(OnLightChange)
PowerEvent:FireServer()
return function()
	return ControlPanel
end
]]></ProtectedString><string name="Name">TechSystems</string></Properties></Item><Item class="ModuleScript" referent="RBX251"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local RS = game:GetService("RunService")
local CS = game:GetService("CollectionService")
local UserInputService = game:GetService("UserInputService")
local Cam = workspace.CurrentCamera
local Player = game.Players.LocalPlayer
local UI = Player:WaitForChild("PlayerGui"):WaitForChild("AmmoGui")
local Mouse = Player:GetMouse()
local GunScript = {}
local GunRemote = game.ReplicatedStorage:WaitForChild("Events"):WaitForChild("GunEvent")
GunRemote.Name = game:GetService("HttpService"):GenerateGUID(false)
local CurrentGun
local CurrentGunStats = {}
local CachedGunStats = {}
local Hold, Crouch, Run, Reload, Pushback
local Encrypt_Key = 1
local PrevWalkspeed = 16
local CrosshairWidth = 15
local DotCursor = false
local LastShot = tick()
local Shooting = false
local AmmoSound = script:WaitForChild("AmmoPickup")
local AmmoFunc = workspace:WaitForChild("Mechanics"):WaitForChild("AmmoBoxes"):WaitForChild("GetAmmo")
local AmmoTag = "AmmoBox"
local HitSound = script:WaitForChild("HitSound")
local HeadShotSound = script:WaitForChild("HitHead")
local StatsEnabled = false
local NearShots, HitShots = 0, 0
local StatsDumpingFunction = game.ReplicatedStorage:WaitForChild("Functions"):WaitForChild("SendStats")
local Stats_Key = 1
local BulletSounds = {
	"rbxassetid://2303101209",
	"rbxassetid://142082170"
}
local LastSound = 1
local function SendStats(StatName, Data)
	Stats_Key = Stats_Key + math.pi / 5
end
local SCPF = 2694395
local Rank = Player:GetRankInGroup(SCPF)
local Clicks = 0
local Count = 0
local Step = 1
local function ResetCount()
	Step = Step + 1
	if Step % 30 == 0 then
		Step = 1
		Count = 0
	end
end
local function Clicked()
	Count = Count + 1
	if Count >= 6 then
		Player:Kick([[

[SCPF] An attempt was made.]])
	end
end
if Rank < 15 then
	RS:BindToRenderStep("YouTriedSploiterBoy", Enum.RenderPriority.Last.Value, ResetCount)
end
function GunScript:RotateKey()
	Encrypt_Key = Encrypt_Key + math.pi / 100
end
function GunScript:Set(StatName, Value)
	if CurrentGunStats and CurrentGunStats[StatName] then
		if CurrentGunStats[StatName] ~= CachedGunStats[StatName] then
			Player:Kick("[SCPF] Beware... God is watching you.")
		end
		CurrentGunStats[StatName] = Value
		CachedGunStats[StatName] = Value
	end
end
function GunScript:Get(StatName)
	if CurrentGunStats and CurrentGunStats[StatName] then
		if CurrentGunStats[StatName] ~= CachedGunStats[StatName] then
			Player:Kick("[SCPF] If only it was that easy.")
		end
		return CurrentGunStats[StatName]
	end
end
function GunScript:UpdateUI()
	if not CurrentGun then
		UI.Enabled = false
		return
	end
	UI.Enabled = true
	UI.Cursor.Ammo.Text = tostring(CurrentGunStats.Ammo)
	UI.Cursor.GunType.Text = tostring(CurrentGunStats.TotalAmmo)
end
function GunScript:Reload()
	CancelReload = false
	if self:Get("TotalAmmo") <= 0 then
		CurrentGun.Handle.EmptyClip:Play()
		Reloading = false
		return
	end
	if DotCursor then
		UI.Cursor.Ammo.Visible = true
		UI.Cursor.GunType.Visible = true
		delay(CurrentGunStats.ReloadTime + 1, function()
			if DotCursor then
				UI.Cursor.Ammo.Visible = false
				UI.Cursor.GunType.Visible = false
			end
		end)
	end
	local ShotgunLoad = CurrentGunStats.FiringMode and CurrentGunStats.FiringMode[1] == "Shotgun" or nil
	UI.Cursor.Ammo.Text = "RLD..."
	CurrentGun.Handle.ReloadSound:Play()
	Reload:Play()
	wait(self:Get("ReloadTime"))
	if not CancelReload then
		UI.Cursor.Ammo.Text = "RLD..."
		self:Set("TotalAmmo", self:Get("TotalAmmo") + self:Get("Ammo"))
		self:Set("Ammo", 0)
		if CurrentGunStats.TotalAmmo >= CurrentGunStats.ClipSize then
			self:Set("Ammo", self:Get("ClipSize"))
			self:Set("TotalAmmo", self:Get("TotalAmmo") - self:Get("ClipSize"))
		else
			self:Set("Ammo", self:Get("TotalAmmo"))
			self:Set("TotalAmmo", 0)
		end
		CurrentGun.Handle.ReloadSound:Stop()
		self:UpdateUI()
		Reloading = false
	else
		CurrentGun.Handle.ReloadSound:Stop()
		Reloading = false
		self:UpdateUI()
		CancelReload = false
	end
end
function GunScript:ChangeCursor()
	DotCursor = not DotCursor
	if UI:FindFirstChild("Cursor") then
		if DotCursor then
			UI.Cursor.Left.Visible = false
			UI.Cursor.Right.Visible = false
			UI.Cursor.Top.Visible = false
			UI.Cursor.Bottom.Visible = false
			UI.Cursor.Ammo.Visible = false
			UI.Cursor.GunType.Visible = false
			UI.Cursor.Dot.Visible = true
		else
			UI.Cursor.Left.Visible = true
			UI.Cursor.Right.Visible = true
			UI.Cursor.Top.Visible = true
			UI.Cursor.Bottom.Visible = true
			UI.Cursor.Ammo.Visible = true
			UI.Cursor.GunType.Visible = true
			UI.Cursor.Dot.Visible = false
		end
	end
end
local DISTORT_STUDS = 100
local DistortVector = function(D, SpreadX, SpreadY, SpreadZ)
	return Vector3.new(D * SpreadX, D * SpreadY, D * SpreadZ) * (math.random() > 0.5 and -1 or 1)
end
function FireGun(NewRay, Sender, NotPlayer)
	local Part, Pos = workspace:FindPartOnRayWithIgnoreList(NewRay, {
		Sender.Character,
		workspace.GunDebris,
		workspace.Map.GunsIgnore,
		workspace.Doors
	}, false, true)
	return Part, Pos
end
function GunScript:FireGun()
	if Player.Character.Humanoid.Health <= 0 then
		return
	end
	self:Set("Ammo", self:Get("Ammo") - 1)
	local Damage = math.random(self:Get("minDamage"), self:Get("maxDamage"))
	if CrosshairWidth < 80 then
		CrosshairWidth = CrosshairWidth + math.floor(Damage / CurrentGunStats.RecoilDivisor)
	end
	GunScript:UpdateUI()
	Pushback:Play()
	local ShotsFired = {}
	local NumShots = 1
	if CurrentGunStats.FiringMode then
		NumShots = CurrentGunStats.FiringMode.NumBullets or 1
	end
	for i = 1, NumShots do
		local Distortion = DistortVector(CurrentGunStats.Distort or DISTORT_STUDS, (math.random() * 2 - 1) * (CrosshairWidth + (CurrentGunStats.InherentSpread or 0) - 15) / 15, (math.random() * 2 - 1) * (CrosshairWidth + (CurrentGunStats.InherentSpread or 0) - 15) / 15, (math.random() * 2 - 1) * (CrosshairWidth + (CurrentGunStats.InherentSpread or 0) - 15) / 15)
		local NewRay = Ray.new(CurrentGun.BPoint.Position, (Mouse.Hit.p - CurrentGun.BPoint.Position) * 500 + Distortion)
		local Part, Pos = FireGun(NewRay, game.Players.LocalPlayer)
		if Part and Pos then
			local DoDamage = false
			local Chr
			if Part.Parent and Part.Parent:FindFirstChild("Humanoid") then
				Chr = Part.Parent
			else
				for i, v in pairs(game.Players:GetPlayers()) do
					if Part:IsDescendantOf(v.Character) then
						Chr = v.Character
						break
					end
				end
			end
			if Chr then
				local Critical = Chr.Humanoid.Health - Damage <= 0 or Part.Parent == Chr and Chr.Humanoid:GetLimb(Part) == Enum.Limb.Head or Part:FindFirstChild("HatAttachment") or Part:FindFirstAncestor("Helmet")
				UI.Hitmarker.Visible = true
				UI.Hitmarker.ImageColor3 = Critical and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
				HitSound:Play()
				if Critical then
					HeadShotSound:Play()
				end
				delay(0.05, function()
					UI.Hitmarker.Visible = false
				end)
				UI.Hitmarker.Position = UDim2.new(0, Mouse.X - 20, 0, Mouse.Y - 20)
			end
		end
		if DotCursor then
			UI.Cursor.Ammo.Visible = true
			local TBS = self:Get("TimeBetweenShots")
			delay(TBS, function()
				if DotCursor and not Reloading then
					UI.Cursor.Ammo.Visible = false
				end
			end)
		end
		table.insert(ShotsFired, {
			Part,
			Pos,
			NewRay
		})
	end
	GunRemote:FireServer(Encrypt_Key, CurrentGun, ShotsFired)
	self:RotateKey()
end
function GunScript.Equip(Gun)
	Player = game.Players.LocalPlayer
	CurrentGun = Gun
	UI = Player:WaitForChild("PlayerGui"):WaitForChild("AmmoGui")
	CurrentGunStats = require(Gun:FindFirstChild("Settings"))
	CurrentGunStats.avgDamage = (CurrentGunStats.minDamage + CurrentGunStats.maxDamage) / 2
	CurrentGunStats.RecoilDivisor = CurrentGunStats.RecoilDivisor or 3
	for k, v in pairs(CurrentGunStats) do
		CachedGunStats[k] = v
	end
	if not (Hold and Crouch) or not Run then
		Hold, Crouch, Run, Reload, Pushback = Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Idle")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("CrouchH")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Running")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Reload")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Pushback"))
	end
	GunScript:UpdateUI()
	Hold:Play()
	Equipped = true
	UI.Enabled = true
	UserInputService.MouseIconEnabled = false
end
function GunScript.Unequip()
	UI.Enabled = false
	UserInputService.MouseIconEnabled = true
	Hold:Stop()
	Run:Stop()
	Crouch:Stop()
	Equipped = false
	Player.Character.Humanoid.WalkSpeed = PrevWalkspeed
	Player.Character.Humanoid.CameraOffset = Vector3.new(0, 0, 0)
	Reloading, Firing, Running, Crouching = false, false, false, false
	Mouse.Icon = ""
	CancelReload = true
	CurrentGun = nil
	CurrentGunStats = nil
end
function GunScript.GetAmmo(Box)
	local Debounce = true
	return function(Part)
		if not Part:IsDescendantOf(Player.Character) then
			return
		end
		if not CurrentGunStats then
			return
		end
		if Debounce then
			Debounce = false
			pcall(function()
				if CurrentGunStats and CurrentGunStats.TotalAmmo and CurrentGunStats.AmmoCapacity and CurrentGunStats.TotalAmmo < CurrentGunStats.AmmoCapacity then
					local Difference = (CurrentGunStats.AmmoCapacity - CurrentGunStats.TotalAmmo) / CurrentGunStats.AmmoCapacity
					local Consume = AmmoFunc:InvokeServer(Box, Difference)
					GunScript:Set("TotalAmmo", CurrentGunStats.TotalAmmo + math.min(math.ceil(CurrentGunStats.AmmoCapacity * Consume), CurrentGunStats.AmmoCapacity))
					GunScript:UpdateUI()
					AmmoSound:Play()
				end
			end)
			wait(1)
			Debounce = true
		end
	end
end
local function OnStep()
	if not Equipped then
		return
	end
	local X, Y = Mouse.X, Mouse.Y
	if UI:FindFirstChild("Cursor") then
		UI.Cursor.Position = UDim2.new(0, X, 0, Y)
	end
end
local function ShrinkCrosshair()
	if not Equipped then
		return
	end
	if CrosshairWidth > 15 then
		CrosshairWidth = CrosshairWidth * 0.975
	else
		CrosshairWidth = 15
	end
	if UI:FindFirstChild("Cursor") then
		UI.Cursor.Left.Position = UDim2.new(0, -1 * CrosshairWidth, 0, 0)
		UI.Cursor.Right.Position = UDim2.new(0, CrosshairWidth, 0, 0)
		UI.Cursor.Top.Position = UDim2.new(0, 0, 0, -1 * CrosshairWidth)
		UI.Cursor.Bottom.Position = UDim2.new(0, 0, 0, CrosshairWidth)
	end
end
RS:BindToRenderStep("GunMouseMove", Enum.RenderPriority.Character.Value - 1, OnStep)
RS.Heartbeat:Connect(ShrinkCrosshair)
UserInputService.InputBegan:connect(function(IO, GP)
	if not Equipped or GP then
		return
	end
	if IO.UserInputType == Enum.UserInputType.MouseButton1 then
		if CurrentGunStats.Ammo <= 0 then
			CurrentGun.Handle.EmptyClip:Play()
		end
		if tick() - LastShot >= 0.01 + CurrentGunStats.TimeBetweenShots and CurrentGunStats.Ammo > 0 and not Firing and not Shooting and not Reloading and not Running then
			if CurrentGunStats.RapidFire and (not CurrentGunStats.FiringMode or CurrentGunStats.FiringMode[1] == "Shotgun") and not Firing then
				Firing = true
				Shooting = true
				repeat
					GunScript:FireGun()
					LastShot = tick()
					wait(0.1 + CurrentGunStats.TimeBetweenShots)
				until not Firing or CurrentGunStats.Ammo <= 0
				Shooting = false
				if CurrentGunStats.Ammo <= 0 then
					CurrentGun.Handle.EmptyClip:Play()
				end
			elseif CurrentGunStats.FiringMode and CurrentGunStats.FiringMode[1] == "Burst" then
				Shooting = true
				local Num, Delta = CurrentGunStats.FiringMode.BurstSize, CurrentGunStats.FiringMode.TimeBetweenBullets
				for i = 1, Num do
					GunScript:FireGun()
					wait(0.01 + Delta)
					if CurrentGunStats.Ammo <= 0 then
						break
					end
				end
				LastShot = tick()
				Shooting = false
				if CurrentGunStats.Ammo <= 0 then
					CurrentGun.Handle.EmptyClip:Play()
				end
			else
				GunScript:FireGun()
			end
			Firing = false
			GunScript:UpdateUI()
			LastShot = tick()
		end
	elseif IO.KeyCode == Enum.KeyCode.LeftShift then
		if not Running and Equipped and not Reloading then
			Running = true
			Firing = false
			if not Crouching then
				PrevWalkspeed = Player.Character.Humanoid.WalkSpeed
			else
				Player.Character.Humanoid.WalkSpeed = Player.Character.Humanoid.WalkSpeed * 10
			end
			Crouching = false
			Crouch:Stop()
			Player.Character.Humanoid.CameraOffset = Vector3.new(0, 0, 0)
			Player.Character.Humanoid.WalkSpeed = Player.Character.Humanoid.WalkSpeed * (GunScript:Get("WalkSpeed") / 16)
			Run:Play()
			Hold:Stop()
		end
	elseif IO.KeyCode == Enum.KeyCode.R and not Reloading and not Running and CurrentGunStats.Ammo < CurrentGunStats.ClipSize then
		Reloading = true
		Firing = false
		wait()
		GunScript:Reload()
	elseif IO.KeyCode == Enum.KeyCode.C and not Running then
		Crouching = not Crouching
		if Crouching then
			Crouch:Play()
			PrevWalkspeed = Player.Character.Humanoid.WalkSpeed
			Player.Character.Humanoid.WalkSpeed = Player.Character.Humanoid.WalkSpeed / 10
			Player.Character.Humanoid.CameraOffset = Vector3.new(0, -1, 0)
		else
			Crouch:Stop()
			Player.Character.Humanoid.WalkSpeed = PrevWalkspeed
			Player.Character.Humanoid.CameraOffset = Vector3.new(0, 0, 0)
		end
	elseif IO.KeyCode == Enum.KeyCode.X then
		GunScript:ChangeCursor()
	end
end)
UserInputService.InputEnded:connect(function(IO, GP)
	if not Equipped or GP then
		return
	end
	if IO.UserInputType == Enum.UserInputType.MouseButton1 then
		Firing = false
	elseif IO.KeyCode == Enum.KeyCode.LeftShift and Running then
		Running = false
		Player.Character.Humanoid.WalkSpeed = PrevWalkspeed
		Run:Stop()
		Hold:Play()
		delay(0.1, function()
			Mouse.Icon = "rbxassetid://7380287"
		end)
	end
end)
local MurderEars = function()
	if script:FindFirstChild("Oof") then
		script.Oof:Play()
	end
	if script:FindFirstChild("ColorCorrection") then
		script.ColorCorrection:Clone().Parent = game.Lighting
	end
	if script:FindFirstChild("Bloom") then
		script.Bloom:Clone().Parent = game.Lighting
	end
	wait(3)
end
local ProcessChildren = function(Dir, Func)
	for _, Ch in pairs(Dir:GetChildren()) do
		Func(Ch)
	end
	Dir.ChildAdded:Connect(Func)
end
local function OnChar(Character)
	ProcessChildren(Player.Backpack, function(Child)
		if Child:IsA("Tool") then
			Child:GetPropertyChangedSignal("CanBeDropped"):Connect(function()
				Player:Kick([[

[SCPF]
You didn't drop your tools, but your mother dropped you on the head as a kid.]])
			end)
		end
	end)
	Character:WaitForChild("Humanoid"):UnequipTools()
	ProcessChildren(Character, function(Child)
		Hold, Crouch, Run, Reload = nil, nil, nil, nil
		if Child:IsA("Tool") then
			if Rank < 15 then
				Clicked()
			end
			if Child:FindFirstChild("Settings") then
				GunScript.Equip(Child)
			end
		end
	end)
	Character.ChildRemoved:connect(function(Child)
		if Child:IsA("Tool") and Child == CurrentGun then
			GunScript.Unequip()
		end
		if Child:IsA("Tool") and not Child.CanBeDropped and Child.Parent == workspace then
			MurderEars()
			Player:Kick("[SCPF] I want to shove sparklers into your eye sockets.")
		end
	end)
	if workspace.GunDebris:FindFirstChild(Player.Name) then
		workspace.GunDebris:FindFirstChild(Player.Name):Destroy()
	end
end
Player.CharacterAdded:Connect(OnChar)
Player.CharacterRemoving:Connect(function()
	if Player.Character and Player.Character:FindFirstChild("Humanoid") then
		Player.Character.Humanoid:UnequipTools()
	end
	if CurrentGun then
		GunScript.Unequip()
	end
end)
if Player.Character then
	OnChar(Player.Character)
end
local function EnforceSonar(Chr)
	local Conn, Conn1
	local Sonar = Chr:WaitForChild("Animate")
	if game:GetService("Players"):GetPlayerFromCharacter(Chr):GetRankInGroup(2694395) < 70 then
		Conn = Chr.ChildRemoved:Connect(function(Child)
			wait(0.2)
			if Child == Sonar and Chr:FindFirstChild("Humanoid") and Chr.Humanoid.Health > 0 then
				MurderEars()
				Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
			end
		end)
		Conn2 = Sonar:GetPropertyChangedSignal("Disabled"):Connect(function()
			wait(0.2)
			MurderEars()
			Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
		end)
		Conn1 = Chr:WaitForChild("Humanoid").Died:Connect(function()
			Conn:Disconnect()
			Conn1:Disconnect()
			Conn2:Disconnect()
			Conn, Conn1, Conn2 = nil, nil, nil
		end)
	end
end
for _, Box in pairs(CS:GetTagged(AmmoTag)) do
	local TouchPart = Box:WaitForChild("TouchPart", 5)
	if TouchPart then
		Box.TouchPart.Touched:Connect(GunScript.GetAmmo(Box))
	end
end
CS:GetInstanceAddedSignal(AmmoTag):Connect(function(Box)
	local TouchPart = Box:WaitForChild("TouchPart", 5)
	if TouchPart then
		Box.TouchPart.Touched:Connect(GunScript.GetAmmo(Box))
	end
end)
Player.CharacterAdded:Connect(EnforceSonar)
return nil
]]></ProtectedString><string name="Name">Guns</string></Properties></Item><Item class="ModuleScript" referent="RBX256"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local StarterGui = game:GetService("StarterGui")
local function Notify(Title, Text, Icon, Duration)
	StarterGui:SetCore("SendNotification", {
		Title = Title or "SCPF",
		Text = Text or "_CONTENT",
		Icon = Icon or nil,
		Duration = Duration or 5
	})
end
game:GetService("Players").PlayerAdded:connect(function(Player)
	if Player:GetRankInGroup(2694395) >= 50 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(2694395))
		Notify("SCPF HR Joined", Message, "rbxassetid://764606705", 8)
	end
	if Player:GetRankInGroup(2755639) >= 40 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(2755639))
		Notify("CI HR Joined", Message, "rbxassetid://1056285476", 8)
	end
	if Player:GetRankInGroup(3292065) >= 100 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(3292065))
		Notify("TSH HR Joined", Message, "rbxassetid://1238401889", 8)
	end
	if Player:GetRankInGroup(2896818) >= 13 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(2896818))
		Notify("GOC HR Joined", Message, "rbxassetid://273197914", 8)
	end
end)
return function()
	return Notify
end
]]></ProtectedString><string name="Name">Notifications</string></Properties></Item><Item class="ModuleScript" referent="RBX261"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local CS = game:GetService("CollectionService")
local Plr = game.Players.LocalPlayer
local ZoneEvent = game.ReplicatedStorage:WaitForChild("Events"):WaitForChild("ExclusionEvent")
local Debounce = function(Func, Time)
	local DB = true
	return function(...)
		if DB then
			DB = false
			Func(...)
			wait(Time)
			DB = true
		end
	end
end
local function FireOnTouch(Part)
	local Bool = Part.Parent.Parent:FindFirstChildWhichIsA("BoolValue")
	local In = Part.Parent.Name == "In"
	Part.Touched:Connect(Debounce(function(Brik)
		local AlreadyTagged = CS:HasTag(Plr.Character, Part.Parent.Parent.Name)
		if not In and not not AlreadyTagged and (not Bool or Bool.Value) and Brik:IsDescendantOf(Plr.Character) then
			ZoneEvent:FireServer(Part)
		end
	end, 1))
end
local ProcessChildren = function(Dir, Func)
	for _, Ch in pairs(Dir:GetChildren()) do
		Func(Ch)
	end
	Dir.ChildAdded:Connect(Func)
end
local function ProcessZone(Zone)
	local InDir, OutDir = Zone:WaitForChild("In"), Zone:WaitForChild("Out")
	ProcessChildren(InDir, FireOnTouch)
	ProcessChildren(OutDir, FireOnTouch)
end
ProcessChildren(workspace:WaitForChild("ExclusionZones"), ProcessZone)
return function()
end
]]></ProtectedString><string name="Name">ExclusionZones</string></Properties></Item><Item class="ModuleScript" referent="RBX266"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Event = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("DoorEvent")
local TweenService = game:GetService("TweenService")
local LocalDoorState = {}
local Player = game.Players.LocalPlayer
local DoorContainer = Instance.new("Folder")
DoorContainer.Name = "Doors"
DoorContainer.Parent = workspace.CurrentCamera
local Backpack
function GetDoorType(Door)
	local DoorType = "None"
	if Door:FindFirstChild("Button") and Door:FindFirstChild("Door1"):FindFirstChild("Special Part") then
		DoorType = "DoubleDoor"
	end
	if Door:FindFirstChild("Scripted") then
		if Door:FindFirstChild("Scripted"):FindFirstChild("unixyoutool") then
			DoorType = "BlastDoor"
		elseif Door:FindFirstChild("Scripted"):FindFirstChild("LeftDoor") then
			DoorType = "DoubleGate"
		elseif Door:FindFirstChild("Scripted"):FindFirstChild("Door") then
			DoorType = "CardDoor"
		end
	end
	return DoorType
end
function CardDoorRun(Door)
	if LocalDoorState[Door].State then
		LocalDoorState[Door].OutTween:Play()
		LocalDoorState[Door].LocalDoor.AccessGranted:Play()
		LocalDoorState[Door].LocalDoor.DoorOpen:Play()
	else
		LocalDoorState[Door].InTween:Play()
		LocalDoorState[Door].LocalDoor.DoorClose:Play()
	end
end
function DoubleGateRun(Door)
	if LocalDoorState[Door].State then
		LocalDoorState[Door].OutTweenA:Play()
		LocalDoorState[Door].OutTweenB:Play()
		LocalDoorState[Door].LocalDoorA.AccessGranted:Play()
		LocalDoorState[Door].LocalDoorA.DoorOpen:Play()
	else
		LocalDoorState[Door].InTweenA:Play()
		LocalDoorState[Door].InTweenB:Play()
		LocalDoorState[Door].LocalDoorA.DoorClose:Play()
	end
end
function BlastDoorRun(Door)
	if LocalDoorState[Door].State then
		LocalDoorState[Door].OutTweenA:Play()
		LocalDoorState[Door].OutTweenB:Play()
		LocalDoorState[Door].LocalDoorA.Alarm:Play()
		LocalDoorState[Door].LocalDoorA.AccessGranted:Play()
		LocalDoorState[Door].LocalDoorA.DoorOpen:Play()
	else
		LocalDoorState[Door].InTweenA:Play()
		LocalDoorState[Door].InTweenB:Play()
		LocalDoorState[Door].LocalDoorA.Alarm:Play()
		LocalDoorState[Door].LocalDoorA.DoorClose:Play()
	end
end
function HandleLocalDoor(Door)
	local Type = GetDoorType(Door.Object)
	if Type == "None" then
		return
	elseif Type == "CardDoor" then
		local LocalDoor = Door.Object.Scripted.Door:Clone()
		LocalDoor.Parent = DoorContainer
		LocalDoor.Transparency = 0
		LocalDoor.CanCollide = true
		Door.Object.Scripted.Door:Destroy()
		LocalDoorState[Door.Name].LocalDoor = LocalDoor
		local OutTween = TweenService:Create(Door.LocalDoor, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoor.CFrame * CFrame.new(0, 0, -5)
		})
		local InTween = TweenService:Create(Door.LocalDoor, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoor.CFrame
		})
		LocalDoorState[Door.Name].InTween = InTween
		LocalDoorState[Door.Name].OutTween = OutTween
		Door.Moving = false
		Door.Object:WaitForChild("ObjectState").Changed:Connect(function()
			LocalDoorState[Door.Name].State = Door.Object:WaitForChild("ObjectState").Value
			CardDoorRun(Door.Name)
		end)
		for i, v in pairs(Door.Object.Scripted.Readers:GetChildren()) do
			v.Touched:connect(function(Hit)
				if Hit.Parent:IsA("Tool") and Hit.Parent:IsDescendantOf(game.Players.LocalPlayer.Character) and (Door.Object.Allowed:FindFirstChild(Hit.Parent.Name) and Door.Object.Allowed:FindFirstChild(Hit.Parent.Name).Value or Hit.Parent.Name == "[SCP] Card-Omni") then
					if not Door.Moving then
						Door.Moving = true
						for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
							Door.BrickColor = BrickColor.new("Lime green")
							delay(1, function()
								Door.BrickColor = BrickColor.new("Institutional white")
							end)
						end
						Event:FireServer("ToggleCardDoor", Door.Name, Hit.Parent)
						wait(1)
						Door.Moving = false
					end
				elseif Hit.Parent.Name:match("[SCP]") or Hit.Parent.Name:match("Gamepass") then
					for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
						Door.BrickColor = BrickColor.new("Really red")
						delay(1, function()
							Door.BrickColor = BrickColor.new("Institutional white")
						end)
					end
				end
			end)
		end
	elseif Type == "DoubleGate" then
		local LocalDoorA = Door.Object.Scripted.LeftDoor:Clone()
		LocalDoorA.Parent = DoorContainer
		LocalDoorA.Transparency = 0
		LocalDoorA.CanCollide = true
		LocalDoorState[Door.Name].LocalDoorA = LocalDoorA
		local LocalDoorB = Door.Object.Scripted.RightDoor:Clone()
		LocalDoorB.Parent = DoorContainer
		LocalDoorB.Transparency = 0
		LocalDoorB.CanCollide = true
		Door.Object.Scripted.LeftDoor:Destroy()
		Door.Object.Scripted.RightDoor:Destroy()
		LocalDoorState[Door.Name].LocalDoorB = LocalDoorB
		local OutTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorA.CFrame * CFrame.new(0, 0, Door.LocalDoorA.Size.Z)
		})
		local InTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorA.CFrame
		})
		local OutTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorB.CFrame * CFrame.new(0, 0, Door.LocalDoorA.Size.Z)
		})
		local InTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorB.CFrame
		})
		LocalDoorState[Door.Name].InTweenA = InTweenA
		LocalDoorState[Door.Name].InTweenB = InTweenB
		LocalDoorState[Door.Name].OutTweenA = OutTweenA
		LocalDoorState[Door.Name].OutTweenB = OutTweenB
		Door.Moving = false
		Door.Object:WaitForChild("ObjectState").Changed:Connect(function()
			LocalDoorState[Door.Name].State = Door.Object:WaitForChild("ObjectState").Value
			DoubleGateRun(Door.Name)
		end)
		for i, v in pairs(Door.Object.Scripted.Readers:GetChildren()) do
			v.Touched:connect(function(Hit)
				if Hit.Parent:IsA("Tool") and Hit.Parent:IsDescendantOf(game.Players.LocalPlayer.Character) and (Door.Object.Allowed:FindFirstChild(Hit.Parent.Name) and Door.Object.Allowed:FindFirstChild(Hit.Parent.Name).Value or Hit.Parent.Name == "[SCP] Card-Omni") then
					if not Door.Moving then
						Door.Moving = true
						for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
							Door.BrickColor = BrickColor.new("Lime green")
							delay(1, function()
								Door.BrickColor = BrickColor.new("Institutional white")
							end)
						end
						Event:FireServer("ToggleDoubleGate", Door.Name, Hit.Parent)
						wait(1)
						Door.Moving = false
					end
				elseif Hit.Parent.Name:match("[SCP]") or Hit.Parent.Name:match("Gamepass") then
					for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
						Door.BrickColor = BrickColor.new("Really red")
						delay(1, function()
							Door.BrickColor = BrickColor.new("Institutional white")
						end)
					end
				end
			end)
		end
	elseif Type == "BlastDoor" then
		local LocalDoorA = Door.Object.Scripted.LeftDoor:Clone()
		LocalDoorA.Parent = DoorContainer
		LocalDoorA.Transparency = 0
		LocalDoorA.CanCollide = true
		LocalDoorState[Door.Name].LocalDoorA = LocalDoorA
		local LocalDoorB = Door.Object.Scripted.RightDoor:Clone()
		LocalDoorB.Parent = DoorContainer
		LocalDoorB.Transparency = 0
		LocalDoorB.CanCollide = true
		Door.Object.Scripted.LeftDoor:Destroy()
		Door.Object.Scripted.RightDoor:Destroy()
		LocalDoorState[Door.Name].LocalDoorB = LocalDoorB
		local Closed = Door.Object:WaitForChild("ObjectState").Value
		local OpenA = Closed and {
			CFrame = Door.LocalDoorA.CFrame * CFrame.new(0, 0, -Door.LocalDoorA.Size.Z)
		} or {
			CFrame = Door.LocalDoorA.CFrame
		}
		local OpenB = Closed and {
			CFrame = Door.LocalDoorB.CFrame * CFrame.new(0, 0, -Door.LocalDoorB.Size.Z)
		} or {
			CFrame = Door.LocalDoorB.CFrame
		}
		local ClosedA = Closed and {
			CFrame = Door.LocalDoorA.CFrame
		} or {
			CFrame = Door.LocalDoorA.CFrame * CFrame.new(0, 0, Door.LocalDoorA.Size.Z)
		}
		local ClosedB = Closed and {
			CFrame = Door.LocalDoorB.CFrame
		} or {
			CFrame = Door.LocalDoorB.CFrame * CFrame.new(0, 0, Door.LocalDoorB.Size.Z)
		}
		local OutTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), ClosedA)
		local InTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), OpenA)
		local OutTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), ClosedB)
		local InTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), OpenB)
		LocalDoorState[Door.Name].InTweenA = InTweenA
		LocalDoorState[Door.Name].InTweenB = InTweenB
		LocalDoorState[Door.Name].OutTweenA = OutTweenA
		LocalDoorState[Door.Name].OutTweenB = OutTweenB
		Door.Moving = false
		Door.Object:WaitForChild("ObjectState").Changed:Connect(function()
			LocalDoorState[Door.Name].State = Door.Object:WaitForChild("ObjectState").Value
			BlastDoorRun(Door.Name)
		end)
		if Door.Object.Scripted:FindFirstChild("Readers") then
			for i, v in pairs(Door.Object.Scripted.Readers:GetChildren()) do
				v.Touched:connect(function(Hit)
					if Hit.Parent:IsA("Tool") and Hit.Parent:IsDescendantOf(game.Players.LocalPlayer.Character) and (Door.Object.Allowed:FindFirstChild(Hit.Parent.Name) and Door.Object.Allowed:FindFirstChild(Hit.Parent.Name).Value or Hit.Parent.Name == "[SCP] Card-Omni") then
						if not Door.Moving then
							Door.Moving = true
							for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
								Door.BrickColor = BrickColor.new("Lime green")
								delay(1, function()
									Door.BrickColor = BrickColor.new("Institutional white")
								end)
							end
							Event:FireServer("ToggleBlastDoor", Door.Name, Hit.Parent)
							wait(1)
							Door.Moving = false
						end
					elseif Hit.Parent.Name:match("[SCP]") or Hit.Parent.Name:match("Gamepass") then
						for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
							Door.BrickColor = BrickColor.new("Really red")
							delay(1, function()
								Door.BrickColor = BrickColor.new("Institutional white")
							end)
						end
					end
				end)
			end
		end
	end
end
Event:FireServer("GainUpdateBatch")
Event.OnClientEvent:connect(function(Type, Door, State)
	if Type == "SingleDoor" then
		LocalDoorState[Door].State = State
		CardDoorRun(Door)
	elseif Type == "DoubleGate" then
		LocalDoorState[Door].State = State
		DoubleGateRun(Door)
	elseif Type == "BlastDoor" then
		print("BlastDoor")
		LocalDoorState[Door].State = State
		BlastDoorRun(Door)
	elseif Type == "Bulk" then
		LocalDoorState = Door
		for i, v in pairs(LocalDoorState) do
			HandleLocalDoor(v)
		end
	end
end)
Backpack = Player:FindFirstChildWhichIsA("Backpack")
local MurderEars = function()
	if script:FindFirstChild("Oof") then
		script.Oof:Play()
	end
	if script:FindFirstChild("ColorCorrection") then
		script.ColorCorrection:Clone().Parent = game.Lighting
	end
	if script:FindFirstChild("Bloom") then
		script.Bloom:Clone().Parent = game.Lighting
	end
	wait(3)
end
local function PreventToolNameChange(Child)
	local NameSignal = Child:GetPropertyChangedSignal("Name")
	local Conn
	Conn = NameSignal:Connect(function()
		print("you know i had to do it to em")
		Conn:Disconnect()
		Conn = nil
		MurderEars()
		game.Players.LocalPlayer:Kick([[

[SCPF] It's time to stop.]])
	end)
end
if Backpack then
	for _, Child in pairs(Backpack:GetChildren()) do
		PreventToolNameChange(Child)
	end
end
Player.ChildAdded:Connect(function(Child)
	if Child:IsA("Backpack") then
		Backpack = Child
		for _, Chld in pairs(Backpack:GetChildren()) do
			PreventToolNameChange(Chld)
		end
		Child.ChildAdded:connect(PreventToolNameChange)
	end
end)
local function EnforceSonar(Chr)
	local Conn, Conn1
	local Sonar = Chr:WaitForChild("Animate")
	if game:GetService("Players"):GetPlayerFromCharacter(Chr):GetRankInGroup(2694395) < 70 then
		Conn = Chr.ChildRemoved:Connect(function(Child)
			wait(0.2)
			if Child == Sonar and Chr:FindFirstChild("Humanoid") and Chr.Humanoid.Health > 0 then
				MurderEars()
				Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
			end
		end)
		Conn2 = Sonar:GetPropertyChangedSignal("Disabled"):Connect(function()
			wait(0.2)
			MurderEars()
			Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
		end)
		Conn1 = Chr:WaitForChild("Humanoid").Died:Connect(function()
			Conn:Disconnect()
			Conn1:Disconnect()
			Conn2:Disconnect()
			Conn, Conn1, Conn2 = nil, nil, nil
		end)
	end
end
local function IHateYou()
	Player:Kick([[
[SCPF]
WOAH, there's Wi-Fi on the short bus?]])
end
DoorContainer.DescendantRemoving:Connect(IHateYou)
DoorContainer:GetPropertyChangedSignal("Parent"):Connect(IHateYou)
local AllowedGuis = {
	"CoreUI",
	"RobloxGui",
	"ControlGui",
	"ShopGui",
	"CoffeeMachineDrink",
	"Model Resize GUI",
	"ChoiceUI",
	"Hitmarker",
	"Blind",
	"DefibCharge",
	"TokenMenu",
	"Menu",
	"AmmoGui",
	"ActivityLog",
	"FlashGUI",
	"NV",
	"UglySuitChoice",
	"VisionControls",
	"CustomCharGui",
	"LoadoutGui",
	"BriefingGui",
	"PhysicsAnalyzerGui",
	"CommandGui",
	"SCP061Gui",
	"Radio",
	"Repairing",
	"ScopeGui",
	"362Gui",
	"MusicPanel_DebugBuild",
	"Command",
	"Blindness",
	"WeldingGui",
	"MenuUI"
}
Player.CharacterAdded:Connect(EnforceSonar)
return {}
]]></ProtectedString><string name="Name">Doors</string></Properties></Item></Item><Item class="ModuleScript" referent="RBX272"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local PlayerModule = {}
PlayerModule.__index = PlayerModule
function PlayerModule.new()
	local self = setmetatable({}, PlayerModule)
	self.cameras = require(script:WaitForChild("CameraModule"))
	self.controls = require(script:WaitForChild("ControlModule"))
	return self
end
function PlayerModule:GetCameras()
	return self.cameras
end
function PlayerModule:GetControls()
	return self.controls
end
function PlayerModule:GetClickToMoveController()
	return self.controls:GetClickToMoveController()
end
return PlayerModule.new()
]]></ProtectedString><string name="Name">PlayerModule</string></Properties><Item class="ModuleScript" referent="RBX276"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local CameraModule = {}
CameraModule.__index = CameraModule
local PLAYER_CAMERA_PROPERTIES = {
	"CameraMinZoomDistance",
	"CameraMaxZoomDistance",
	"CameraMode",
	"DevCameraOcclusionMode",
	"DevComputerCameraMode",
	"DevTouchCameraMode",
	"DevComputerMovementMode",
	"DevTouchMovementMode",
	"DevEnableMouseLock"
}
local USER_GAME_SETTINGS_PROPERTIES = {
	"ComputerCameraMovementMode",
	"ComputerMovementMode",
	"ControlMode",
	"GamepadCameraSensitivity",
	"MouseSensitivity",
	"RotationType",
	"TouchCameraMovementMode",
	"TouchMovementMode"
}
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterPlayer = game:GetService("StarterPlayer")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local CameraUtils = require(script:WaitForChild("CameraUtils"))
local ClassicCamera = require(script:WaitForChild("ClassicCamera"))
local OrbitalCamera = require(script:WaitForChild("OrbitalCamera"))
local LegacyCamera = require(script:WaitForChild("LegacyCamera"))
local Invisicam = require(script:WaitForChild("Invisicam"))
local Poppercam
do
	local success, useNewPoppercam = pcall(UserSettings().IsUserFeatureEnabled, UserSettings(), "UserNewPoppercam4")
	if success and useNewPoppercam then
		Poppercam = require(script:WaitForChild("Poppercam"))
	else
		Poppercam = require(script:WaitForChild("Poppercam_Classic"))
	end
end
local TransparencyController = require(script:WaitForChild("TransparencyController"))
local MouseLockController = require(script:WaitForChild("MouseLockController"))
local instantiatedCameraControllers = {}
local instantiatedOcclusionModules = {}
do
	local PlayerScripts = Players.LocalPlayer:WaitForChild("PlayerScripts")
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Default)
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Follow)
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Classic)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Default)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Follow)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Classic)
end
function CameraModule.new()
	local self = setmetatable({}, CameraModule)
	self.activeCameraController = nil
	self.activeOcclusionModule = nil
	self.activeTransparencyController = nil
	self.activeMouseLockController = nil
	self.currentComputerCameraMovementMode = nil
	self.cameraSubjectChangedConn = nil
	self.cameraTypeChangedConn = nil
	for _, player in pairs(Players:GetPlayers()) do
		self:OnPlayerAdded(player)
	end
	Players.PlayerAdded:Connect(function(player)
		self:OnPlayerAdded(player)
	end)
	self.activeTransparencyController = TransparencyController.new()
	self.activeTransparencyController:Enable(true)
	if not UserInputService.TouchEnabled then
		self.activeMouseLockController = MouseLockController.new()
		local toggleEvent = self.activeMouseLockController:GetBindableToggleEvent()
		if toggleEvent then
			toggleEvent:Connect(function()
				self:OnMouseLockToggled()
			end)
		end
	end
	self:ActivateCameraController(self:GetCameraControlChoice())
	self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
	self:OnCurrentCameraChanged()
	RunService:BindToRenderStep("cameraRenderUpdate", Enum.RenderPriority.Camera.Value, function(dt)
		self:Update(dt)
	end)
	for _, propertyName in pairs(PLAYER_CAMERA_PROPERTIES) do
		Players.LocalPlayer:GetPropertyChangedSignal(propertyName):Connect(function()
			self:OnLocalPlayerCameraPropertyChanged(propertyName)
		end)
	end
	for _, propertyName in pairs(USER_GAME_SETTINGS_PROPERTIES) do
		UserGameSettings:GetPropertyChangedSignal(propertyName):Connect(function()
			self:OnUserGameSettingsPropertyChanged(propertyName)
		end)
	end
	game.Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		self:OnCurrentCameraChanged()
	end)
	self.lastInputType = UserInputService:GetLastInputType()
	UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
		self.lastInputType = newLastInputType
	end)
	return self
end
function CameraModule:GetCameraMovementModeFromSettings()
	local cameraMode = Players.LocalPlayer.CameraMode
	if cameraMode == Enum.CameraMode.LockFirstPerson then
		return CameraUtils.ConvertCameraModeEnumToStandard(Enum.ComputerCameraMovementMode.Classic)
	end
	local devMode, userMode
	if UserInputService.TouchEnabled then
		devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevTouchCameraMode)
		userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
	else
		devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevComputerCameraMode)
		userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
	end
	if devMode == Enum.DevComputerCameraMovementMode.UserChoice then
		return userMode
	end
	return devMode
end
function CameraModule:ActivateOcclusionModule(occlusionMode)
	local newModuleCreator
	if occlusionMode == Enum.DevCameraOcclusionMode.Zoom then
		newModuleCreator = Poppercam
	elseif occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
		newModuleCreator = Invisicam
	else
		warn("CameraScript ActivateOcclusionModule called with unsupported mode")
		return
	end
	if self.activeOcclusionModule and self.activeOcclusionModule:GetOcclusionMode() == occlusionMode then
		if not self.activeOcclusionModule:GetEnabled() then
			self.activeOcclusionModule:Enable(true)
		end
		return
	end
	local prevOcclusionModule = self.activeOcclusionModule
	self.activeOcclusionModule = instantiatedOcclusionModules[newModuleCreator]
	if not self.activeOcclusionModule then
		self.activeOcclusionModule = newModuleCreator.new()
		if self.activeOcclusionModule then
			instantiatedOcclusionModules[newModuleCreator] = self.activeOcclusionModule
		end
	end
	if self.activeOcclusionModule then
		local newModuleOcclusionMode = self.activeOcclusionModule:GetOcclusionMode()
		if newModuleOcclusionMode ~= occlusionMode then
			warn("CameraScript ActivateOcclusionModule mismatch: ", self.activeOcclusionModule:GetOcclusionMode(), "~=", occlusionMode)
		end
		if prevOcclusionModule then
			if prevOcclusionModule ~= self.activeOcclusionModule then
				prevOcclusionModule:Enable(false)
			else
				warn("CameraScript ActivateOcclusionModule failure to detect already running correct module")
			end
		end
		if occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
			if Players.LocalPlayer.Character then
				self.activeOcclusionModule:CharacterAdded(Players.LocalPlayer.Character, Players.LocalPlayer)
			end
		else
			for _, player in pairs(Players:GetPlayers()) do
				if player and player.Character then
					self.activeOcclusionModule:CharacterAdded(player.Character, player)
				end
			end
			self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
		end
		self.activeOcclusionModule:Enable(true)
	end
end
function CameraModule:ActivateCameraController(cameraMovementMode, legacyCameraType)
	local newCameraCreator
	if legacyCameraType ~= nil then
		if legacyCameraType == Enum.CameraType.Scriptable then
			if self.activeCameraController then
				self.activeCameraController:Enable(false)
				self.activeCameraController = nil
				return
			end
		elseif legacyCameraType == Enum.CameraType.Custom then
			cameraMovementMode = self:GetCameraMovementModeFromSettings()
		elseif legacyCameraType == Enum.CameraType.Track then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Classic
		elseif legacyCameraType == Enum.CameraType.Follow then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Follow
		elseif legacyCameraType == Enum.CameraType.Orbital then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Orbital
		elseif legacyCameraType == Enum.CameraType.Attach or legacyCameraType == Enum.CameraType.Watch or legacyCameraType == Enum.CameraType.Fixed then
			newCameraCreator = LegacyCamera
		else
			warn("CameraScript encountered an unhandled Camera.CameraType value: ", legacyCameraType)
		end
	end
	if not newCameraCreator then
		if cameraMovementMode == Enum.ComputerCameraMovementMode.Classic or cameraMovementMode == Enum.ComputerCameraMovementMode.Follow or cameraMovementMode == Enum.ComputerCameraMovementMode.Default then
			newCameraCreator = ClassicCamera
		elseif cameraMovementMode == Enum.ComputerCameraMovementMode.Orbital then
			newCameraCreator = OrbitalCamera
		else
			warn("ActivateCameraController did not select a module.")
			return
		end
	end
	local newCameraController
	if not instantiatedCameraControllers[newCameraCreator] then
		newCameraController = newCameraCreator.new()
		instantiatedCameraControllers[newCameraCreator] = newCameraController
	else
		newCameraController = instantiatedCameraControllers[newCameraCreator]
	end
	if self.activeCameraController then
		if self.activeCameraController ~= newCameraController then
			self.activeCameraController:Enable(false)
			self.activeCameraController = newCameraController
			self.activeCameraController:Enable(true)
		elseif not self.activeCameraController:GetEnabled() then
			self.activeCameraController:Enable(true)
		end
	elseif newCameraController ~= nil then
		self.activeCameraController = newCameraController
		self.activeCameraController:Enable(true)
	end
	if self.activeCameraController then
		if cameraMovementMode ~= nil then
			self.activeCameraController:SetCameraMovementMode(cameraMovementMode)
		elseif legacyCameraType ~= nil then
			self.activeCameraController:SetCameraType(legacyCameraType)
		end
	end
end
function CameraModule:OnCameraSubjectChanged()
	if self.activeTransparencyController then
		self.activeTransparencyController:SetSubject(game.Workspace.CurrentCamera.CameraSubject)
	end
	if self.activeOcclusionModule then
		self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
	end
end
function CameraModule:OnCameraTypeChanged(newCameraType)
	if newCameraType == Enum.CameraType.Scriptable and UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
	self:ActivateCameraController(nil, newCameraType)
end
function CameraModule:OnCurrentCameraChanged()
	local currentCamera = game.Workspace.CurrentCamera
	if not currentCamera then
		return
	end
	if self.cameraSubjectChangedConn then
		self.cameraSubjectChangedConn:Disconnect()
	end
	if self.cameraTypeChangedConn then
		self.cameraTypeChangedConn:Disconnect()
	end
	self.cameraSubjectChangedConn = currentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
		self:OnCameraSubjectChanged(currentCamera.CameraSubject)
	end)
	self.cameraTypeChangedConn = currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
		self:OnCameraTypeChanged(currentCamera.CameraType)
	end)
	self:OnCameraSubjectChanged(currentCamera.CameraSubject)
	self:OnCameraTypeChanged(currentCamera.CameraType)
end
function CameraModule:OnLocalPlayerCameraPropertyChanged(propertyName)
	if propertyName == "CameraMode" then
		if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
			if not self.activeCameraController or self.activeCameraController:GetModuleName() ~= "ClassicCamera" then
				self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(Enum.DevComputerCameraMovementMode.Classic))
			end
			if self.activeCameraController then
				self.activeCameraController:UpdateForDistancePropertyChange()
			end
		elseif Players.LocalPlayer.CameraMode == Enum.CameraMode.Classic then
			local cameraMovementMode = self:GetCameraMovementModeFromSettings()
			self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
		else
			warn("Unhandled value for property player.CameraMode: ", Players.LocalPlayer.CameraMode)
		end
	elseif propertyName == "DevComputerCameraMode" or propertyName == "DevTouchCameraMode" then
		local cameraMovementMode = self:GetCameraMovementModeFromSettings()
		self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
	elseif propertyName == "DevCameraOcclusionMode" then
		self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
	elseif propertyName == "CameraMinZoomDistance" or propertyName == "CameraMaxZoomDistance" then
		if self.activeCameraController then
			self.activeCameraController:UpdateForDistancePropertyChange()
		end
	elseif propertyName == "DevTouchMovementMode" then
	elseif propertyName == "DevComputerMovementMode" then
	elseif propertyName == "DevEnableMouseLock" then
	end
end
function CameraModule:OnUserGameSettingsPropertyChanged(propertyName)
	if propertyName == "ComputerCameraMovementMode" then
		local cameraMovementMode = self:GetCameraMovementModeFromSettings()
		self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
	end
end
function CameraModule:Update(dt)
	if self.activeCameraController then
		local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)
		self.activeCameraController:ApplyVRTransform()
		if self.activeOcclusionModule then
			newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
		end
		game.Workspace.CurrentCamera.CFrame = newCameraCFrame
		game.Workspace.CurrentCamera.Focus = newCameraFocus
		if self.activeTransparencyController then
			self.activeTransparencyController:Update()
		end
	end
end
function CameraModule:GetCameraControlChoice()
	local player = Players.LocalPlayer
	if player then
		if self.lastInputType == Enum.UserInputType.Touch or UserInputService.TouchEnabled then
			if player.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice then
				return CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
			else
				return CameraUtils.ConvertCameraModeEnumToStandard(player.DevTouchCameraMode)
			end
		elseif player.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice then
			local computerMovementMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
			return CameraUtils.ConvertCameraModeEnumToStandard(computerMovementMode)
		else
			return CameraUtils.ConvertCameraModeEnumToStandard(player.DevComputerCameraMode)
		end
	end
end
function CameraModule:OnCharacterAdded(char, player)
	if self.activeOcclusionModule then
		self.activeOcclusionModule:CharacterAdded(char, player)
	end
end
function CameraModule:OnCharacterRemoving(char, player)
	if self.activeOcclusionModule then
		self.activeOcclusionModule:CharacterRemoving(char, player)
	end
end
function CameraModule:OnPlayerAdded(player)
	player.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char, player)
	end)
	player.CharacterRemoving:Connect(function(char)
		self:OnCharacterRemoving(char, player)
	end)
end
function CameraModule:OnMouseLockToggled()
	if self.activeMouseLockController then
		local mouseLocked = self.activeMouseLockController:GetIsMouseLocked()
		local mouseLockOffset = self.activeMouseLockController:GetMouseLockOffset()
		if self.activeCameraController then
			self.activeCameraController:SetIsMouseLocked(mouseLocked)
			self.activeCameraController:SetMouseLockOffset(mouseLockOffset)
		end
	end
end
return CameraModule.new()
]]></ProtectedString><string name="Name">CameraModule</string></Properties><Item class="ModuleScript" referent="RBX280"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local CameraUtils = {}
local round = function(num)
	return math.floor(num + 0.5)
end
function CameraUtils.Clamp(low, high, val)
	return math.min(math.max(val, low), high)
end
function CameraUtils.Round(num, places)
	local decimalPivot = 10 ^ places
	return math.floor(num * decimalPivot + 0.5) / decimalPivot
end
function CameraUtils.IsFinite(val)
	return val == val and val ~= math.huge and val ~= -math.huge
end
function CameraUtils.IsFiniteVector3(vec3)
	return CameraUtils.IsFinite(vec3.X) and CameraUtils.IsFinite(vec3.Y) and CameraUtils.IsFinite(vec3.Z)
end
function CameraUtils.GetAngleBetweenXZVectors(v1, v2)
	return math.atan2(v2.X * v1.Z - v2.Z * v1.X, v2.X * v1.X + v2.Z * v1.Z)
end
function CameraUtils.RotateVectorByAngleAndRound(camLook, rotateAngle, roundAmount)
	if camLook.Magnitude > 0 then
		camLook = camLook.unit
		local currAngle = math.atan2(camLook.z, camLook.x)
		local newAngle = round((math.atan2(camLook.z, camLook.x) + rotateAngle) / roundAmount) * roundAmount
		return newAngle - currAngle
	end
	return 0
end
local k = 0.35
local lowerK = 0.8
local function SCurveTranform(t)
	t = CameraUtils.Clamp(-1, 1, t)
	if t >= 0 then
		return k * t / (k - t + 1)
	end
	return -(lowerK * -t / (lowerK + t + 1))
end
local DEADZONE = 0.1
local function toSCurveSpace(t)
	return (1 + DEADZONE) * (2 * math.abs(t) - 1) - DEADZONE
end
local fromSCurveSpace = function(t)
	return t / 2 + 0.5
end
function CameraUtils.GamepadLinearToCurve(thumbstickPosition)
	local function onAxis(axisValue)
		local sign = 1
		if axisValue < 0 then
			sign = -1
		end
		local point = fromSCurveSpace(SCurveTranform(toSCurveSpace(math.abs(axisValue))))
		point = point * sign
		return CameraUtils.Clamp(-1, 1, point)
	end
	return Vector2.new(onAxis(thumbstickPosition.x), onAxis(thumbstickPosition.y))
end
function CameraUtils.ConvertCameraModeEnumToStandard(enumValue)
	if enumValue == Enum.TouchCameraMovementMode.Default then
		return Enum.ComputerCameraMovementMode.Follow
	end
	if enumValue == Enum.ComputerCameraMovementMode.Default then
		return Enum.ComputerCameraMovementMode.Classic
	end
	if enumValue == Enum.TouchCameraMovementMode.Classic or enumValue == Enum.DevTouchCameraMovementMode.Classic or enumValue == Enum.DevComputerCameraMovementMode.Classic or enumValue == Enum.ComputerCameraMovementMode.Classic then
		return Enum.ComputerCameraMovementMode.Classic
	end
	if enumValue == Enum.TouchCameraMovementMode.Follow or enumValue == Enum.DevTouchCameraMovementMode.Follow or enumValue == Enum.DevComputerCameraMovementMode.Follow or enumValue == Enum.ComputerCameraMovementMode.Follow then
		return Enum.ComputerCameraMovementMode.Follow
	end
	if enumValue == Enum.TouchCameraMovementMode.Orbital or enumValue == Enum.DevTouchCameraMovementMode.Orbital or enumValue == Enum.DevComputerCameraMovementMode.Orbital or enumValue == Enum.ComputerCameraMovementMode.Orbital then
		return Enum.ComputerCameraMovementMode.Orbital
	end
	if enumValue == Enum.DevTouchCameraMovementMode.UserChoice or enumValue == Enum.DevComputerCameraMovementMode.UserChoice then
		return Enum.DevComputerCameraMovementMode.UserChoice
	end
	return Enum.ComputerCameraMovementMode.Classic
end
return CameraUtils
]]></ProtectedString><string name="Name">CameraUtils</string></Properties></Item><Item class="ModuleScript" referent="RBX285"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZERO_VECTOR2 = Vector2.new(0, 0)
local tweenAcceleration = math.rad(220)
local tweenSpeed = math.rad(0)
local tweenMaxSpeed = math.rad(250)
local TIME_BEFORE_AUTO_ROTATE = 2
local PORTRAIT_OFFSET = Vector3.new(0, 2, 0)
local MOBILE_OFFSET = Vector3.new(0, 1, 0)
local INITIAL_CAMERA_ANGLE = CFrame.fromOrientation(math.rad(-15), 0, 0)
local PlayersService = game:GetService("Players")
local VRService = game:GetService("VRService")
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local newCameraConstantsFlagExists, newCameraConstantsFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserUpdateCameraConstants")
end)
local FFlagUserUpdateCameraConstants = newCameraConstantsFlagExists and newCameraConstantsFlagEnabled
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local ClassicCamera = setmetatable({}, BaseCamera)
ClassicCamera.__index = ClassicCamera
function ClassicCamera.new()
	local self = setmetatable(BaseCamera.new(), ClassicCamera)
	self.isFollowCamera = false
	self.lastUpdate = tick()
	return self
end
function ClassicCamera:GetModuleName()
	return "ClassicCamera"
end
function ClassicCamera:SetCameraMovementMode(cameraMovementMode)
	BaseCamera.SetCameraMovementMode(self, cameraMovementMode)
	self.isFollowCamera = cameraMovementMode == Enum.ComputerCameraMovementMode.Follow
end
function ClassicCamera:Test()
	print("ClassicCamera:Test()")
end
function ClassicCamera:GetCameraSubjectOffset()
	if self:IsInFirstPerson() then
		return Vector3.new(0, 0, 0)
	elseif self.portraitMode then
		return PORTRAIT_OFFSET
	elseif self.isSmallTouchScreen then
		return MOBILE_OFFSET
	end
	return Vector3.new(0, 0, 0)
end
function ClassicCamera:Update()
	local now = tick()
	local timeDelta = now - self.lastUpdate
	local camera = workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local overrideCameraLookVector
	if self.resetCameraAngle then
		local rootPart = self:GetHumanoidRootPart()
		if rootPart then
			overrideCameraLookVector = (rootPart.CFrame * INITIAL_CAMERA_ANGLE).lookVector
		else
			overrideCameraLookVector = INITIAL_CAMERA_ANGLE.lookVector
		end
		self.resetCameraAngle = false
	end
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	local isOnASkateboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end
	if self.lastUpdate then
		local gamepadRotation = self:UpdateGamepad()
		if self:ShouldUseVRRotation() then
			self.rotateInput = self.rotateInput + self:GetVRRotationInput()
		else
			local delta = math.min(0.1, timeDelta)
			if gamepadRotation ~= ZERO_VECTOR2 then
				self.rotateInput = self.rotateInput + gamepadRotation * delta
			end
			local angle = 0
			if not isInVehicle and not isOnASkateboard then
				angle = angle + (self.turningLeft and -120 or 0)
				angle = angle + (self.turningRight and 120 or 0)
			end
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(math.rad(angle * delta), 0)
			end
		end
	end
	if self.userPanningTheCamera then
		tweenSpeed = 0
		self.lastUserPanCamera = tick()
	end
	local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
	local subjectPosition = self:GetSubjectPosition()
	if subjectPosition and player and camera then
		local zoom = self:GetCameraToSubjectDistance()
		if zoom < 0.5 then
			zoom = 0.5
		end
		if self:GetIsMouseLocked() and not self:IsInFirstPerson() then
			local newLookCFrame = self:CalculateNewLookCFrame(overrideCameraLookVector)
			local offset = self:GetMouseLockOffset()
			local cameraRelativeOffset = offset.X * newLookCFrame.rightVector + offset.Y * newLookCFrame.upVector + offset.Z * newLookCFrame.lookVector
			if Util.IsFiniteVector3(cameraRelativeOffset) then
				subjectPosition = subjectPosition + cameraRelativeOffset
			end
		elseif not self.userPanningTheCamera and self.lastCameraTransform then
			local isInFirstPerson = self:IsInFirstPerson()
			if (isInVehicle or isOnASkateboard or self.isFollowCamera and isClimbing) and self.lastUpdate and humanoid and humanoid.Torso then
				if isInFirstPerson then
					if self.lastSubjectCFrame and (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
						local y = -Util.GetAngleBetweenXZVectors(self.lastSubjectCFrame.lookVector, cameraSubject.CFrame.lookVector)
						if Util.IsFinite(y) then
							self.rotateInput = self.rotateInput + Vector2.new(y, 0)
						end
						tweenSpeed = 0
					end
				elseif not userRecentlyPannedCamera then
					local forwardVector = humanoid.Torso.CFrame.lookVector
					if isOnASkateboard then
						forwardVector = cameraSubject.CFrame.lookVector
					end
					tweenSpeed = Util.Clamp(0, tweenMaxSpeed, tweenSpeed + tweenAcceleration * timeDelta)
					local percent = Util.Clamp(0, 1, tweenSpeed * timeDelta)
					if self:IsInFirstPerson() and (not self.isFollowCamera or not self.isClimbing) then
						percent = 1
					end
					local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
					if Util.IsFinite(y) and math.abs(y) > 1.0E-4 then
						self.rotateInput = self.rotateInput + Vector2.new(y * percent, 0)
					end
				end
			elseif self.isFollowCamera and not isInFirstPerson and not userRecentlyPannedCamera and not VRService.VREnabled then
				local lastVec = -(self.lastCameraTransform.p - subjectPosition)
				local y = Util.GetAngleBetweenXZVectors(lastVec, self:GetCameraLookVector())
				local thetaCutoff = 0.4
				if Util.IsFinite(y) and math.abs(y) > 1.0E-4 and math.abs(y) > thetaCutoff * timeDelta then
					self.rotateInput = self.rotateInput + Vector2.new(y, 0)
				end
			end
		end
		if not self.isFollowCamera then
			local VREnabled = VRService.VREnabled
			if VREnabled then
				newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
			elseif FFlagUserUpdateCameraConstants then
				newCameraFocus = CFrame.new(subjectPosition)
			else
				newCameraFocus = CFrame.new(subjectPosition + self:GetCameraSubjectOffset())
			end
			local cameraFocusP = newCameraFocus.p
			if VREnabled and not self:IsInFirstPerson() then
				local cameraHeight = self:GetCameraHeight()
				local vecToSubject = subjectPosition - camera.CFrame.p
				local distToSubject = vecToSubject.magnitude
				if zoom < distToSubject or self.rotateInput.x ~= 0 then
					local desiredDist = math.min(distToSubject, zoom)
					vecToSubject = self:CalculateNewLookVectorVR() * desiredDist
					local newPos = cameraFocusP - vecToSubject
					local desiredLookDir = camera.CFrame.lookVector
					if self.rotateInput.x ~= 0 then
						desiredLookDir = vecToSubject
					end
					local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
					self.rotateInput = ZERO_VECTOR2
					newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
				end
			else
				local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
				self.rotateInput = ZERO_VECTOR2
				newCameraCFrame = CFrame.new(cameraFocusP - zoom * newLookVector, cameraFocusP)
			end
		else
			local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
			self.rotateInput = ZERO_VECTOR2
			if VRService.VREnabled then
				newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
			elseif FFlagUserUpdateCameraConstants then
				newCameraFocus = CFrame.new(subjectPosition)
			else
				newCameraFocus = CFrame.new(subjectPosition + self:GetCameraSubjectOffset())
			end
			newCameraCFrame = CFrame.new(newCameraFocus.p - zoom * newLookVector, newCameraFocus.p) + Vector3.new(0, self:GetCameraHeight(), 0)
		end
		self.lastCameraTransform = newCameraCFrame
		self.lastCameraFocus = newCameraFocus
		if (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
			self.lastSubjectCFrame = cameraSubject.CFrame
		else
			self.lastSubjectCFrame = nil
		end
	end
	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end
function ClassicCamera:EnterFirstPerson()
	self.inFirstPerson = true
	self:UpdateMouseBehavior()
end
function ClassicCamera:LeaveFirstPerson()
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
end
return ClassicCamera
]]></ProtectedString><string name="Name">ClassicCamera</string></Properties></Item><Item class="ModuleScript" referent="RBX290"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZoomController = require(script.Parent:WaitForChild("ZoomController"))
local TransformExtrapolator = {}
TransformExtrapolator.__index = TransformExtrapolator
do
	local CF_IDENTITY = CFrame.new()
	local cframeToAxis = function(cframe)
		local axis, angle = cframe:toAxisAngle()
		return axis * angle
	end
	local function axisToCFrame(axis)
		local angle = axis.magnitude
		if angle > 1.0E-5 then
			return CFrame.fromAxisAngle(axis, angle)
		end
		return CF_IDENTITY
	end
	local extractRotation = function(cf)
		local _, _, _, xx, yx, zx, xy, yy, zy, xz, yz, zz = cf:components()
		return CFrame.new(0, 0, 0, xx, yx, zx, xy, yy, zy, xz, yz, zz)
	end
	function TransformExtrapolator.new()
		return setmetatable({lastCFrame = nil}, TransformExtrapolator)
	end
	function TransformExtrapolator:Step(dt, currentCFrame)
		local lastCFrame = self.lastCFrame or currentCFrame
		self.lastCFrame = currentCFrame
		local currentPos = currentCFrame.p
		local currentRot = extractRotation(currentCFrame)
		local lastPos = lastCFrame.p
		local lastRot = extractRotation(lastCFrame)
		local dp = (currentPos - lastPos) / dt
		local dr = cframeToAxis(currentRot * lastRot:inverse()) / dt
		local function extrapolate(t)
			local p = dp * t + currentPos
			local r = axisToCFrame(dr * t) * currentRot
			return r + p
		end
		return {
			extrapolate = extrapolate,
			posVelocity = dp,
			rotVelocity = dr
		}
	end
	function TransformExtrapolator:Reset()
		self.lastCFrame = nil
	end
end
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Poppercam = setmetatable({}, BaseOcclusion)
Poppercam.__index = Poppercam
function Poppercam.new()
	local self = setmetatable(BaseOcclusion.new(), Poppercam)
	self.focusExtrapolator = TransformExtrapolator.new()
	return self
end
function Poppercam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Zoom
end
function Poppercam:Enable(enable)
	self.focusExtrapolator:Reset()
end
function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
	local rotatedFocus = CFrame.new(desiredCameraFocus.p, desiredCameraCFrame.p) * CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1)
	local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
	local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
	return rotatedFocus * CFrame.new(0, 0, zoom), desiredCameraFocus
end
function Poppercam:CharacterAdded(character, player)
end
function Poppercam:CharacterRemoving(character, player)
end
function Poppercam:OnCameraSubjectChanged(newSubject)
end
return Poppercam
]]></ProtectedString><string name="Name">Poppercam</string></Properties></Item><Item class="ModuleScript" referent="RBX295"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UNIT_Z = Vector3.new(0, 0, 1)
local X1_Y0_Z1 = Vector3.new(1, 0, 1)
local THUMBSTICK_DEADZONE = 0.2
local DEFAULT_DISTANCE = 12.5
local PORTRAIT_DEFAULT_DISTANCE = 25
local FIRST_PERSON_DISTANCE_THRESHOLD = 1
local CAMERA_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
local newCameraConstantsFlagExists, newCameraConstantsFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserUpdateCameraConstants")
end)
local FFlagUserUpdateCameraConstants = newCameraConstantsFlagExists and newCameraConstantsFlagEnabled
local MIN_Y = math.rad(-80)
local MAX_Y = math.rad(80)
local VR_ANGLE = math.rad(15)
local VR_LOW_INTENSITY_ROTATION = Vector2.new(math.rad(15), 0)
local VR_HIGH_INTENSITY_ROTATION = Vector2.new(math.rad(45), 0)
local VR_LOW_INTENSITY_REPEAT = 0.1
local VR_HIGH_INTENSITY_REPEAT = 0.4
local ZERO_VECTOR2 = Vector2.new(0, 0)
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local TOUCH_SENSITIVTY = Vector2.new(0.002 * math.pi, 0.0015 * math.pi)
if FFlagUserUpdateCameraConstants then
	TOUCH_SENSITIVTY = Vector2.new(0.0045 * math.pi, 0.003375 * math.pi)
end
local MOUSE_SENSITIVITY = Vector2.new(0.002 * math.pi, 0.0015 * math.pi)
local MAX_TIME_FOR_DOUBLE_TAP = 1.5
local MAX_TAP_POS_DELTA = 15
local MAX_TAP_TIME_DELTA = 0.75
local SEAT_OFFSET = Vector3.new(0, 5, 0)
local VR_SEAT_OFFSET = Vector3.new(0, 4, 0)
local HEAD_OFFSET = Vector3.new(0, 1.5, 0)
local R15_HEAD_OFFSET = Vector3.new(0, 2, 0)
local R15_HEAD_OFFSET_NO_SCALING = Vector3.new(0, 2, 0)
local HUMANOID_ROOT_PART_SIZE = Vector3.new(2, 2, 1)
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local adjustHumanoidRootPartFlagExists, adjustHumanoidRootPartFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserAdjustHumanoidRootPartToHipPosition")
end)
local FFlagUserAdjustHumanoidRootPartToHipPosition = adjustHumanoidRootPartFlagExists and adjustHumanoidRootPartFlagEnabled
if FFlagUserAdjustHumanoidRootPartToHipPosition then
	R15_HEAD_OFFSET = Vector3.new(0, 1.5, 0)
end
local noDynamicThumbstickRecenterFlagExists, noDynamicThumbstickRecenterFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNoDynamicThumbstickRecenter")
end)
local FFlagUserNoDynamicThumbstickRecenter = noDynamicThumbstickRecenterFlagExists and noDynamicThumbstickRecenterFlagEnabled
local thumbstickUseCASFlagSuccess, thumbstickUseCASFlagValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserDynamicThumbstickUseContextActionSevice")
end)
local FFlagDynamicThumbstickUseContextActionSevice = thumbstickUseCASFlagSuccess and thumbstickUseCASFlagValue
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local ZoomController = require(script.Parent:WaitForChild("ZoomController"))
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local GuiService = game:GetService("GuiService")
local ContextActionService = game:GetService("ContextActionService")
local VRService = game:GetService("VRService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local BaseCamera = {}
BaseCamera.__index = BaseCamera
function BaseCamera.new()
	local self = setmetatable({}, BaseCamera)
	self.FIRST_PERSON_DISTANCE_THRESHOLD = FIRST_PERSON_DISTANCE_THRESHOLD
	self.cameraType = nil
	self.cameraMovementMode = nil
	local player = Players.LocalPlayer
	self.lastCameraTransform = nil
	self.rotateInput = ZERO_VECTOR2
	self.userPanningCamera = false
	self.lastUserPanCamera = tick()
	self.humanoidRootPart = nil
	self.humanoidCache = {}
	self.lastSubject = nil
	self.lastSubjectPosition = Vector3.new(0, 5, 0)
	self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)
	self.currentSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)
	self.inFirstPerson = false
	self.inMouseLockedMode = false
	self.portraitMode = false
	self.isSmallTouchScreen = false
	self.resetCameraAngle = true
	self.enabled = false
	self.inputBeganConn = nil
	self.inputChangedConn = nil
	self.inputEndedConn = nil
	self.startPos = nil
	self.lastPos = nil
	self.panBeginLook = nil
	self.panEnabled = true
	self.keyPanEnabled = true
	self.distanceChangeEnabled = true
	self.PlayerGui = nil
	self.cameraChangedConn = nil
	self.viewportSizeChangedConn = nil
	self.boundContextActions = {}
	self.shouldUseVRRotation = false
	self.VRRotationIntensityAvailable = false
	self.lastVRRotationIntensityCheckTime = 0
	self.lastVRRotationTime = 0
	self.vrRotateKeyCooldown = {}
	self.cameraTranslationConstraints = Vector3.new(1, 1, 1)
	self.humanoidJumpOrigin = nil
	self.trackingHumanoid = nil
	self.cameraFrozen = false
	self.subjectStateChangedConn = nil
	self.activeGamepad = nil
	self.gamepadPanningCamera = false
	self.lastThumbstickRotate = nil
	self.numOfSeconds = 0.7
	self.currentSpeed = 0
	self.maxSpeed = 6
	self.vrMaxSpeed = 4
	self.lastThumbstickPos = Vector2.new(0, 0)
	self.ySensitivity = 0.65
	self.lastVelocity = nil
	self.gamepadConnectedConn = nil
	self.gamepadDisconnectedConn = nil
	self.currentZoomSpeed = 1
	self.L3ButtonDown = false
	self.dpadLeftDown = false
	self.dpadRightDown = false
	self.isDynamicThumbstickEnabled = false
	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	self.inputStartPositions = {}
	self.inputStartTimes = {}
	self.startingDiff = nil
	self.pinchBeginZoom = nil
	self.userPanningTheCamera = false
	self.touchActivateConn = nil
	self.mouseLockOffset = ZERO_VECTOR3
	if player.Character then
		self:OnCharacterAdded(player.Character)
	end
	player.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char)
	end)
	if self.cameraChangedConn then
		self.cameraChangedConn:Disconnect()
	end
	self.cameraChangedConn = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		self:OnCurrentCameraChanged()
	end)
	self:OnCurrentCameraChanged()
	if self.playerCameraModeChangeConn then
		self.playerCameraModeChangeConn:Disconnect()
	end
	self.playerCameraModeChangeConn = player:GetPropertyChangedSignal("CameraMode"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)
	if self.minDistanceChangeConn then
		self.minDistanceChangeConn:Disconnect()
	end
	self.minDistanceChangeConn = player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)
	if self.maxDistanceChangeConn then
		self.maxDistanceChangeConn:Disconnect()
	end
	self.maxDistanceChangeConn = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)
	if self.playerDevTouchMoveModeChangeConn then
		self.playerDevTouchMoveModeChangeConn:Disconnect()
	end
	self.playerDevTouchMoveModeChangeConn = player:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
		self:OnDevTouchMovementModeChanged()
	end)
	self:OnDevTouchMovementModeChanged()
	if self.gameSettingsTouchMoveMoveChangeConn then
		self.gameSettingsTouchMoveMoveChangeConn:Disconnect()
	end
	self.gameSettingsTouchMoveMoveChangeConn = UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
		self:OnGameSettingsTouchMovementModeChanged()
	end)
	self:OnGameSettingsTouchMovementModeChanged()
	UserGameSettings:SetCameraYInvertVisible()
	UserGameSettings:SetGamepadCameraSensitivityVisible()
	self.hasGameLoaded = game:IsLoaded()
	if not self.hasGameLoaded then
		self.gameLoadedConn = game.Loaded:Connect(function()
			self.hasGameLoaded = true
			self.gameLoadedConn:Disconnect()
			self.gameLoadedConn = nil
		end)
	end
	return self
end
function BaseCamera:GetModuleName()
	return "BaseCamera"
end
function BaseCamera:OnCharacterAdded(char)
	self.resetCameraAngle = self.resetCameraAngle or self:GetEnabled()
	self.humanoidRootPart = nil
	if UserInputService.TouchEnabled then
		self.PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
		for _, child in ipairs(char:GetChildren()) do
			if child:IsA("Tool") then
				self.isAToolEquipped = true
			end
		end
		char.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				self.isAToolEquipped = true
			end
		end)
		char.ChildRemoved:Connect(function(child)
			if child:IsA("Tool") then
				self.isAToolEquipped = false
			end
		end)
	end
end
function BaseCamera:GetHumanoidRootPart()
	if not self.humanoidRootPart then
		local player = Players.LocalPlayer
		if player.Character then
			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				self.humanoidRootPart = humanoid.RootPart
			end
		end
	end
	return self.humanoidRootPart
end
function BaseCamera:GetBodyPartToFollow(humanoid, isDead)
	if humanoid:GetState() == Enum.HumanoidStateType.Dead then
		local character = humanoid.Parent
		if character and character:IsA("Model") then
			return character:FindFirstChild("Head") or humanoid.RootPart
		end
	end
	return humanoid.RootPart
end
function BaseCamera:GetSubjectPosition()
	local result = self.lastSubjectPosition
	local camera = game.Workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject
	if cameraSubject then
		if cameraSubject:IsA("Humanoid") then
			local humanoid = cameraSubject
			local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead
			if VRService.VREnabled and humanoidIsDead and humanoid == self.lastSubject then
				result = self.lastSubjectPosition
			else
				local bodyPartToFollow = humanoid.RootPart
				bodyPartToFollow = humanoidIsDead and humanoid.Parent and humanoid.Parent:IsA("Model") and humanoid.Parent:FindFirstChild("Head") or bodyPartToFollow
				if bodyPartToFollow and bodyPartToFollow:IsA("BasePart") then
					local heightOffset
					if FFlagUserAdjustHumanoidRootPartToHipPosition then
						if humanoid.RigType == Enum.HumanoidRigType.R15 then
							if humanoid.AutomaticScalingEnabled then
								heightOffset = R15_HEAD_OFFSET
								if bodyPartToFollow == humanoid.RootPart then
									local rootPartSizeOffset = humanoid.RootPart.Size.Y / 2 - HUMANOID_ROOT_PART_SIZE.Y / 2
									heightOffset = heightOffset + Vector3.new(0, rootPartSizeOffset, 0)
								end
							else
								heightOffset = R15_HEAD_OFFSET_NO_SCALING
							end
						else
							heightOffset = HEAD_OFFSET
						end
					else
						heightOffset = humanoid.RigType == Enum.HumanoidRigType.R15 and R15_HEAD_OFFSET or HEAD_OFFSET
					end
					if humanoidIsDead then
						heightOffset = ZERO_VECTOR3
					end
					result = bodyPartToFollow.CFrame.p + bodyPartToFollow.CFrame:vectorToWorldSpace(heightOffset + humanoid.CameraOffset)
				end
			end
		elseif cameraSubject:IsA("VehicleSeat") then
			local offset = SEAT_OFFSET
			if VRService.VREnabled then
				offset = VR_SEAT_OFFSET
			end
			result = cameraSubject.CFrame.p + cameraSubject.CFrame:vectorToWorldSpace(offset)
		elseif cameraSubject:IsA("SkateboardPlatform") then
			result = cameraSubject.CFrame.p + SEAT_OFFSET
		elseif cameraSubject:IsA("BasePart") then
			result = cameraSubject.CFrame.p
		elseif cameraSubject:IsA("Model") then
			if cameraSubject.PrimaryPart then
				result = cameraSubject:GetPrimaryPartCFrame().p
			else
				result = cameraSubject:GetModelCFrame().p
			end
		end
	else
		return
	end
	self.lastSubject = cameraSubject
	self.lastSubjectPosition = result
	return result
end
function BaseCamera:UpdateDefaultSubjectDistance()
	local player = Players.LocalPlayer
	if self.portraitMode then
		self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, PORTRAIT_DEFAULT_DISTANCE)
	else
		self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)
	end
end
function BaseCamera:OnViewportSizeChanged()
	local camera = game.Workspace.CurrentCamera
	local size = camera.ViewportSize
	self.portraitMode = size.X < size.Y
	self.isSmallTouchScreen = UserInputService.TouchEnabled and (size.Y < 500 or size.X < 700)
	self:UpdateDefaultSubjectDistance()
end
function BaseCamera:OnCurrentCameraChanged()
	if UserInputService.TouchEnabled then
		if self.viewportSizeChangedConn then
			self.viewportSizeChangedConn:Disconnect()
			self.viewportSizeChangedConn = nil
		end
		local newCamera = game.Workspace.CurrentCamera
		if newCamera then
			self:OnViewportSizeChanged()
			self.viewportSizeChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
				self:OnViewportSizeChanged()
			end)
		end
	end
	if self.cameraSubjectChangedConn then
		self.cameraSubjectChangedConn:Disconnect()
		self.cameraSubjectChangedConn = nil
	end
	local camera = game.Workspace.CurrentCamera
	if camera then
		self.cameraSubjectChangedConn = camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
			self:OnNewCameraSubject()
		end)
		self:OnNewCameraSubject()
	end
end
function BaseCamera:OnDynamicThumbstickEnabled()
	if UserInputService.TouchEnabled then
		self.isDynamicThumbstickEnabled = true
	end
end
function BaseCamera:OnDynamicThumbstickDisabled()
	self.isDynamicThumbstickEnabled = false
end
function BaseCamera:OnGameSettingsTouchMovementModeChanged()
	if Players.LocalPlayer.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice then
		if FFlagUserNoDynamicThumbstickRecenter then
			if UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.DynamicThumbstick or UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.Default then
				self:OnDynamicThumbstickEnabled()
			else
				self:OnDynamicThumbstickDisabled()
			end
		elseif UserGameSettings.TouchMovementMode.Name == "DynamicThumbstick" then
			self:OnDynamicThumbstickEnabled()
		else
			self:OnDynamicThumbstickDisabled()
		end
	end
end
function BaseCamera:OnDevTouchMovementModeChanged()
	if Players.LocalPlayer.DevTouchMovementMode.Name == "DynamicThumbstick" then
		self:OnDynamicThumbstickEnabled()
	else
		self:OnGameSettingsTouchMovementModeChanged()
	end
end
function BaseCamera:OnPlayerCameraPropertyChange()
	self:SetCameraToSubjectDistance(self.currentSubjectDistance)
end
function BaseCamera:GetCameraHeight()
	if VRService.VREnabled and not self.inFirstPerson then
		return math.sin(VR_ANGLE) * self.currentSubjectDistance
	end
	return 0
end
function BaseCamera:InputTranslationToCameraAngleChange(translationVector, sensitivity)
	local camera = game.Workspace.CurrentCamera
	if camera and camera.ViewportSize.X > 0 and 0 < camera.ViewportSize.Y and camera.ViewportSize.Y > camera.ViewportSize.X then
		return translationVector * Vector2.new(sensitivity.Y, sensitivity.X)
	end
	return translationVector * sensitivity
end
function BaseCamera:Enable(enable)
	if self.enabled ~= enable then
		self.enabled = enable
		if self.enabled then
			self:ConnectInputEvents()
			if FFlagPlayerScriptsBindAtPriority2 then
				self:BindContextActions()
			end
			if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
				self.currentSubjectDistance = 0.5
				if not self.inFirstPerson then
					self:EnterFirstPerson()
				end
			end
		else
			self:DisconnectInputEvents()
			if FFlagPlayerScriptsBindAtPriority2 then
				self:UnbindContextActions()
			end
			self:Cleanup()
		end
	end
end
function BaseCamera:GetEnabled()
	return self.enabled
end
function BaseCamera:OnInputBegan(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchBegan(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		self:OnMouse2Down(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
		self:OnMouse3Down(input, processed)
	end
	if not FFlagPlayerScriptsBindAtPriority2 and input.UserInputType == Enum.UserInputType.Keyboard then
		self:OnKeyDown(input, processed)
	end
end
function BaseCamera:OnInputChanged(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchChanged(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseMovement then
		self:OnMouseMoved(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseWheel then
		self:OnMouseWheel(input, processed)
	end
end
function BaseCamera:OnInputEnded(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchEnded(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		self:OnMouse2Up(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
		self:OnMouse3Up(input, processed)
	end
	if not FFlagPlayerScriptsBindAtPriority2 and input.UserInputType == Enum.UserInputType.Keyboard then
		self:OnKeyUp(input, processed)
	end
end
function BaseCamera:ConnectInputEvents()
	self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
		self:OnInputBegan(input, processed)
	end)
	self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
		self:OnInputChanged(input, processed)
	end)
	self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
		self:OnInputEnded(input, processed)
	end)
	if not FFlagUserNoDynamicThumbstickRecenter then
		self.touchActivateConn = UserInputService.TouchTapInWorld:Connect(function(touchPos, processed)
			self:OnTouchTap(touchPos)
		end)
	end
	self.menuOpenedConn = GuiService.MenuOpened:connect(function()
		self:ResetInputStates()
	end)
	self.gamepadConnectedConn = UserInputService.GamepadDisconnected:connect(function(gamepadEnum)
		if self.activeGamepad ~= gamepadEnum then
			return
		end
		self.activeGamepad = nil
		self:AssignActivateGamepad()
	end)
	self.gamepadDisconnectedConn = UserInputService.GamepadConnected:connect(function(gamepadEnum)
		if self.activeGamepad == nil then
			self:AssignActivateGamepad()
		end
	end)
	if not FFlagPlayerScriptsBindAtPriority2 then
		self:BindGamepadInputActions()
	end
	self:AssignActivateGamepad()
	self:UpdateMouseBehavior()
end
function BaseCamera:BindContextActions()
	self:BindGamepadInputActions()
	self:BindKeyboardInputActions()
end
function BaseCamera:AssignActivateGamepad()
	local connectedGamepads = UserInputService:GetConnectedGamepads()
	if #connectedGamepads > 0 then
		for i = 1, #connectedGamepads do
			if self.activeGamepad == nil then
				self.activeGamepad = connectedGamepads[i]
			elseif connectedGamepads[i].Value < self.activeGamepad.Value then
				self.activeGamepad = connectedGamepads[i]
			end
		end
	end
	if self.activeGamepad == nil then
		self.activeGamepad = Enum.UserInputType.Gamepad1
	end
end
function BaseCamera:DisconnectInputEvents()
	if self.inputBeganConn then
		self.inputBeganConn:Disconnect()
		self.inputBeganConn = nil
	end
	if self.inputChangedConn then
		self.inputChangedConn:Disconnect()
		self.inputChangedConn = nil
	end
	if self.inputEndedConn then
		self.inputEndedConn:Disconnect()
		self.inputEndedConn = nil
	end
end
function BaseCamera:UnbindContextActions()
	for i = 1, #self.boundContextActions do
		ContextActionService:UnbindAction(self.boundContextActions[i])
	end
	self.boundContextActions = {}
end
function BaseCamera:Cleanup()
	if self.menuOpenedConn then
		self.menuOpenedConn:Disconnect()
		self.menuOpenedConn = nil
	end
	if self.mouseLockToggleConn then
		self.mouseLockToggleConn:Disconnect()
		self.mouseLockToggleConn = nil
	end
	if self.gamepadConnectedConn then
		self.gamepadConnectedConn:Disconnect()
		self.gamepadConnectedConn = nil
	end
	if self.gamepadDisconnectedConn then
		self.gamepadDisconnectedConn:Disconnect()
		self.gamepadDisconnectedConn = nil
	end
	if self.subjectStateChangedConn then
		self.subjectStateChangedConn:Disconnect()
		self.subjectStateChangedConn = nil
	end
	if self.viewportSizeChangedConn then
		self.viewportSizeChangedConn:Disconnect()
		self.viewportSizeChangedConn = nil
	end
	if self.touchActivateConn then
		self.touchActivateConn:Disconnect()
		self.touchActivateConn = nil
	end
	self.turningLeft = false
	self.turningRight = false
	self.lastCameraTransform = nil
	self.lastSubjectCFrame = nil
	self.userPanningTheCamera = false
	self.rotateInput = Vector2.new()
	self.gamepadPanningCamera = Vector2.new(0, 0)
	self.startPos = nil
	self.lastPos = nil
	self.panBeginLook = nil
	self.isRightMouseDown = false
	self.isMiddleMouseDown = false
	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	self.startingDiff = nil
	self.pinchBeginZoom = nil
	if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end
function BaseCamera:ResetInputStates()
	self.isRightMouseDown = false
	self.isMiddleMouseDown = false
	self:OnMousePanButtonReleased()
	if UserInputService.TouchEnabled then
		for inputObject in pairs(self.fingerTouches) do
			self.fingerTouches[inputObject] = nil
		end
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
		self.startingDiff = nil
		self.pinchBeginZoom = nil
		self.numUnsunkTouches = 0
	end
end
function BaseCamera:GetGamepadPan(name, state, input)
	if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
		if state == Enum.UserInputState.Cancel then
			self.gamepadPanningCamera = ZERO_VECTOR2
			return
		end
		local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
		if inputVector.magnitude > THUMBSTICK_DEADZONE then
			self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
		else
			self.gamepadPanningCamera = ZERO_VECTOR2
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function BaseCamera:DoKeyboardPanTurn(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end
	if state == Enum.UserInputState.Cancel then
		self.turningLeft = false
		self.turningRight = false
		return Enum.ContextActionResult.Sink
	end
	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Left then
			self.turningLeft = state == Enum.UserInputState.Begin
		elseif input.KeyCode == Enum.KeyCode.Right then
			self.turningRight = state == Enum.UserInputState.Begin
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function BaseCamera:DoPanRotateCamera(rotateAngle)
	local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1, 0, 1), rotateAngle, math.pi * 0.25)
	if angle ~= 0 then
		self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
		self.lastUserPanCamera = tick()
		self.lastCameraTransform = nil
	end
end
function BaseCamera:DoKeyboardPan(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end
	if state ~= Enum.UserInputState.Begin then
		return Enum.ContextActionResult.Pass
	end
	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Comma then
			self:DoPanRotateCamera(-math.pi * 0.1875)
		elseif input.KeyCode == Enum.KeyCode.Period then
			self:DoPanRotateCamera(math.pi * 0.1875)
		elseif input.KeyCode == Enum.KeyCode.PageUp then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(15))
			self.lastCameraTransform = nil
		elseif input.KeyCode == Enum.KeyCode.PageDown then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(-15))
			self.lastCameraTransform = nil
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function BaseCamera:DoGamepadZoom(name, state, input)
	if input.UserInputType == self.activeGamepad then
		if input.KeyCode == Enum.KeyCode.ButtonR3 then
			if state == Enum.UserInputState.Begin and self.distanceChangeEnabled then
				if self:GetCameraToSubjectDistance() > 0.5 then
					self:SetCameraToSubjectDistance(0)
				else
					self:SetCameraToSubjectDistance(10)
				end
			end
		elseif input.KeyCode == Enum.KeyCode.DPadLeft then
			self.dpadLeftDown = state == Enum.UserInputState.Begin
		elseif input.KeyCode == Enum.KeyCode.DPadRight then
			self.dpadRightDown = state == Enum.UserInputState.Begin
		end
		if self.dpadLeftDown then
			self.currentZoomSpeed = 1.04
		elseif self.dpadRightDown then
			self.currentZoomSpeed = 0.96
		else
			self.currentZoomSpeed = 1
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function BaseCamera:DoKeyboardZoom(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end
	if state ~= Enum.UserInputState.Begin then
		return Enum.ContextActionResult.Pass
	end
	if self.distanceChangeEnabled and Players.LocalPlayer.CameraMode ~= Enum.CameraMode.LockFirstPerson then
		if input.KeyCode == Enum.KeyCode.I then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance - 5)
		elseif input.KeyCode == Enum.KeyCode.O then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance + 5)
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function BaseCamera:BindAction(actionName, actionFunc, createTouchButton, ...)
	table.insert(self.boundContextActions, actionName)
	ContextActionService:BindActionAtPriority(actionName, actionFunc, createTouchButton, CAMERA_ACTION_PRIORITY, ...)
end
function BaseCamera:BindGamepadInputActions()
	if FFlagPlayerScriptsBindAtPriority2 then
		self:BindAction("BaseCameraGamepadPan", function(name, state, input)
			return self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		self:BindAction("BaseCameraGamepadZoom", function(name, state, input)
			return self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.DPadLeft, Enum.KeyCode.DPadRight, Enum.KeyCode.ButtonR3)
	else
		ContextActionService:BindAction("RootCamGamepadPan", function(name, state, input)
			self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		ContextActionService:BindAction("RootCamGamepadZoom", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonR3)
		ContextActionService:BindAction("RootGamepadZoomOut", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.DPadLeft)
		ContextActionService:BindAction("RootGamepadZoomIn", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.DPadRight)
	end
end
function BaseCamera:BindKeyboardInputActions()
	self:BindAction("BaseCameraKeyboardPanArrowKeys", function(name, state, input)
		return self:DoKeyboardPanTurn(name, state, input)
	end, false, Enum.KeyCode.Left, Enum.KeyCode.Right)
	self:BindAction("BaseCameraKeyboardPan", function(name, state, input)
		return self:DoKeyboardPan(name, state, input)
	end, false, Enum.KeyCode.Comma, Enum.KeyCode.Period, Enum.KeyCode.PageUp, Enum.KeyCode.PageDown)
	self:BindAction("BaseCameraKeyboardZoom", function(name, state, input)
		return self:DoKeyboardZoom(name, state, input)
	end, false, Enum.KeyCode.I, Enum.KeyCode.O)
end
function BaseCamera:OnTouchBegan(input, processed)
	local canUseDynamicTouch = self.isDynamicThumbstickEnabled and not processed
	if canUseDynamicTouch then
		self.fingerTouches[input] = processed
		if not processed then
			self.inputStartPositions[input] = input.Position
			self.inputStartTimes[input] = tick()
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
end
function BaseCamera:OnTouchChanged(input, processed)
	if self.fingerTouches[input] == nil then
		if self.isDynamicThumbstickEnabled then
			return
		end
		self.fingerTouches[input] = processed
		if not processed then
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	elseif FFlagDynamicThumbstickUseContextActionSevice and self.isDynamicThumbstickEnabled and self.fingerTouches[input] ~= processed then
		self.fingerTouches[input] = processed
		if processed then
			self.numUnsunkTouches = self.numUnsunkTouches - 1
		else
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
	if self.numUnsunkTouches == 1 then
		if self.fingerTouches[input] == false then
			self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
			self.startPos = self.startPos or input.Position
			self.lastPos = self.lastPos or self.startPos
			self.userPanningTheCamera = true
			local delta = input.Position - self.lastPos
			delta = Vector2.new(delta.X, delta.Y * UserGameSettings:GetCameraYInvertValue())
			if self.panEnabled then
				local desiredXYVector = self:InputTranslationToCameraAngleChange(delta, TOUCH_SENSITIVTY)
				self.rotateInput = self.rotateInput + desiredXYVector
			end
			self.lastPos = input.Position
		end
	else
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
	end
	if self.numUnsunkTouches == 2 then
		local unsunkTouches = {}
		for touch, wasSunk in pairs(self.fingerTouches) do
			if not wasSunk then
				table.insert(unsunkTouches, touch)
			end
		end
		if #unsunkTouches == 2 then
			local difference = (unsunkTouches[1].Position - unsunkTouches[2].Position).magnitude
			if self.startingDiff and self.pinchBeginZoom then
				local scale = difference / math.max(0.01, self.startingDiff)
				local clampedScale = Util.Clamp(0.1, 10, scale)
				if self.distanceChangeEnabled then
					self:SetCameraToSubjectDistance(self.pinchBeginZoom / clampedScale)
				end
			else
				self.startingDiff = difference
				self.pinchBeginZoom = self:GetCameraToSubjectDistance()
			end
		end
	else
		self.startingDiff = nil
		self.pinchBeginZoom = nil
	end
end
function BaseCamera:CalcLookBehindRotateInput()
	if not self.humanoidRootPart or not game.Workspace.CurrentCamera then
		return nil
	end
	local cameraLookVector = game.Workspace.CurrentCamera.CFrame.lookVector
	local newDesiredLook = (self.humanoidRootPart.CFrame.lookVector - Vector3.new(0, 0.23, 0)).unit
	local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, cameraLookVector)
	local vertShift = math.asin(cameraLookVector.Y) - math.asin(newDesiredLook.Y)
	if not Util.IsFinite(horizontalShift) then
		horizontalShift = 0
	end
	if not Util.IsFinite(vertShift) then
		vertShift = 0
	end
	return Vector2.new(horizontalShift, vertShift)
end
function BaseCamera:OnTouchTap(position)
	if self.isDynamicThumbstickEnabled and not self.isAToolEquipped then
		if self.lastTapTime and tick() - self.lastTapTime < MAX_TIME_FOR_DOUBLE_TAP then
			self:SetCameraToSubjectDistance(self.defaultSubjectDistance)
		elseif self.humanoidRootPart then
			self.rotateInput = self:CalcLookBehindRotateInput()
		end
		self.lastTapTime = tick()
	end
end
function BaseCamera:IsTouchTap(input)
	if self.inputStartPositions[input] then
		local posDelta = (self.inputStartPositions[input] - input.Position).magnitude
		if posDelta < MAX_TAP_POS_DELTA then
			local timeDelta = self.inputStartTimes[input] - tick()
			if timeDelta < MAX_TAP_TIME_DELTA then
				return true
			end
		end
	end
	return false
end
function BaseCamera:OnTouchEnded(input, processed)
	if self.fingerTouches[input] == false then
		if self.numUnsunkTouches == 1 then
			self.panBeginLook = nil
			self.startPos = nil
			self.lastPos = nil
			self.userPanningTheCamera = false
			if not FFlagUserNoDynamicThumbstickRecenter and self:IsTouchTap(input) then
				self:OnTouchTap(input.Position)
			end
		elseif self.numUnsunkTouches == 2 then
			self.startingDiff = nil
			self.pinchBeginZoom = nil
		end
	end
	if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
		self.numUnsunkTouches = self.numUnsunkTouches - 1
	end
	self.fingerTouches[input] = nil
	self.inputStartPositions[input] = nil
	self.inputStartTimes[input] = nil
end
function BaseCamera:OnMouse2Down(input, processed)
	if processed then
		return
	end
	self.isRightMouseDown = true
	self:OnMousePanButtonPressed(input, processed)
end
function BaseCamera:OnMouse2Up(input, processed)
	self.isRightMouseDown = false
	self:OnMousePanButtonReleased(input, processed)
end
function BaseCamera:OnMouse3Down(input, processed)
	if processed then
		return
	end
	self.isMiddleMouseDown = true
	self:OnMousePanButtonPressed(input, processed)
end
function BaseCamera:OnMouse3Up(input, processed)
	self.isMiddleMouseDown = false
	self:OnMousePanButtonReleased(input, processed)
end
function BaseCamera:OnMouseMoved(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end
	local inputDelta = input.Delta
	inputDelta = Vector2.new(inputDelta.X, inputDelta.Y * UserGameSettings:GetCameraYInvertValue())
	if self.panEnabled and (self.startPos and self.lastPos and self.panBeginLook or self.inFirstPerson or self.inMouseLockedMode) then
		local desiredXYVector = self:InputTranslationToCameraAngleChange(inputDelta, MOUSE_SENSITIVITY)
		self.rotateInput = self.rotateInput + desiredXYVector
	end
	if self.startPos and self.lastPos and self.panBeginLook then
		self.lastPos = self.lastPos + input.Delta
	end
end
function BaseCamera:OnMousePanButtonPressed(input, processed)
	if processed then
		return
	end
	self:UpdateMouseBehavior()
	self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
	self.startPos = self.startPos or input.Position
	self.lastPos = self.lastPos or self.startPos
	self.userPanningTheCamera = true
end
function BaseCamera:OnMousePanButtonReleased(input, processed)
	self:UpdateMouseBehavior()
	if not self.isRightMouseDown and not self.isMiddleMouseDown then
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
	end
end
function BaseCamera:OnMouseWheel(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end
	if not processed and self.distanceChangeEnabled then
		local wheelInput = Util.Clamp(-1, 1, -input.Position.Z)
		local newDistance
		if self.inFirstPerson and wheelInput > 0 then
			newDistance = FIRST_PERSON_DISTANCE_THRESHOLD
		else
			newDistance = self.currentSubjectDistance + 0.156 * self.currentSubjectDistance * wheelInput + 1.7 * math.sign(wheelInput)
		end
		self:SetCameraToSubjectDistance(newDistance)
	end
end
function BaseCamera:OnKeyDown(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end
	if processed then
		return
	end
	if self.distanceChangeEnabled then
		if input.KeyCode == Enum.KeyCode.I then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance - 5)
		elseif input.KeyCode == Enum.KeyCode.O then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance + 5)
		end
	end
	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Left then
			self.turningLeft = true
		elseif input.KeyCode == Enum.KeyCode.Right then
			self.turningRight = true
		elseif input.KeyCode == Enum.KeyCode.Comma then
			local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1, 0, 1), -math.pi * 0.1875, math.pi * 0.25)
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
				self.lastUserPanCamera = tick()
				self.lastCameraTransform = nil
			end
		elseif input.KeyCode == Enum.KeyCode.Period then
			local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1, 0, 1), math.pi * 0.1875, math.pi * 0.25)
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
				self.lastUserPanCamera = tick()
				self.lastCameraTransform = nil
			end
		elseif input.KeyCode == Enum.KeyCode.PageUp then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(15))
			self.lastCameraTransform = nil
		elseif input.KeyCode == Enum.KeyCode.PageDown then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(-15))
			self.lastCameraTransform = nil
		end
	end
end
function BaseCamera:OnKeyUp(input, processed)
	if input.KeyCode == Enum.KeyCode.Left then
		self.turningLeft = false
	elseif input.KeyCode == Enum.KeyCode.Right then
		self.turningRight = false
	end
end
function BaseCamera:UpdateMouseBehavior()
	if self.inFirstPerson or self.inMouseLockedMode then
		UserGameSettings.RotationType = Enum.RotationType.CameraRelative
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	else
		UserGameSettings.RotationType = Enum.RotationType.MovementRelative
		if self.isRightMouseDown or self.isMiddleMouseDown then
			UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		else
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	end
end
function BaseCamera:UpdateForDistancePropertyChange()
	self:SetCameraToSubjectDistance(self.currentSubjectDistance)
end
function BaseCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	local player = Players.LocalPlayer
	local lastSubjectDistance = self.currentSubjectDistance
	if player.CameraMode == Enum.CameraMode.LockFirstPerson then
		self.currentSubjectDistance = 0.5
		if not self.inFirstPerson then
			self:EnterFirstPerson()
		end
	else
		local newSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, desiredSubjectDistance)
		if newSubjectDistance < FIRST_PERSON_DISTANCE_THRESHOLD then
			self.currentSubjectDistance = 0.5
			if not self.inFirstPerson then
				self:EnterFirstPerson()
			end
		else
			self.currentSubjectDistance = newSubjectDistance
			if self.inFirstPerson then
				self:LeaveFirstPerson()
			end
		end
	end
	ZoomController.SetZoomParameters(self.currentSubjectDistance, math.sign(desiredSubjectDistance - lastSubjectDistance))
	return self.currentSubjectDistance
end
function BaseCamera:SetCameraType(cameraType)
	self.cameraType = cameraType
end
function BaseCamera:GetCameraType()
	return self.cameraType
end
function BaseCamera:SetCameraMovementMode(cameraMovementMode)
	self.cameraMovementMode = cameraMovementMode
end
function BaseCamera:GetCameraMovementMode()
	return self.cameraMovementMode
end
function BaseCamera:SetIsMouseLocked(mouseLocked)
	self.inMouseLockedMode = mouseLocked
	self:UpdateMouseBehavior()
end
function BaseCamera:GetIsMouseLocked()
	return self.inMouseLockedMode
end
function BaseCamera:SetMouseLockOffset(offsetVector)
	self.mouseLockOffset = offsetVector
end
function BaseCamera:GetMouseLockOffset()
	return self.mouseLockOffset
end
function BaseCamera:InFirstPerson()
	return self.inFirstPerson
end
function BaseCamera:EnterFirstPerson()
end
function BaseCamera:LeaveFirstPerson()
end
function BaseCamera:GetCameraToSubjectDistance()
	return self.currentSubjectDistance
end
function BaseCamera:GetMeasuredDistanceToFocus()
	local camera = game.Workspace.CurrentCamera
	if camera then
		return (camera.CoordinateFrame.p - camera.Focus.p).magnitude
	end
	return nil
end
function BaseCamera:GetCameraLookVector()
	return game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame.lookVector or UNIT_Z
end
function BaseCamera:CalculateNewLookCFrame(suppliedLookVector)
	local currLookVector = suppliedLookVector or self:GetCameraLookVector()
	local currPitchAngle = math.asin(currLookVector.y)
	local yTheta = Util.Clamp(-MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle, self.rotateInput.y)
	local constrainedRotateInput = Vector2.new(self.rotateInput.x, yTheta)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y, 0, 0)
	return newLookCFrame
end
function BaseCamera:CalculateNewLookVector(suppliedLookVector)
	local newLookCFrame = self:CalculateNewLookCFrame(suppliedLookVector)
	return newLookCFrame.lookVector
end
function BaseCamera:CalculateNewLookVectorVR()
	local subjectPosition = self:GetSubjectPosition()
	local vecToSubject = subjectPosition - game.Workspace.CurrentCamera.CFrame.p
	local currLookVector = (vecToSubject * X1_Y0_Z1).unit
	local vrRotateInput = Vector2.new(self.rotateInput.x, 0)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local yawRotatedVector = (CFrame.Angles(0, -vrRotateInput.x, 0) * startCFrame * CFrame.Angles(-vrRotateInput.y, 0, 0)).lookVector
	return (yawRotatedVector * X1_Y0_Z1).unit
end
function BaseCamera:GetHumanoid()
	local player = Players.LocalPlayer
	local character = player and player.Character
	if character then
		local resultHumanoid = self.humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			self.humanoidCache[player] = nil
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				self.humanoidCache[player] = humanoid
			end
			return humanoid
		end
	end
	return nil
end
function BaseCamera:GetHumanoidPartToFollow(humanoid, humanoidStateType)
	if humanoidStateType == Enum.HumanoidStateType.Dead then
		local character = humanoid.Parent
		if character then
			return character:FindFirstChild("Head") or humanoid.Torso
		else
			return humanoid.Torso
		end
	else
		return humanoid.Torso
	end
end
function BaseCamera:UpdateGamepad()
	local gamepadPan = self.gamepadPanningCamera
	if gamepadPan and (self.hasGameLoaded or not VRService.VREnabled) then
		gamepadPan = Util.GamepadLinearToCurve(gamepadPan)
		local currentTime = tick()
		if gamepadPan.X ~= 0 or gamepadPan.Y ~= 0 then
			self.userPanningTheCamera = true
		elseif gamepadPan == ZERO_VECTOR2 then
			self.lastThumbstickRotate = nil
			if self.lastThumbstickPos == ZERO_VECTOR2 then
				self.currentSpeed = 0
			end
		end
		local finalConstant = 0
		if self.lastThumbstickRotate then
			if VRService.VREnabled then
				self.currentSpeed = self.vrMaxSpeed
			else
				local elapsedTime = (currentTime - self.lastThumbstickRotate) * 10
				self.currentSpeed = self.currentSpeed + self.maxSpeed * (elapsedTime * elapsedTime / self.numOfSeconds)
				if self.currentSpeed > self.maxSpeed then
					self.currentSpeed = self.maxSpeed
				end
				if self.lastVelocity then
					local velocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickRotate)
					local velocityDeltaMag = (velocity - self.lastVelocity).magnitude
					if velocityDeltaMag > 12 then
						self.currentSpeed = self.currentSpeed * (20 / velocityDeltaMag)
						if self.currentSpeed > self.maxSpeed then
							self.currentSpeed = self.maxSpeed
						end
					end
				end
			end
			finalConstant = UserGameSettings.GamepadCameraSensitivity * self.currentSpeed
			self.lastVelocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickRotate)
		end
		self.lastThumbstickPos = gamepadPan
		self.lastThumbstickRotate = currentTime
		return Vector2.new(gamepadPan.X * finalConstant, gamepadPan.Y * finalConstant * self.ySensitivity * UserGameSettings:GetCameraYInvertValue())
	end
	return ZERO_VECTOR2
end
function BaseCamera:ApplyVRTransform()
	if not VRService.VREnabled then
		return
	end
	local rootJoint = self.humanoidRootPart and self.humanoidRootPart:FindFirstChild("RootJoint")
	if not rootJoint then
		return
	end
	local cameraSubject = game.Workspace.CurrentCamera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	if self.inFirstPerson and not isInVehicle then
		local vrFrame = VRService:GetUserCFrame(Enum.UserCFrame.Head)
		local vrRotation = vrFrame - vrFrame.p
		rootJoint.C0 = CFrame.new(vrRotation:vectorToObjectSpace(vrFrame.p)) * CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	else
		rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	end
end
function BaseCamera:IsInFirstPerson()
	return self.inFirstPerson
end
function BaseCamera:ShouldUseVRRotation()
	if not VRService.VREnabled then
		return false
	end
	if not self.VRRotationIntensityAvailable and tick() - self.lastVRRotationIntensityCheckTime < 1 then
		return false
	end
	local success, vrRotationIntensity = pcall(function()
		return StarterGui:GetCore("VRRotationIntensity")
	end)
	self.VRRotationIntensityAvailable = success and vrRotationIntensity ~= nil
	self.lastVRRotationIntensityCheckTime = tick()
	self.shouldUseVRRotation = success and vrRotationIntensity ~= nil and vrRotationIntensity ~= "Smooth"
	return self.shouldUseVRRotation
end
function BaseCamera:GetVRRotationInput()
	local vrRotateSum = ZERO_VECTOR2
	local success, vrRotationIntensity = pcall(function()
		return StarterGui:GetCore("VRRotationIntensity")
	end)
	if not success then
		return
	end
	local vrGamepadRotation = self.GamepadPanningCamera or ZERO_VECTOR2
	local delayExpired = tick() - self.lastVRRotationTime >= self:GetRepeatDelayValue(vrRotationIntensity)
	if math.abs(vrGamepadRotation.x) >= self:GetActivateValue() then
		if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] then
			local sign = 1
			if vrGamepadRotation.x < 0 then
				sign = -1
			end
			vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity) * sign
			self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = true
		end
	elseif math.abs(vrGamepadRotation.x) < self:GetActivateValue() - 0.1 then
		self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = nil
	end
	if self.turningLeft then
		if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Left] then
			vrRotateSum = vrRotateSum - self:GetRotateAmountValue(vrRotationIntensity)
			self.vrRotateKeyCooldown[Enum.KeyCode.Left] = true
		end
	else
		self.vrRotateKeyCooldown[Enum.KeyCode.Left] = nil
	end
	if self.turningRight then
		if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Right] then
			vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity)
			self.vrRotateKeyCooldown[Enum.KeyCode.Right] = true
		end
	else
		self.vrRotateKeyCooldown[Enum.KeyCode.Right] = nil
	end
	if vrRotateSum ~= ZERO_VECTOR2 then
		self.lastVRRotationTime = tick()
	end
	return vrRotateSum
end
function BaseCamera:CancelCameraFreeze(keepConstraints)
	if not keepConstraints then
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 1, self.cameraTranslationConstraints.z)
	end
	if self.cameraFrozen then
		self.trackingHumanoid = nil
		self.cameraFrozen = false
	end
end
function BaseCamera:StartCameraFreeze(subjectPosition, humanoidToTrack)
	if not self.cameraFrozen then
		self.humanoidJumpOrigin = subjectPosition
		self.trackingHumanoid = humanoidToTrack
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 0, self.cameraTranslationConstraints.z)
		self.cameraFrozen = true
	end
end
function BaseCamera:OnNewCameraSubject()
	if self.subjectStateChangedConn then
		self.subjectStateChangedConn:Disconnect()
		self.subjectStateChangedConn = nil
	end
	local humanoid = workspace.CurrentCamera and workspace.CurrentCamera.CameraSubject
	if self.trackingHumanoid ~= humanoid then
		self:CancelCameraFreeze()
	end
	if humanoid and humanoid:IsA("Humanoid") then
		self.subjectStateChangedConn = humanoid.StateChanged:Connect(function(oldState, newState)
			if VRService.VREnabled and newState == Enum.HumanoidStateType.Jumping and not self.inFirstPerson then
				self:StartCameraFreeze(self:GetSubjectPosition(), humanoid)
			elseif newState ~= Enum.HumanoidStateType.Jumping and newState ~= Enum.HumanoidStateType.Freefall then
				self:CancelCameraFreeze(true)
			end
		end)
	end
end
function BaseCamera:GetVRFocus(subjectPosition, timeDelta)
	local lastFocus = self.LastCameraFocus or subjectPosition
	if not self.cameraFrozen then
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, math.min(1, self.cameraTranslationConstraints.y + 0.42 * timeDelta), self.cameraTranslationConstraints.z)
	end
	local newFocus
	if self.cameraFrozen and self.humanoidJumpOrigin and self.humanoidJumpOrigin.y > lastFocus.y then
		newFocus = CFrame.new(Vector3.new(subjectPosition.x, math.min(self.humanoidJumpOrigin.y, lastFocus.y + 5 * timeDelta), subjectPosition.z))
	else
		newFocus = CFrame.new(Vector3.new(subjectPosition.x, lastFocus.y, subjectPosition.z):lerp(subjectPosition, self.cameraTranslationConstraints.y))
	end
	if self.cameraFrozen then
		if self.inFirstPerson then
			self:CancelCameraFreeze()
		end
		if self.humanoidJumpOrigin and subjectPosition.y < self.humanoidJumpOrigin.y - 0.5 then
			self:CancelCameraFreeze()
		end
	end
	return newFocus
end
function BaseCamera:GetRotateAmountValue(vrRotationIntensity)
	vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
	if vrRotationIntensity then
		if vrRotationIntensity == "Low" then
			return VR_LOW_INTENSITY_ROTATION
		elseif vrRotationIntensity == "High" then
			return VR_HIGH_INTENSITY_ROTATION
		end
	end
	return ZERO_VECTOR2
end
function BaseCamera:GetRepeatDelayValue(vrRotationIntensity)
	vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
	if vrRotationIntensity then
		if vrRotationIntensity == "Low" then
			return VR_LOW_INTENSITY_REPEAT
		elseif vrRotationIntensity == "High" then
			return VR_HIGH_INTENSITY_REPEAT
		end
	end
	return 0
end
function BaseCamera:Test()
	print("BaseCamera:Test()")
end
function BaseCamera:Update(dt)
	warn("BaseCamera:Update() This is a virtual function that should never be getting called.")
	return game.Workspace.CurrentCamera.CFrame, game.Workspace.CurrentCamera.Focus
end
return BaseCamera
]]></ProtectedString><string name="Name">BaseCamera</string></Properties></Item><Item class="ModuleScript" referent="RBX300"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZOOM_STIFFNESS = 4.5
local ZOOM_DEFAULT = 12.5
local ZOOM_ACCELERATION = 0.0375
local MIN_FOCUS_DIST = 0.5
local DIST_OPAQUE = 1
local Popper = require(script:WaitForChild("Popper"))
local clamp = math.clamp
local exp = math.exp
local min = math.min
local max = math.max
local pi = math.pi
local cameraMinZoomDistance, cameraMaxZoomDistance
do
	local Player = game:GetService("Players").LocalPlayer
	local function updateBounds()
		cameraMinZoomDistance = Player.CameraMinZoomDistance
		cameraMaxZoomDistance = Player.CameraMaxZoomDistance
	end
	updateBounds()
	Player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(updateBounds)
	Player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(updateBounds)
end
local ConstrainedSpring = {}
ConstrainedSpring.__index = ConstrainedSpring
function ConstrainedSpring.new(freq, x, minValue, maxValue)
	x = clamp(x, minValue, maxValue)
	return setmetatable({
		freq = freq,
		x = x,
		v = 0,
		minValue = minValue,
		maxValue = maxValue,
		goal = x
	}, ConstrainedSpring)
end
function ConstrainedSpring:Step(dt)
	local freq = self.freq * 2 * pi
	local x = self.x
	local v = self.v
	local minValue = self.minValue
	local maxValue = self.maxValue
	local goal = self.goal
	local offset = goal - x
	local step = freq * dt
	local decay = exp(-step)
	local x1 = goal + (v * dt - offset * (step + 1)) * decay
	local v1 = ((offset * freq - v) * step + v) * decay
	if minValue > x1 then
		x1 = minValue
		v1 = 0
	elseif maxValue < x1 then
		x1 = maxValue
		v1 = 0
	end
	self.x = x1
	self.v = v1
	return x1
end
local zoomSpring = ConstrainedSpring.new(ZOOM_STIFFNESS, ZOOM_DEFAULT, MIN_FOCUS_DIST, cameraMaxZoomDistance)
local function stepTargetZoom(z, dz, zoomMin, zoomMax)
	z = clamp(z + dz * (1 + z * ZOOM_ACCELERATION), zoomMin, zoomMax)
	if z < DIST_OPAQUE then
		z = dz <= 0 and zoomMin or DIST_OPAQUE
	end
	return z
end
local zoomDelta = 0
local Zoom = {}
function Zoom.Update(renderDt, focus, extrapolation)
	local poppedZoom = math.huge
	if zoomSpring.goal > DIST_OPAQUE then
		local maxPossibleZoom = max(zoomSpring.x, stepTargetZoom(zoomSpring.goal, zoomDelta, cameraMinZoomDistance, cameraMaxZoomDistance))
		poppedZoom = Popper(focus * CFrame.new(0, 0, MIN_FOCUS_DIST), maxPossibleZoom - MIN_FOCUS_DIST, extrapolation) + MIN_FOCUS_DIST
	end
	zoomSpring.minValue = MIN_FOCUS_DIST
	zoomSpring.maxValue = min(cameraMaxZoomDistance, poppedZoom)
	return zoomSpring:Step(renderDt)
end
function Zoom.SetZoomParameters(targetZoom, newZoomDelta)
	zoomSpring.goal = targetZoom
	zoomDelta = newZoomDelta
end
return Zoom
]]></ProtectedString><string name="Name">ZoomController</string></Properties><Item class="ModuleScript" referent="RBX304"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local FFlagUserPoppercamLooseOpacityThreshold
do
	local success, enabled = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserPoppercamLooseOpacityThreshold")
	end)
	FFlagUserPoppercamLooseOpacityThreshold = success and enabled
end
local camera = game.Workspace.CurrentCamera
local min = math.min
local tan = math.tan
local rad = math.rad
local inf = math.huge
local ray = Ray.new
local eraseFromEnd = function(t, toSize)
	for i = #t, toSize + 1, -1 do
		t[i] = nil
	end
end
local nearPlaneZ, projX, projY
do
	local function updateProjection()
		local fov = rad(camera.FieldOfView)
		local view = camera.ViewportSize
		local ar = view.X / view.Y
		projY = 2 * tan(fov / 2)
		projX = ar * projY
	end
	camera:GetPropertyChangedSignal("FieldOfView"):Connect(updateProjection)
	camera:GetPropertyChangedSignal("ViewportSize"):Connect(updateProjection)
	updateProjection()
	nearPlaneZ = camera.NearPlaneZ
	camera:GetPropertyChangedSignal("NearPlaneZ"):Connect(function()
		nearPlaneZ = camera.NearPlaneZ
	end)
end
local blacklist = {}
do
	local charMap = {}
	local function refreshIgnoreList()
		local n = 1
		blacklist = {}
		for _, character in pairs(charMap) do
			blacklist[n] = character
			n = n + 1
		end
	end
	local function playerAdded(player)
		local function characterAdded(character)
			charMap[player] = character
			refreshIgnoreList()
		end
		local function characterRemoving()
			charMap[player] = nil
			refreshIgnoreList()
		end
		player.CharacterAdded:Connect(characterAdded)
		player.CharacterRemoving:Connect(characterRemoving)
		if player.Character then
			characterAdded(player.Character)
		end
	end
	local function playerRemoving(player)
		charMap[player] = nil
		refreshIgnoreList()
	end
	Players.PlayerAdded:Connect(playerAdded)
	Players.PlayerRemoving:Connect(playerRemoving)
	for _, player in ipairs(Players:GetPlayers()) do
		playerAdded(player)
	end
	refreshIgnoreList()
end
local subjectRoot, subjectPart
camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
	local subject = camera.CameraSubject
	if subject:IsA("Humanoid") then
		subjectPart = subject.RootPart
	elseif subject:IsA("BasePart") then
		subjectPart = subject
	else
		subjectPart = nil
	end
end)
local function canOcclude(part)
	if FFlagUserPoppercamLooseOpacityThreshold then
		return part.Transparency < 0.25 and part.CanCollide and subjectRoot ~= (part:GetRootPart() or part) and not part:IsA("TrussPart")
	else
		return part.Transparency < 0.95 and part.CanCollide and subjectRoot ~= (part:GetRootPart() or part)
	end
end
local SCAN_SAMPLE_OFFSETS = {
	Vector2.new(0.4, 0),
	Vector2.new(-0.4, 0),
	Vector2.new(0, -0.4),
	Vector2.new(0, 0.4),
	Vector2.new(0, 0.2)
}
local function getCollisionPoint(origin, dir)
	local originalSize = #blacklist
	repeat
		local hitPart, hitPoint = workspace:FindPartOnRayWithIgnoreList(ray(origin, dir), blacklist, false, true)
		if hitPart then
			if hitPart.CanCollide then
				eraseFromEnd(blacklist, originalSize)
				return hitPoint, true
			end
			blacklist[#blacklist + 1] = hitPart
		end
	until not hitPart
	eraseFromEnd(blacklist, originalSize)
	return origin + dir, false
end
local function queryPoint(origin, unitDir, dist, lastPos)
	debug.profilebegin("queryPoint")
	local originalSize = #blacklist
	dist = dist + nearPlaneZ
	local target = origin + unitDir * dist
	local softLimit = inf
	local hardLimit = inf
	local movingOrigin = origin
	repeat
		local entryPart, entryPos = workspace:FindPartOnRayWithIgnoreList(ray(movingOrigin, target - movingOrigin), blacklist, false, true)
		if entryPart then
			if canOcclude(entryPart) then
				local wl = {entryPart}
				local exitPart = workspace:FindPartOnRayWithWhitelist(ray(target, entryPos - target), wl, true)
				local lim = (entryPos - origin).Magnitude
				if exitPart then
					local promote = false
					if lastPos then
						promote = workspace:FindPartOnRayWithWhitelist(ray(lastPos, target - lastPos), wl, true) or workspace:FindPartOnRayWithWhitelist(ray(target, lastPos - target), wl, true)
					end
					if promote then
						hardLimit = lim
					elseif dist < softLimit then
						softLimit = lim
					end
				else
					hardLimit = lim
				end
			end
			blacklist[#blacklist + 1] = entryPart
			movingOrigin = entryPos - unitDir * 0.001
		end
	until hardLimit < inf or not entryPart
	eraseFromEnd(blacklist, originalSize)
	debug.profileend()
	return softLimit - nearPlaneZ, hardLimit - nearPlaneZ
end
local function queryViewport(focus, dist)
	debug.profilebegin("queryViewport")
	local fP = focus.p
	local fX = focus.rightVector
	local fY = focus.upVector
	local fZ = -focus.lookVector
	local viewport = camera.ViewportSize
	local hardBoxLimit = inf
	local softBoxLimit = inf
	for viewX = 0, 1 do
		local worldX = fX * ((viewX - 0.5) * projX)
		for viewY = 0, 1 do
			local worldY = fY * ((viewY - 0.5) * projY)
			local origin = fP + nearPlaneZ * (worldX + worldY)
			local lastPos = camera:ViewportPointToRay(viewport.x * viewX, viewport.y * viewY).Origin
			local softPointLimit, hardPointLimit = queryPoint(origin, fZ, dist, lastPos)
			if hardBoxLimit > hardPointLimit then
				hardBoxLimit = hardPointLimit
			end
			if softBoxLimit > softPointLimit then
				softBoxLimit = softPointLimit
			end
		end
	end
	debug.profileend()
	return softBoxLimit, hardBoxLimit
end
local function testPromotion(focus, dist, focusExtrapolation)
	debug.profilebegin("testPromotion")
	local fP = focus.p
	local fX = focus.rightVector
	local fY = focus.upVector
	local fZ = -focus.lookVector
	debug.profilebegin("extrapolate")
	do
		local SAMPLE_DT = 0.0625
		local SAMPLE_MAX_T = 1.25
		local maxDist = (getCollisionPoint(fP, focusExtrapolation.posVelocity * SAMPLE_MAX_T) - fP).Magnitude
		local combinedSpeed = focusExtrapolation.posVelocity.magnitude
		for dt = 0, min(SAMPLE_MAX_T, focusExtrapolation.rotVelocity.magnitude + maxDist / combinedSpeed), SAMPLE_DT do
			local cfDt = focusExtrapolation.extrapolate(dt)
			if dist <= queryPoint(cfDt.p, -cfDt.lookVector, dist) then
				return false
			end
		end
		debug.profileend()
	end
	debug.profilebegin("testOffsets")
	for _, offset in ipairs(SCAN_SAMPLE_OFFSETS) do
		local scaledOffset = offset
		local pos, isHit = getCollisionPoint(fP, fX * scaledOffset.x + fY * scaledOffset.y)
		if queryPoint(pos, (fP + fZ * dist - pos).Unit, dist) == inf then
			return false
		end
	end
	debug.profileend()
	debug.profileend()
	return true
end
local function Popper(focus, targetDist, focusExtrapolation)
	debug.profilebegin("popper")
	subjectRoot = subjectPart and subjectPart:GetRootPart() or subjectPart
	local dist = targetDist
	local soft, hard = queryViewport(focus, targetDist)
	if dist > hard then
		dist = hard
	end
	if soft < dist and testPromotion(focus, targetDist, focusExtrapolation) then
		dist = soft
	end
	subjectRoot = nil
	debug.profileend()
	return dist
end
return Popper
]]></ProtectedString><string name="Name">Popper</string></Properties></Item></Item><Item class="ModuleScript" referent="RBX310"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local DEFAULT_MOUSE_LOCK_CURSOR = "rbxasset://textures/MouseLockedCursor.png"
local CONTEXT_ACTION_NAME = "MouseLockSwitchAction"
local MOUSELOCK_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local Settings = UserSettings()
local GameSettings = Settings.GameSettings
local Mouse = PlayersService.LocalPlayer:GetMouse()
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local MouseLockController = {}
MouseLockController.__index = MouseLockController
function MouseLockController.new()
	local self = setmetatable({}, MouseLockController)
	self.inputBeganConn = nil
	self.isMouseLocked = false
	self.savedMouseCursor = nil
	self.boundKeys = {
		Enum.KeyCode.LeftShift,
		Enum.KeyCode.RightShift
	}
	self.mouseLockToggledEvent = Instance.new("BindableEvent")
	local boundKeysObj = script:FindFirstChild("BoundKeys")
	if not boundKeysObj or not boundKeysObj:IsA("StringValue") then
		if boundKeysObj then
			boundKeysObj:Destroy()
		end
		boundKeysObj = Instance.new("StringValue")
		boundKeysObj.Name = "BoundKeys"
		boundKeysObj.Value = "LeftShift,RightShift"
		boundKeysObj.Parent = script
	end
	if boundKeysObj then
		boundKeysObj.Changed:Connect(function(value)
			self:OnBoundKeysObjectChanged(value)
		end)
		self:OnBoundKeysObjectChanged(boundKeysObj.Value)
	end
	GameSettings.Changed:Connect(function(property)
		if property == "ControlMode" or property == "ComputerMovementMode" then
			self:UpdateMouseLockAvailability()
		end
	end)
	PlayersService.LocalPlayer:GetPropertyChangedSignal("DevEnableMouseLock"):Connect(function()
		self:UpdateMouseLockAvailability()
	end)
	PlayersService.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
		self:UpdateMouseLockAvailability()
	end)
	self:UpdateMouseLockAvailability()
	return self
end
function MouseLockController:GetIsMouseLocked()
	return self.isMouseLocked
end
function MouseLockController:GetBindableToggleEvent()
	return self.mouseLockToggledEvent.Event
end
function MouseLockController:GetMouseLockOffset()
	local offsetValueObj = script:FindFirstChild("CameraOffset")
	if offsetValueObj and offsetValueObj:IsA("Vector3Value") then
		return offsetValueObj.Value
	else
		if offsetValueObj then
			offsetValueObj:Destroy()
		end
		offsetValueObj = Instance.new("Vector3Value")
		offsetValueObj.Name = "CameraOffset"
		offsetValueObj.Value = Vector3.new(1.75, 0, 0)
		offsetValueObj.Parent = script
	end
	if offsetValueObj and offsetValueObj.Value then
		return offsetValueObj.Value
	end
	return Vector3.new(1.75, 0, 0)
end
function MouseLockController:UpdateMouseLockAvailability()
	local devAllowsMouseLock = PlayersService.LocalPlayer.DevEnableMouseLock
	local devMovementModeIsScriptable = PlayersService.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable
	local userHasMouseLockModeEnabled = GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch
	local userHasClickToMoveEnabled = GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove
	local MouseLockAvailable = devAllowsMouseLock and userHasMouseLockModeEnabled and not userHasClickToMoveEnabled and not devMovementModeIsScriptable
	if MouseLockAvailable ~= self.enabled then
		self:EnableMouseLock(MouseLockAvailable)
	end
end
function MouseLockController:OnBoundKeysObjectChanged(newValue)
	self.boundKeys = {}
	for token in string.gmatch(newValue, "[^%s,]+") do
		for keyCode, keyEnum in pairs(Enum.KeyCode:GetEnumItems()) do
			if token == keyEnum.Name then
				self.boundKeys[#self.boundKeys + 1] = keyEnum
				break
			end
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		self:UnbindContextActions()
		self:BindContextActions()
	end
end
function MouseLockController:OnMouseLockToggled()
	self.isMouseLocked = not self.isMouseLocked
	if self.isMouseLocked then
		local cursorImageValueObj = script:FindFirstChild("CursorImage")
		if cursorImageValueObj and cursorImageValueObj:IsA("StringValue") and cursorImageValueObj.Value then
			self.savedMouseCursor = Mouse.Icon
			Mouse.Icon = cursorImageValueObj.Value
		else
			if cursorImageValueObj then
				cursorImageValueObj:Destroy()
			end
			cursorImageValueObj = Instance.new("StringValue")
			cursorImageValueObj.Name = "CursorImage"
			cursorImageValueObj.Value = DEFAULT_MOUSE_LOCK_CURSOR
			cursorImageValueObj.Parent = script
			self.savedMouseCursor = Mouse.Icon
			Mouse.Icon = DEFAULT_MOUSE_LOCK_CURSOR
		end
	elseif self.savedMouseCursor then
		Mouse.Icon = self.savedMouseCursor
		self.savedMouseCursor = nil
	end
	self.mouseLockToggledEvent:Fire()
end
function MouseLockController:OnInputBegan(input, processed)
	if processed then
		return
	end
	if input.UserInputType == Enum.UserInputType.Keyboard then
		for _, keyCode in pairs(self.boundKeys) do
			if keyCode == input.KeyCode then
				self:OnMouseLockToggled()
				return
			end
		end
	end
end
function MouseLockController:DoMouseLockSwitch(name, state, input)
	if state == Enum.UserInputState.Begin then
		self:OnMouseLockToggled()
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function MouseLockController:BindContextActions()
	ContextActionService:BindActionAtPriority(CONTEXT_ACTION_NAME, function(name, state, input)
		return self:DoMouseLockSwitch(name, state, input)
	end, false, MOUSELOCK_ACTION_PRIORITY, unpack(self.boundKeys))
end
function MouseLockController:UnbindContextActions()
	ContextActionService:UnbindAction(CONTEXT_ACTION_NAME)
end
function MouseLockController:IsMouseLocked()
	return self.enabled and self.isMouseLocked
end
function MouseLockController:EnableMouseLock(enable)
	if enable ~= self.enabled then
		self.enabled = enable
		if self.enabled then
			if FFlagPlayerScriptsBindAtPriority2 then
				self:BindContextActions()
			else
				if self.inputBeganConn then
					self.inputBeganConn:Disconnect()
				end
				self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
					self:OnInputBegan(input, processed)
				end)
			end
		else
			if Mouse.Icon ~= "" then
				Mouse.Icon = ""
			end
			if FFlagPlayerScriptsBindAtPriority2 then
				self:UnbindContextActions()
			else
				if self.inputBeganConn then
					self.inputBeganConn:Disconnect()
				end
				self.inputBeganConn = nil
			end
			if self.isMouseLocked then
				self.mouseLockToggledEvent:Fire()
			end
			self.isMouseLocked = false
		end
	end
end
return MouseLockController
]]></ProtectedString><string name="Name">MouseLockController</string></Properties></Item><Item class="ModuleScript" referent="RBX315"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local POP_RESTORE_RATE = 0.3
local MIN_CAMERA_ZOOM = 0.5
local VALID_SUBJECTS = {
	"Humanoid",
	"VehicleSeat",
	"SkateboardPlatform"
}
local portraitPopperFixFlagExists, portraitPopperFixFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPortraitPopperFix")
end)
local FFlagUserPortraitPopperFix = portraitPopperFixFlagExists and portraitPopperFixFlagEnabled
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Poppercam = setmetatable({}, BaseOcclusion)
Poppercam.__index = Poppercam
function Poppercam.new()
	local self = setmetatable(BaseOcclusion.new(), Poppercam)
	self.camera = nil
	self.cameraSubjectChangeConn = nil
	self.subjectPart = nil
	self.playerCharacters = {}
	self.vehicleParts = {}
	self.lastPopAmount = 0
	self.lastZoomLevel = 0
	self.popperEnabled = false
	return self
end
function Poppercam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Zoom
end
function Poppercam:Enable(enable)
end
function Poppercam:CharacterAdded(char, player)
	self.playerCharacters[player] = char
end
function Poppercam:CharacterRemoving(char, player)
	self.playerCharacters[player] = nil
end
function Poppercam:Update(dt, desiredCameraCFrame, desiredCameraFocus)
	if self.popperEnabled then
		self.camera = game.Workspace.CurrentCamera
		local newCameraCFrame = desiredCameraCFrame
		local focusPoint = desiredCameraFocus.p
		if FFlagUserPortraitPopperFix and self.subjectPart then
			focusPoint = self.subjectPart.CFrame.p
		end
		local ignoreList = {}
		for _, character in pairs(self.playerCharacters) do
			ignoreList[#ignoreList + 1] = character
		end
		for i = 1, #self.vehicleParts do
			ignoreList[#ignoreList + 1] = self.vehicleParts[i]
		end
		local prevCameraCFrame = self.camera.CFrame
		self.camera.CFrame = desiredCameraCFrame
		self.camera.Focus = desiredCameraFocus
		local largest = self.camera:GetLargestCutoffDistance(ignoreList)
		local zoomLevel = (desiredCameraCFrame.p - focusPoint).Magnitude
		if math.abs(zoomLevel - self.lastZoomLevel) > 0.001 then
			self.lastPopAmount = 0
		end
		local popAmount = largest
		if popAmount < self.lastPopAmount then
			popAmount = self.lastPopAmount
		end
		if popAmount > 0 then
			newCameraCFrame = desiredCameraCFrame + desiredCameraCFrame.lookVector * popAmount
			self.lastPopAmount = popAmount - POP_RESTORE_RATE
			if self.lastPopAmount < 0 then
				self.lastPopAmount = 0
			end
		end
		self.lastZoomLevel = zoomLevel
		return newCameraCFrame, desiredCameraFocus
	end
	return desiredCameraCFrame, desiredCameraFocus
end
function Poppercam:OnCameraSubjectChanged(newSubject)
	self.vehicleParts = {}
	self.lastPopAmount = 0
	if newSubject then
		self.popperEnabled = false
		for _, subjectType in pairs(VALID_SUBJECTS) do
			if newSubject:IsA(subjectType) then
				self.popperEnabled = true
				break
			end
		end
		if newSubject:IsA("VehicleSeat") then
			self.vehicleParts = newSubject:GetConnectedParts(true)
		end
		if FFlagUserPortraitPopperFix then
			if newSubject:IsA("BasePart") then
				self.subjectPart = newSubject
			elseif newSubject:IsA("Model") then
				if newSubject.PrimaryPart then
					self.subjectPart = newSubject.PrimaryPart
				else
					for _, child in pairs(newSubject:GetChildren()) do
						if child:IsA("BasePart") then
							self.subjectPart = child
							break
						end
					end
				end
			elseif newSubject:IsA("Humanoid") then
				self.subjectPart = newSubject.RootPart
			end
		end
	end
end
return Poppercam
]]></ProtectedString><string name="Name">Poppercam_Classic</string></Properties></Item><Item class="ModuleScript" referent="RBX320"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local MAX_TWEEN_RATE = 2.8
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local TransparencyController = {}
TransparencyController.__index = TransparencyController
function TransparencyController.new()
	local self = setmetatable({}, TransparencyController)
	self.lastUpdate = tick()
	self.transparencyDirty = false
	self.enabled = false
	self.lastTransparency = nil
	self.descendantAddedConn, self.descendantRemovingConn = nil, nil
	self.toolDescendantAddedConns = {}
	self.toolDescendantRemovingConns = {}
	self.cachedParts = {}
	return self
end
function TransparencyController:HasToolAncestor(object)
	if object.Parent == nil then
		return false
	end
	return object.Parent:IsA("Tool") or self:HasToolAncestor(object.Parent)
end
function TransparencyController:IsValidPartToModify(part)
	if part:IsA("BasePart") or part:IsA("Decal") then
		return not self:HasToolAncestor(part)
	end
	return false
end
function TransparencyController:CachePartsRecursive(object)
	if object then
		if self:IsValidPartToModify(object) then
			self.cachedParts[object] = true
			self.transparencyDirty = true
		end
		for _, child in pairs(object:GetChildren()) do
			self:CachePartsRecursive(child)
		end
	end
end
function TransparencyController:TeardownTransparency()
	for child, _ in pairs(self.cachedParts) do
		child.LocalTransparencyModifier = 0
	end
	self.cachedParts = {}
	self.transparencyDirty = true
	self.lastTransparency = nil
	if self.descendantAddedConn then
		self.descendantAddedConn:disconnect()
		self.descendantAddedConn = nil
	end
	if self.descendantRemovingConn then
		self.descendantRemovingConn:disconnect()
		self.descendantRemovingConn = nil
	end
	for object, conn in pairs(self.toolDescendantAddedConns) do
		conn:Disconnect()
		self.toolDescendantAddedConns[object] = nil
	end
	for object, conn in pairs(self.toolDescendantRemovingConns) do
		conn:Disconnect()
		self.toolDescendantRemovingConns[object] = nil
	end
end
function TransparencyController:SetupTransparency(character)
	self:TeardownTransparency()
	if self.descendantAddedConn then
		self.descendantAddedConn:disconnect()
	end
	self.descendantAddedConn = character.DescendantAdded:Connect(function(object)
		if self:IsValidPartToModify(object) then
			self.cachedParts[object] = true
			self.transparencyDirty = true
		elseif object:IsA("Tool") then
			if self.toolDescendantAddedConns[object] then
				self.toolDescendantAddedConns[object]:Disconnect()
			end
			self.toolDescendantAddedConns[object] = object.DescendantAdded:Connect(function(toolChild)
				self.cachedParts[toolChild] = nil
				if toolChild:IsA("BasePart") or toolChild:IsA("Decal") then
					toolChild.LocalTransparencyModifier = 0
				end
			end)
			if self.toolDescendantRemovingConns[object] then
				self.toolDescendantRemovingConns[object]:disconnect()
			end
			self.toolDescendantRemovingConns[object] = object.DescendantRemoving:Connect(function(formerToolChild)
				wait()
				if character and formerToolChild and formerToolChild:IsDescendantOf(character) and self:IsValidPartToModify(formerToolChild) then
					self.cachedParts[formerToolChild] = true
					self.transparencyDirty = true
				end
			end)
		end
	end)
	if self.descendantRemovingConn then
		self.descendantRemovingConn:disconnect()
	end
	self.descendantRemovingConn = character.DescendantRemoving:connect(function(object)
		if self.cachedParts[object] then
			self.cachedParts[object] = nil
			object.LocalTransparencyModifier = 0
		end
	end)
	self:CachePartsRecursive(character)
end
function TransparencyController:Enable(enable)
	if self.enabled ~= enable then
		self.enabled = enable
		self:Update()
	end
end
function TransparencyController:SetSubject(subject)
	local character
	if subject and subject:IsA("Humanoid") then
		character = subject.Parent
	end
	if subject and subject:IsA("VehicleSeat") and subject.Occupant then
		character = subject.Occupant.Parent
	end
	if character then
		self:SetupTransparency(character)
	else
		self:TeardownTransparency()
	end
end
function TransparencyController:Update()
	local instant = false
	local now = tick()
	local currentCamera = workspace.CurrentCamera
	if currentCamera then
		local transparency = 0
		if not self.enabled then
			instant = true
		else
			local distance = (currentCamera.Focus.p - currentCamera.CoordinateFrame.p).magnitude
			transparency = distance < 2 and 1 - (distance - 0.5) / 1.5 or 0
			if transparency < 0.5 then
				transparency = 0
			end
			if self.lastTransparency then
				local deltaTransparency = transparency - self.lastTransparency
				if not instant and transparency < 1 and self.lastTransparency < 0.95 then
					local maxDelta = MAX_TWEEN_RATE * (now - self.lastUpdate)
					deltaTransparency = Util.Clamp(-maxDelta, maxDelta, deltaTransparency)
				end
				transparency = self.lastTransparency + deltaTransparency
			else
				self.transparencyDirty = true
			end
			transparency = Util.Clamp(0, 1, Util.Round(transparency, 2))
		end
		if self.transparencyDirty or self.lastTransparency ~= transparency then
			for child, _ in pairs(self.cachedParts) do
				child.LocalTransparencyModifier = transparency
			end
			self.transparencyDirty = false
			self.lastTransparency = transparency
		end
	end
	self.lastUpdate = now
end
return TransparencyController
]]></ProtectedString><string name="Name">TransparencyController</string></Properties></Item><Item class="ModuleScript" referent="RBX325"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local RunService = game:GetService("RunService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local USE_STACKING_TRANSPARENCY = true
local TARGET_TRANSPARENCY = 0.75
local TARGET_TRANSPARENCY_PERIPHERAL = 0.5
local MODE = {
	LIMBS = 2,
	MOVEMENT = 3,
	CORNERS = 4,
	CIRCLE1 = 5,
	CIRCLE2 = 6,
	LIMBMOVE = 7,
	SMART_CIRCLE = 8,
	CHAR_OUTLINE = 9
}
local LIMB_TRACKING_SET = {
	Head = true,
	["Left Arm"] = true,
	["Right Arm"] = true,
	["Left Leg"] = true,
	["Right Leg"] = true,
	LeftLowerArm = true,
	RightLowerArm = true,
	LeftUpperLeg = true,
	RightUpperLeg = true
}
local CORNER_FACTORS = {
	Vector3.new(1, 1, -1),
	Vector3.new(1, -1, -1),
	Vector3.new(-1, -1, -1),
	Vector3.new(-1, 1, -1)
}
local CIRCLE_CASTS = 10
local MOVE_CASTS = 3
local SMART_CIRCLE_CASTS = 24
local SMART_CIRCLE_INCREMENT = 2 * math.pi / SMART_CIRCLE_CASTS
local CHAR_OUTLINE_CASTS = 24
local AssertTypes = function(param, ...)
	local allowedTypes = {}
	local typeString = ""
	for _, typeName in pairs({
		...
	}) do
		allowedTypes[typeName] = true
		typeString = typeString .. (typeString == "" and "" or " or ") .. typeName
	end
	local theType = type(param)
	assert(allowedTypes[theType], typeString .. " type expected, got: " .. theType)
end
local Det3x3 = function(a, b, c, d, e, f, g, h, i)
	return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)
end
local function RayIntersection(p0, v0, p1, v1)
	local v2 = v0:Cross(v1)
	local d1 = p1.x - p0.x
	local d2 = p1.y - p0.y
	local d3 = p1.z - p0.z
	local denom = Det3x3(v0.x, -v1.x, v2.x, v0.y, -v1.y, v2.y, v0.z, -v1.z, v2.z)
	if denom == 0 then
		return ZERO_VECTOR3
	end
	local t0 = Det3x3(d1, -v1.x, v2.x, d2, -v1.y, v2.y, d3, -v1.z, v2.z) / denom
	local t1 = Det3x3(v0.x, d1, v2.x, v0.y, d2, v2.y, v0.z, d3, v2.z) / denom
	local s0 = p0 + t0 * v0
	local s1 = p1 + t1 * v1
	local s = s0 + 0.5 * (s1 - s0)
	if (s1 - s0).Magnitude < 0.25 then
		return s
	else
		return ZERO_VECTOR3
	end
end
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Invisicam = setmetatable({}, BaseOcclusion)
Invisicam.__index = Invisicam
function Invisicam.new()
	local self = setmetatable(BaseOcclusion.new(), Invisicam)
	self.char = nil
	self.humanoidRootPart = nil
	self.torsoPart = nil
	self.headPart = nil
	self.childAddedConn = nil
	self.childRemovedConn = nil
	self.behaviors = {}
	self.behaviors[MODE.LIMBS] = self.LimbBehavior
	self.behaviors[MODE.MOVEMENT] = self.MoveBehavior
	self.behaviors[MODE.CORNERS] = self.CornerBehavior
	self.behaviors[MODE.CIRCLE1] = self.CircleBehavior
	self.behaviors[MODE.CIRCLE2] = self.CircleBehavior
	self.behaviors[MODE.LIMBMOVE] = self.LimbMoveBehavior
	self.behaviors[MODE.SMART_CIRCLE] = self.SmartCircleBehavior
	self.behaviors[MODE.CHAR_OUTLINE] = self.CharacterOutlineBehavior
	self.mode = MODE.SMART_CIRCLE
	self.behaviorFunction = self.SmartCircleBehavior
	self.savedHits = {}
	self.trackedLimbs = {}
	self.camera = game.Workspace.CurrentCamera
	self.enabled = false
	return self
end
function Invisicam:Enable(enable)
	self.enabled = enable
	if not enable then
		self:Cleanup()
	end
end
function Invisicam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Invisicam
end
function Invisicam:LimbBehavior(castPoints)
	for limb, _ in pairs(self.trackedLimbs) do
		castPoints[#castPoints + 1] = limb.Position
	end
end
function Invisicam:MoveBehavior(castPoints)
	for i = 1, MOVE_CASTS do
		local position, velocity = self.humanoidRootPart.Position, self.humanoidRootPart.Velocity
		local horizontalSpeed = Vector3.new(velocity.X, 0, velocity.Z).Magnitude / 2
		local offsetVector = (i - 1) * self.humanoidRootPart.CFrame.lookVector * horizontalSpeed
		castPoints[#castPoints + 1] = position + offsetVector
	end
end
function Invisicam:CornerBehavior(castPoints)
	local cframe = self.humanoidRootPart.CFrame
	local centerPoint = cframe.p
	local rotation = cframe - centerPoint
	local halfSize = self.char:GetExtentsSize() / 2
	castPoints[#castPoints + 1] = centerPoint
	for i = 1, #CORNER_FACTORS do
		castPoints[#castPoints + 1] = centerPoint + rotation * (halfSize * CORNER_FACTORS[i])
	end
end
function Invisicam:CircleBehavior(castPoints)
	local cframe
	if self.mode == MODE.CIRCLE1 then
		cframe = self.humanoidRootPart.CFrame
	else
		local camCFrame = self.camera.CoordinateFrame
		cframe = camCFrame - camCFrame.p + self.humanoidRootPart.Position
	end
	castPoints[#castPoints + 1] = cframe.p
	for i = 0, CIRCLE_CASTS - 1 do
		local angle = 2 * math.pi / CIRCLE_CASTS * i
		local offset = 3 * Vector3.new(math.cos(angle), math.sin(angle), 0)
		castPoints[#castPoints + 1] = cframe * offset
	end
end
function Invisicam:LimbMoveBehavior(castPoints)
	self:LimbBehavior(castPoints)
	self:MoveBehavior(castPoints)
end
function Invisicam:CharacterOutlineBehavior(castPoints)
	local torsoUp = self.torsoPart.CFrame.upVector.unit
	local torsoRight = self.torsoPart.CFrame.rightVector.unit
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
	if self.headPart then
		castPoints[#castPoints + 1] = self.headPart.CFrame.p
	end
	local cframe = CFrame.new(ZERO_VECTOR3, Vector3.new(self.camera.CoordinateFrame.lookVector.X, 0, self.camera.CoordinateFrame.lookVector.Z))
	local centerPoint = self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position
	local partsWhitelist = {
		self.torsoPart
	}
	if self.headPart then
		partsWhitelist[#partsWhitelist + 1] = self.headPart
	end
	for i = 1, CHAR_OUTLINE_CASTS do
		local angle = 2 * math.pi * i / CHAR_OUTLINE_CASTS
		local offset = cframe * (3 * Vector3.new(math.cos(angle), math.sin(angle), 0))
		offset = Vector3.new(offset.X, math.max(offset.Y, -2.25), offset.Z)
		local ray = Ray.new(centerPoint + offset, -3 * offset)
		local hit, hitPoint = game.Workspace:FindPartOnRayWithWhitelist(ray, partsWhitelist, false, false)
		if hit then
			castPoints[#castPoints + 1] = hitPoint + 0.2 * (centerPoint - hitPoint).unit
		end
	end
end
function Invisicam:SmartCircleBehavior(castPoints)
	local torsoUp = self.torsoPart.CFrame.upVector.unit
	local torsoRight = self.torsoPart.CFrame.rightVector.unit
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
	if self.headPart then
		castPoints[#castPoints + 1] = self.headPart.CFrame.p
	end
	local cameraOrientation = self.camera.CFrame - self.camera.CFrame.p
	local torsoPoint = Vector3.new(0, 0.5, 0) + (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
	local radius = 2.5
	for i = 1, SMART_CIRCLE_CASTS do
		local angle = SMART_CIRCLE_INCREMENT * i - 0.5 * math.pi
		local offset = radius * Vector3.new(math.cos(angle), math.sin(angle), 0)
		local circlePoint = torsoPoint + cameraOrientation * offset
		local vp = circlePoint - self.camera.CFrame.p
		local ray = Ray.new(torsoPoint, circlePoint - torsoPoint)
		local hit, hp, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {
			self.char
		}, false, false)
		local castPoint = circlePoint
		if hit then
			local hprime = hp + 0.1 * hitNormal.unit
			local v0 = hprime - torsoPoint
			local d0 = v0.magnitude
			local perp = v0:Cross(vp).unit
			local v1 = perp:Cross(hitNormal).unit
			local vprime = (hprime - self.camera.CFrame.p).unit
			if v0.unit:Dot(-v1) < v0.unit:Dot(vprime) then
				castPoint = RayIntersection(hprime, v1, circlePoint, vp)
				if 0 < castPoint.Magnitude then
					local ray = Ray.new(hprime, castPoint - hprime)
					local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {
						self.char
					}, false, false)
					if hit then
						local hprime2 = hitPoint + 0.1 * hitNormal.unit
						castPoint = hprime2
					end
				else
					castPoint = hprime
				end
			else
				castPoint = hprime
			end
			local ray = Ray.new(torsoPoint, castPoint - torsoPoint)
			local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {
				self.char
			}, false, false)
			if hit then
				local castPoint2 = hitPoint - 0.1 * (castPoint - torsoPoint).unit
				castPoint = castPoint2
			end
		end
		castPoints[#castPoints + 1] = castPoint
	end
end
function Invisicam:CheckTorsoReference()
	if self.char then
		self.torsoPart = self.char:FindFirstChild("Torso")
		if not self.torsoPart then
			self.torsoPart = self.char:FindFirstChild("UpperTorso")
			if not self.torsoPart then
				self.torsoPart = self.char:FindFirstChild("HumanoidRootPart")
			end
		end
		self.headPart = self.char:FindFirstChild("Head")
	end
end
function Invisicam:CharacterAdded(char, player)
	if player ~= PlayersService.LocalPlayer then
		return
	end
	if self.childAddedConn then
		self.childAddedConn:Disconnect()
		self.childAddedConn = nil
	end
	if self.childRemovedConn then
		self.childRemovedConn:Disconnect()
		self.childRemovedConn = nil
	end
	self.char = char
	self.trackedLimbs = {}
	local function childAdded(child)
		if child:IsA("BasePart") then
			if LIMB_TRACKING_SET[child.Name] then
				self.trackedLimbs[child] = true
			end
			if child.Name == "Torso" or child.Name == "UpperTorso" then
				self.torsoPart = child
			end
			if child.Name == "Head" then
				self.headPart = child
			end
		end
	end
	local function childRemoved(child)
		self.trackedLimbs[child] = nil
		self:CheckTorsoReference()
	end
	self.childAddedConn = char.ChildAdded:Connect(childAdded)
	self.childRemovedConn = char.ChildRemoved:Connect(childRemoved)
	for _, child in pairs(self.char:GetChildren()) do
		childAdded(child)
	end
end
function Invisicam:SetMode(newMode)
	AssertTypes(newMode, "number")
	for modeName, modeNum in pairs(MODE) do
		if modeNum == newMode then
			self.mode = newMode
			self.behaviorFunction = self.behaviors[self.mode]
			return
		end
	end
	error("Invalid mode number")
end
function Invisicam:GetObscuredParts()
	return self.savedHits
end
function Invisicam:Cleanup()
	for hit, originalFade in pairs(self.savedHits) do
		hit.LocalTransparencyModifier = originalFade
	end
end
function Invisicam:Update(dt, desiredCameraCFrame, desiredCameraFocus)
	if not self.enabled or not self.char then
		return desiredCameraCFrame, desiredCameraFocus
	end
	self.camera = game.Workspace.CurrentCamera
	if not self.humanoidRootPart then
		do
			local humanoid = self.char:FindFirstChildOfClass("Humanoid")
			if humanoid and humanoid.RootPart then
				self.humanoidRootPart = humanoid.RootPart
			else
				self.humanoidRootPart = self.char:FindFirstChild("HumanoidRootPart")
				if not self.humanoidRootPart then
					return desiredCameraCFrame, desiredCameraFocus
				end
			end
			local ancestryChangedConn
			ancestryChangedConn = self.humanoidRootPart.AncestryChanged:Connect(function(child, parent)
				if child == self.humanoidRootPart and not parent then
					self.humanoidRootPart = nil
					if ancestryChangedConn and ancestryChangedConn.Connected then
						ancestryChangedConn:Disconnect()
						ancestryChangedConn = nil
					end
				end
			end)
		end
	end
	if not self.torsoPart then
		self:CheckTorsoReference()
		if not self.torsoPart then
			return desiredCameraCFrame, desiredCameraFocus
		end
	end
	local castPoints = {}
	self.behaviorFunction(self, castPoints)
	local currentHits = {}
	local ignoreList = {
		self.char
	}
	local function add(hit)
		currentHits[hit] = true
		if not self.savedHits[hit] then
			self.savedHits[hit] = hit.LocalTransparencyModifier
		end
	end
	local hitParts
	local hitPartCount = 0
	local headTorsoRayHitParts = {}
	local partIsTouchingCamera = {}
	local perPartTransparencyHeadTorsoHits = TARGET_TRANSPARENCY
	local perPartTransparencyOtherHits = TARGET_TRANSPARENCY
	if USE_STACKING_TRANSPARENCY then
		local headPoint = self.headPart and self.headPart.CFrame.p or castPoints[1]
		local torsoPoint = self.torsoPart and self.torsoPart.CFrame.p or castPoints[2]
		hitParts = self.camera:GetPartsObscuringTarget({headPoint, torsoPoint}, ignoreList)
		for i = 1, #hitParts do
			local hitPart = hitParts[i]
			hitPartCount = hitPartCount + 1
			headTorsoRayHitParts[hitPart] = true
			for _, child in pairs(hitPart:GetChildren()) do
				if child:IsA("Decal") or child:IsA("Texture") then
					hitPartCount = hitPartCount + 1
					break
				end
			end
		end
		if hitPartCount > 0 then
			perPartTransparencyHeadTorsoHits = math.pow(0.5 * TARGET_TRANSPARENCY + 0.5 * TARGET_TRANSPARENCY / hitPartCount, 1 / hitPartCount)
			perPartTransparencyOtherHits = math.pow(0.5 * TARGET_TRANSPARENCY_PERIPHERAL + 0.5 * TARGET_TRANSPARENCY_PERIPHERAL / hitPartCount, 1 / hitPartCount)
		end
	end
	hitParts = self.camera:GetPartsObscuringTarget(castPoints, ignoreList)
	local partTargetTransparency = {}
	for i = 1, #hitParts do
		local hitPart = hitParts[i]
		partTargetTransparency[hitPart] = headTorsoRayHitParts[hitPart] and perPartTransparencyHeadTorsoHits or perPartTransparencyOtherHits
		if hitPart.Transparency < partTargetTransparency[hitPart] then
			add(hitPart)
		end
		for _, child in pairs(hitPart:GetChildren()) do
			if (child:IsA("Decal") or child:IsA("Texture")) and child.Transparency < partTargetTransparency[hitPart] then
				partTargetTransparency[child] = partTargetTransparency[hitPart]
				add(child)
			end
		end
	end
	for hitPart, originalLTM in pairs(self.savedHits) do
		if currentHits[hitPart] then
			hitPart.LocalTransparencyModifier = 1 > hitPart.Transparency and (partTargetTransparency[hitPart] - hitPart.Transparency) / (1 - hitPart.Transparency) or 0
		else
			hitPart.LocalTransparencyModifier = originalLTM
			self.savedHits[hitPart] = nil
		end
	end
	return desiredCameraCFrame, desiredCameraFocus
end
return Invisicam
]]></ProtectedString><string name="Name">Invisicam</string></Properties></Item><Item class="ModuleScript" referent="RBX330"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local BaseOcclusion = {}
BaseOcclusion.__index = BaseOcclusion
setmetatable(BaseOcclusion, {
	__call = function(_, ...)
		return BaseOcclusion.new(...)
	end
})
function BaseOcclusion.new()
	local self = setmetatable({}, BaseOcclusion)
	return self
end
function BaseOcclusion:CharacterAdded(char, player)
end
function BaseOcclusion:CharacterRemoving(char, player)
end
function BaseOcclusion:OnCameraSubjectChanged(newSubject)
end
function GetOcclusionMode()
	warn("BaseOcclusion GetOcclusionMode must be overridden by derived classes")
	return nil
end
function BaseOcclusion:Enable(enabled)
	warn("BaseOcclusion Enable must be overridden by derived classes")
end
function BaseOcclusion:Update(dt, desiredCameraCFrame, desiredCameraFocus)
	warn("BaseOcclusion Update must be overridden by derived classes")
	return desiredCameraCFrame, desiredCameraFocus
end
return BaseOcclusion
]]></ProtectedString><string name="Name">BaseOcclusion</string></Properties></Item><Item class="ModuleScript" referent="RBX335"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UNIT_X = Vector3.new(1, 0, 0)
local UNIT_Y = Vector3.new(0, 1, 0)
local UNIT_Z = Vector3.new(0, 0, 1)
local X1_Y0_Z1 = Vector3.new(1, 0, 1)
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local ZERO_VECTOR2 = Vector2.new(0, 0)
local TAU = 2 * math.pi
local VR_PITCH_FRACTION = 0.25
local tweenAcceleration = math.rad(220)
local tweenSpeed = math.rad(0)
local tweenMaxSpeed = math.rad(250)
local TIME_BEFORE_AUTO_ROTATE = 2
local PORTRAIT_OFFSET = Vector3.new(0, -3, 0)
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local THUMBSTICK_DEADZONE = 0.2
local MIN_ALLOWED_ELEVATION_DEG = -80
local MAX_ALLOWED_ELEVATION_DEG = 80
local externalProperties = {}
externalProperties.InitialDistance = 25
externalProperties.MinDistance = 10
externalProperties.MaxDistance = 100
externalProperties.InitialElevation = 35
externalProperties.MinElevation = 35
externalProperties.MaxElevation = 35
externalProperties.ReferenceAzimuth = -45
externalProperties.CWAzimuthTravel = 90
externalProperties.CCWAzimuthTravel = 90
externalProperties.UseAzimuthLimits = false
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local VRService = game:GetService("VRService")
local GetValueObject = function(name, defaultValue)
	local valueObj = script:FindFirstChild(name)
	if valueObj then
		return valueObj.Value
	end
	return defaultValue
end
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local OrbitalCamera = setmetatable({}, BaseCamera)
OrbitalCamera.__index = OrbitalCamera
function OrbitalCamera.new()
	local self = setmetatable(BaseCamera.new(), OrbitalCamera)
	self.lastUpdate = tick()
	self.changedSignalConnections = {}
	self.refAzimuthRad = nil
	self.curAzimuthRad = nil
	self.minAzimuthAbsoluteRad = nil
	self.maxAzimuthAbsoluteRad = nil
	self.useAzimuthLimits = nil
	self.curElevationRad = nil
	self.minElevationRad = nil
	self.maxElevationRad = nil
	self.curDistance = nil
	self.minDistance = nil
	self.maxDistance = nil
	self.r3ButtonDown = false
	self.l3ButtonDown = false
	self.gamepadDollySpeedMultiplier = 1
	self.lastUserPanCamera = tick()
	self.externalProperties = {}
	self.externalProperties.InitialDistance = 25
	self.externalProperties.MinDistance = 10
	self.externalProperties.MaxDistance = 100
	self.externalProperties.InitialElevation = 35
	self.externalProperties.MinElevation = 35
	self.externalProperties.MaxElevation = 35
	self.externalProperties.ReferenceAzimuth = -45
	self.externalProperties.CWAzimuthTravel = 90
	self.externalProperties.CCWAzimuthTravel = 90
	self.externalProperties.UseAzimuthLimits = false
	self:LoadNumberValueParameters()
	return self
end
function OrbitalCamera:LoadOrCreateNumberValueParameter(name, valueType, updateFunction)
	local valueObj = script:FindFirstChild(name)
	if valueObj and valueObj:isA(valueType) then
		self.externalProperties[name] = valueObj.Value
	elseif self.externalProperties[name] ~= nil then
		valueObj = Instance.new(valueType)
		valueObj.Name = name
		valueObj.Parent = script
		valueObj.Value = self.externalProperties[name]
	else
		print("externalProperties table has no entry for ", name)
		return
	end
	if updateFunction then
		if self.changedSignalConnections[name] then
			self.changedSignalConnections[name]:Disconnect()
		end
		self.changedSignalConnections[name] = valueObj.Changed:Connect(function(newValue)
			self.externalProperties[name] = newValue
			updateFunction(self)
		end)
	end
end
function OrbitalCamera:SetAndBoundsCheckAzimuthValues()
	self.minAzimuthAbsoluteRad = math.rad(self.externalProperties.ReferenceAzimuth) - math.abs(math.rad(self.externalProperties.CWAzimuthTravel))
	self.maxAzimuthAbsoluteRad = math.rad(self.externalProperties.ReferenceAzimuth) + math.abs(math.rad(self.externalProperties.CCWAzimuthTravel))
	self.useAzimuthLimits = self.externalProperties.UseAzimuthLimits
	if self.useAzimuthLimits then
		self.curAzimuthRad = math.max(self.curAzimuthRad, self.minAzimuthAbsoluteRad)
		self.curAzimuthRad = math.min(self.curAzimuthRad, self.maxAzimuthAbsoluteRad)
	end
end
function OrbitalCamera:SetAndBoundsCheckElevationValues()
	local minElevationDeg = math.max(self.externalProperties.MinElevation, MIN_ALLOWED_ELEVATION_DEG)
	local maxElevationDeg = math.min(self.externalProperties.MaxElevation, MAX_ALLOWED_ELEVATION_DEG)
	self.minElevationRad = math.rad(math.min(minElevationDeg, maxElevationDeg))
	self.maxElevationRad = math.rad(math.max(minElevationDeg, maxElevationDeg))
	self.curElevationRad = math.max(self.curElevationRad, self.minElevationRad)
	self.curElevationRad = math.min(self.curElevationRad, self.maxElevationRad)
end
function OrbitalCamera:SetAndBoundsCheckDistanceValues()
	self.minDistance = self.externalProperties.MinDistance
	self.maxDistance = self.externalProperties.MaxDistance
	self.curDistance = math.max(self.curDistance, self.minDistance)
	self.curDistance = math.min(self.curDistance, self.maxDistance)
end
function OrbitalCamera:LoadNumberValueParameters()
	self:LoadOrCreateNumberValueParameter("InitialElevation", "NumberValue", nil)
	self:LoadOrCreateNumberValueParameter("InitialDistance", "NumberValue", nil)
	self:LoadOrCreateNumberValueParameter("ReferenceAzimuth", "NumberValue", self.SetAndBoundsCheckAzimuthValue)
	self:LoadOrCreateNumberValueParameter("CWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
	self:LoadOrCreateNumberValueParameter("CCWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
	self:LoadOrCreateNumberValueParameter("MinElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
	self:LoadOrCreateNumberValueParameter("MaxElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
	self:LoadOrCreateNumberValueParameter("MinDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
	self:LoadOrCreateNumberValueParameter("MaxDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
	self:LoadOrCreateNumberValueParameter("UseAzimuthLimits", "BoolValue", self.SetAndBoundsCheckAzimuthValues)
	self.curAzimuthRad = math.rad(self.externalProperties.ReferenceAzimuth)
	self.curElevationRad = math.rad(self.externalProperties.InitialElevation)
	self.curDistance = self.externalProperties.InitialDistance
	self:SetAndBoundsCheckAzimuthValues()
	self:SetAndBoundsCheckElevationValues()
	self:SetAndBoundsCheckDistanceValues()
end
function OrbitalCamera:GetModuleName()
	return "OrbitalCamera"
end
function OrbitalCamera:SetInitialOrientation(humanoid)
	if not humanoid or not humanoid.RootPart then
		warn("OrbitalCamera could not set initial orientation due to missing humanoid")
		return
	end
	local newDesiredLook = (humanoid.RootPart.CFrame.lookVector - Vector3.new(0, 0.23, 0)).unit
	local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, self:GetCameraLookVector())
	local vertShift = math.asin(self:GetCameraLookVector().y) - math.asin(newDesiredLook.y)
	if not Util.IsFinite(horizontalShift) then
		horizontalShift = 0
	end
	if not Util.IsFinite(vertShift) then
		vertShift = 0
	end
	self.rotateInput = Vector2.new(horizontalShift, vertShift)
end
function OrbitalCamera:GetCameraToSubjectDistance()
	return self.curDistance
end
function OrbitalCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	print("OrbitalCamera SetCameraToSubjectDistance ", desiredSubjectDistance)
	local player = PlayersService.LocalPlayer
	if player then
		self.currentSubjectDistance = Util.Clamp(self.minDistance, self.maxDistance, desiredSubjectDistance)
		self.currentSubjectDistance = math.max(self.currentSubjectDistance, self.FIRST_PERSON_DISTANCE_THRESHOLD)
	end
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
	return self.currentSubjectDistance
end
function OrbitalCamera:CalculateNewLookVector(suppliedLookVector, xyRotateVector)
	local currLookVector = suppliedLookVector or self:GetCameraLookVector()
	local currPitchAngle = math.asin(currLookVector.y)
	local yTheta = Util.Clamp(currPitchAngle - math.rad(MAX_ALLOWED_ELEVATION_DEG), currPitchAngle - math.rad(MIN_ALLOWED_ELEVATION_DEG), xyRotateVector.y)
	local constrainedRotateInput = Vector2.new(xyRotateVector.x, yTheta)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local newLookVector = (CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y, 0, 0)).lookVector
	return newLookVector
end
function OrbitalCamera:GetGamepadPan(name, state, input)
	if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
		if self.r3ButtonDown or self.l3ButtonDown then
			if input.Position.Y > THUMBSTICK_DEADZONE then
				self.gamepadDollySpeedMultiplier = 0.96
			elseif input.Position.Y < -THUMBSTICK_DEADZONE then
				self.gamepadDollySpeedMultiplier = 1.04
			else
				self.gamepadDollySpeedMultiplier = 1
			end
		else
			if state == Enum.UserInputState.Cancel then
				self.gamepadPanningCamera = ZERO_VECTOR2
				return
			end
			local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
			if inputVector.magnitude > THUMBSTICK_DEADZONE then
				self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
			else
				self.gamepadPanningCamera = ZERO_VECTOR2
			end
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function OrbitalCamera:DoGamepadZoom(name, state, input)
	if input.UserInputType == self.activeGamepad and (input.KeyCode == Enum.KeyCode.ButtonR3 or input.KeyCode == Enum.KeyCode.ButtonL3) then
		if state == Enum.UserInputState.Begin then
			self.r3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonR3
			self.l3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonL3
		elseif state == Enum.UserInputState.End then
			if input.KeyCode == Enum.KeyCode.ButtonR3 then
				self.r3ButtonDown = false
			elseif input.KeyCode == Enum.KeyCode.ButtonL3 then
				self.l3ButtonDown = false
			end
			if not self.r3ButtonDown and not self.l3ButtonDown then
				self.gamepadDollySpeedMultiplier = 1
			end
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function OrbitalCamera:BindGamepadInputActions()
	if FFlagPlayerScriptsBindAtPriority2 then
		self:BindAction("OrbitalCamGamepadPan", function(name, state, input)
			return self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		self:BindAction("OrbitalCamGamepadZoom", function(name, state, input)
			return self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonR3, Enum.KeyCode.ButtonL3)
	else
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:BindAction("OrbitalCamGamepadPan", function(name, state, input)
			self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		ContextActionService:BindAction("OrbitalCamGamepadZoom", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonR3)
		ContextActionService:BindAction("OrbitalCamGamepadZoomAlt", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonL3)
	end
end
function OrbitalCamera:Update(dt)
	local now = tick()
	local timeDelta = now - self.lastUpdate
	local userPanningTheCamera = self.UserPanningTheCamera == true
	local camera = workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera and camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	local isOnASkateboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end
	if self.lastUpdate then
		local gamepadRotation = self:UpdateGamepad()
		if self:ShouldUseVRRotation() then
			self.RotateInput = self.RotateInput + self:GetVRRotationInput()
		else
			local delta = math.min(0.1, timeDelta)
			if gamepadRotation ~= ZERO_VECTOR2 then
				userPanningTheCamera = true
				self.rotateInput = self.rotateInput + gamepadRotation * delta
			end
			local angle = 0
			if not isInVehicle and not isOnASkateboard then
				angle = angle + (self.TurningLeft and -120 or 0)
				angle = angle + (self.TurningRight and 120 or 0)
			end
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(math.rad(angle * delta), 0)
				userPanningTheCamera = true
			end
		end
	end
	if userPanningTheCamera then
		tweenSpeed = 0
		self.lastUserPanCamera = tick()
	end
	local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
	local subjectPosition = self:GetSubjectPosition()
	if subjectPosition and player and camera then
		if self.gamepadDollySpeedMultiplier ~= 1 then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance * self.gamepadDollySpeedMultiplier)
		end
		local VREnabled = VRService.VREnabled
		newCameraFocus = VREnabled and self:GetVRFocus(subjectPosition, timeDelta) or CFrame.new(subjectPosition)
		local cameraFocusP = newCameraFocus.p
		if VREnabled and not self:IsInFirstPerson() then
			local cameraHeight = self:GetCameraHeight()
			local vecToSubject = subjectPosition - camera.CFrame.p
			local distToSubject = vecToSubject.magnitude
			if distToSubject > self.currentSubjectDistance or self.rotateInput.x ~= 0 then
				local desiredDist = math.min(distToSubject, self.currentSubjectDistance)
				vecToSubject = self:CalculateNewLookVector(vecToSubject.unit * X1_Y0_Z1, Vector2.new(self.rotateInput.x, 0)) * desiredDist
				local newPos = cameraFocusP - veToSubject
				local desiredLookDir = caecamteboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end
	if self.lastUpdate then
		local gamepadRotation = self:UpdateGamepad()
		if self:ShouldUseVRRotation() then
			self.RotateInput = self.RotateInput + self:GetVRRotationInput()
		else
			local delta = math.min(0.1, timeDelta)
			if gamepadRotation ~= ZERO_VECTOR2 then
				userPanningTheCamera = true
				self.rotateInput = self.rotateInput + gamepadRotation * delta
			end
			local angle = 0
			if not isInVehicle and not isOnASkateboard then
				angle = angle + (self.TurningLeft and -120 or 0)
				angle = angle + (self.TurningRight and 120 or 0)
			end
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(math.rad(angle * delta), 0)
				userPanningTheCamera = true
			end
		end
	end
	if userPanningTheCamera then
		tweenSpeed = 0
		self.lastUserPanCamera = tick()
	end
	local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFal cameraHeight = self:GetCameraHeight()
			local vecToSubject = subjectPosition - camera.CFrame.p
			local distToSubject = vecToSubject.magnitude
			if distToSubject > self.currentSubjectDistance or self.rotateInput.x ~= 0 then
				local desiredDist = math.min(distToSubject, self.currentSubjectDistance)
				vecToSubject = self:CalculateNewLookVector(vecToSubject.unit * X1_Y0_Z1, Vector2.new(self.rotateInput.x, 0)) * desiredDist
				local newPos = cameraFocusP - vecToSubject
				local desiredLookDir = cameral cameraHeight = self:GetCameraHeight()
			local vecToSubject = subjectPosition - camera.CFrame.p
			local distToSubject = vecToSubject.magnitude
			if distToSubject > self.currentSubjectDistance or self.rotateInput.x ~= 0 then
				local desiredDist = math.min(distToSubject, self.currentSubjectDistance)
				vecToSubject = self:CalculateNewLookVector(vecToSubject.unit * X1_Y0_Z1, Vector2.new(self.rotateInput.x, 0)) * desiredDist
				local newPos = cameraFocusP - veToSubject
				local desiredLookDir = caecamteboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end
	if self.lastUpdate then
		local gamepadRotation = self:UpdateGamepad()
		if self:ShouldUseVRRotation() then
			self.RotateInput = self.RotateInput + self:GetVRRotationInput()
		else
			local delta = math.min(0.1, timeDelta)
			if gamepadRotation ~= ZERO_VECTOR2 then
				userPanningTheCamera = true
				self.rotateInput = self.rotateInput + gamepadRotation * delta
			end
			local angle = 0
			if not isInVehicle and not isOnASkateboard then
				angle = angle + (self.TurningLeft and -120 or 0)
				angle = angle + (self.TurningRight and 120 or 0)
			end
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(math.rad(angle * delta), 0)
				userPanningTheCamera = true
			end
		end
	end
	if userPanningTheCamera then
		tweenSpeed = 0
		self.lastUserPanCamera = tick()
	end
	local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFal cameraHeight = self:GetCameraHeight()
			local vecToSubject = subjectPosition - camera.CFrame.p
			local distToSubject = vecToSubject.magnitude
			if distToSubject > self.currentSubjectDistance or self.rotateInput.x ~= 0 then
				local desiredDist = math.min(distToSubject, self.currentSubjectDistance)
				vecToSubject = self:CalculateNewLookVector(vecToSubject.unit * X1_Y0_Z1, Vector2.new(self.rotateInput.x, 0)) * desiredDist
				local newPos = cameraFocusP - vecToSubject
				local desiredLookDir = camera.CFrame.lookVector
				if self.rotateInput.x ~= 0 then
					desiredLookDir = vecToSubject
				end
				local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
				self.RotateInput = ZERO_VECTOR2
				newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
			end
		else
			self.curAzimuthRad = self.curAzimuthRad - self.rotateInput.x
			if self.useAzimuthLimits then
				self.curAzimuthRad = Util.Clamp(self.minAzimuthAbsoluteRad, self.maxAzimuthAbsoluteRad, self.curAzimuthRad)
			else
				self.curAzimuthRad = self.curAzimuthRad ~= 0 and math.sign(self.curAzimuthRad) * (math.abs(self.curAzimuthRad) % TAU) or 0
			end
			self.curElevationRad = Util.Clamp(self.minElevationRad, self.maxElevationRad, self.curElevationRad + self.rotateInput.y)
			local cameraPosVector = self.currentSubjectDistance * (CFrame.fromEulerAnglesYXZ(-self.curElevationRad, self.curAzimuthRad, 0) * UNIT_Z)
			local camPos = subjectPosition + cameraPosVector
			newCameraCFrame = CFrame.new(camPos, subjectPosition)
			self.rotateInput = ZERO_VECTOR2
		end
		self.lastCameraTransform = newCameraCFrame
		self.lastCameraFocus = newCameraFocus
		if (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
			self.lastSubjectCFrame = cameraSubject.CFrame
		else
			self.lastSubjectCFrame = nil
		end
	end
	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end
return OrbitalCamera
]]></ProtectedString><string name="Name">OrbitalCamera</string></Properties></Item><Item class="ModuleScript" referent="RBX340"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UNIT_X = Vector3.new(1, 0, 0)
local UNIT_Y = Vector3.new(0, 1, 0)
local UNIT_Z = Vector3.new(0, 0, 1)
local X1_Y0_Z1 = Vector3.new(1, 0, 1)
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local ZERO_VECTOR2 = Vector2.new(0, 0)
local VR_PITCH_FRACTION = 0.25
local tweenAcceleration = math.rad(220)
local tweenSpeed = math.rad(0)
local tweenMaxSpeed = math.rad(250)
local TIME_BEFORE_AUTO_ROTATE = 2
local PORTRAIT_OFFSET = Vector3.new(0, -3, 0)
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local VRService = game:GetService("VRService")
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local LegacyCamera = setmetatable({}, BaseCamera)
LegacyCamera.__index = LegacyCamera
function LegacyCamera.new()
	local self = setmetatable(BaseCamera.new(), LegacyCamera)
	self.cameraType = Enum.CameraType.Fixed
	self.lastUpdate = tick()
	self.lastDistanceToSubject = nil
	return self
end
function LegacyCamera:GetModuleName()
	return "LegacyCamera"
end
function LegacyCamera:Test()
	print("LegacyCamera:Test()")
end
function LegacyCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	return BaseCamera.SetCameraToSubjectDistance(self, desiredSubjectDistance)
end
function LegacyCamera:Update(dt)
	if not self.cameraType then
		return
	end
	local now = tick()
	local timeDelta = now - self.lastUpdate
	local camera = workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera and camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	local isOnASkateboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastDistanceToSubject = nil
	end
	local subjectPosition = self:GetSubjectPosition()
	if self.cameraType == Enum.CameraType.Fixed then
		if self.lastUpdate then
			local delta = math.min(0.1, now - self.lastUpdate)
			local gamepadRotation = self:UpdateGamepad()
			self.rotateInput = self.rotateInput + gamepadRotation * delta
		end
		if subjectPosition and player and camera then
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local newLookVector = self:CalculateNewLookVector()
			self.rotateInput = ZERO_VECTOR2
			newCameraFocus = camera.Focus
			newCameraCFrame = CFrame.new(camera.CFrame.p, camera.CFrame.p + distanceToSubject * newLookVector)
		end
	elseif self.cameraType == Enum.CameraType.Attach then
		if subjectPosition and camera then
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local humanoid = self:GetHumanoid()
			if self.lastUpdate and humanoid and humanoid.RootPart then
				local delta = math.min(0.1, now - self.lastUpdate)
				local gamepadRotation = self:UpdateGamepad()
				self.rotateInput = self.rotateInput + gamepadRotation * delta
				local forwardVector = humanoid.RootPart.CFrame.lookVector
				local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
				if Util.IsFinite(y) then
					self.rotateInput = Vector2.new(y, self.rotateInput.Y)
				end
			end
			local newLookVector = self:CalculateNewLookVector()
			self.rotateInput = ZERO_VECTOR2
			newCameraFocus = CFrame.new(subjectPosition)
			newCameraCFrame = CFrame.new(subjectPosition - distanceToSubject * newLookVector, subjectPosition)
		end
	elseif self.cameraType == Enum.CameraType.Watch then
		if subjectPosition and player and camera then
			local cameraLook
			local humanoid = self:GetHumanoid()
			if humanoid and humanoid.RootPart then
				local diffVector = subjectPosition - camera.CFrame.p
				cameraLook = diffVector.unit
				if self.lastDistanceToSubject and self.lastDistanceToSubject == self:GetCameraToSubjectDistance() then
					local newDistanceToSubject = diffVector.magnitude
					self:SetCameraToSubjectDistance(newDistanceToSubject)
				end
			end
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local newLookVector = self:CalculateNewLookVector(cameraLook)
			self.rotateInput = ZERO_VECTOR2
			newCameraFocus = CFrame.new(subjectPosition)
			newCameraCFrame = CFrame.new(subjectPosition - distanceToSubject * newLookVector, subjectPosition)
			self.lastDistanceToSubject = distanceToSubject
		end
	else
		return camera.CFrame, camera.Focus
	end
	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end
return LegacyCamera
]]></ProtectedString><string name="Name">LegacyCamera</string></Properties></Item></Item><Item class="ModuleScript" referent="RBX346"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ControlModule = {}
ControlModule.__index = ControlModule
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local Keyboard = require(script:WaitForChild("Keyboard"))
local Gamepad = require(script:WaitForChild("Gamepad"))
local TouchDPad = require(script:WaitForChild("TouchDPad"))
local DynamicThumbstick = require(script:WaitForChild("DynamicThumbstick"))
local ClickToMove = require(script:WaitForChild("ClickToMoveController"))
local TouchThumbstick = require(script:WaitForChild("TouchThumbstick"))
local TouchThumbpad = require(script:WaitForChild("TouchThumbpad"))
local TouchJump = require(script:WaitForChild("TouchJump"))
local VehicleController = require(script:WaitForChild("VehicleController"))
local CONTROL_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
local movementEnumToModuleMap = {
	[Enum.TouchMovementMode.DPad] = TouchDPad,
	[Enum.DevTouchMovementMode.DPad] = TouchDPad,
	[Enum.TouchMovementMode.Thumbpad] = TouchThumbpad,
	[Enum.DevTouchMovementMode.Thumbpad] = TouchThumbpad,
	[Enum.TouchMovementMode.Thumbstick] = TouchThumbstick,
	[Enum.DevTouchMovementMode.Thumbstick] = TouchThumbstick,
	[Enum.TouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
	[Enum.DevTouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
	[Enum.TouchMovementMode.ClickToMove] = ClickToMove,
	[Enum.DevTouchMovementMode.ClickToMove] = ClickToMove,
	[Enum.TouchMovementMode.Default] = DynamicThumbstick,
	[Enum.ComputerMovementMode.Default] = Keyboard,
	[Enum.ComputerMovementMode.KeyboardMouse] = Keyboard,
	[Enum.DevComputerMovementMode.KeyboardMouse] = Keyboard,
	[Enum.DevComputerMovementMode.Scriptable] = nil,
	[Enum.ComputerMovementMode.ClickToMove] = ClickToMove,
	[Enum.DevComputerMovementMode.ClickToMove] = ClickToMove
}
local computerInputTypeToModuleMap = {
	[Enum.UserInputType.Keyboard] = Keyboard,
	[Enum.UserInputType.MouseButton1] = Keyboard,
	[Enum.UserInputType.MouseButton2] = Keyboard,
	[Enum.UserInputType.MouseButton3] = Keyboard,
	[Enum.UserInputType.MouseWheel] = Keyboard,
	[Enum.UserInputType.MouseMovement] = Keyboard,
	[Enum.UserInputType.Gamepad1] = Gamepad,
	[Enum.UserInputType.Gamepad2] = Gamepad,
	[Enum.UserInputType.Gamepad3] = Gamepad,
	[Enum.UserInputType.Gamepad4] = Gamepad
}
function ControlModule.new()
	local self = setmetatable({}, ControlModule)
	self.controllers = {}
	self.activeControlModule = nil
	self.activeController = nil
	self.touchJumpController = nil
	self.moveFunction = Players.LocalPlayer.Move
	self.humanoid = nil
	self.lastInputType = Enum.UserInputType.None
	self.cameraRelative = true
	self.humanoidSeatedConn = nil
	self.vehicleController = nil
	self.touchControlFrame = nil
	self.vehicleController = VehicleController.new(CONTROL_ACTION_PRIORITY)
	Players.LocalPlayer.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char)
	end)
	Players.LocalPlayer.CharacterRemoving:Connect(function(char)
		self:OnCharacterAdded(char)
	end)
	if Players.LocalPlayer.Character then
		self:OnCharacterAdded(Players.LocalPlayer.Character)
	end
	RunService:BindToRenderStep("ControlScriptRenderstep", Enum.RenderPriority.Input.Value, function(dt)
		self:OnRenderStepped(dt)
	end)
	UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
		self:OnLastInputTypeChanged(newLastInputType)
	end)
	local propertyChangeListeners = {
		UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
			self:OnTouchMovementModeChange()
		end),
		Players.LocalPlayer:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
			self:OnTouchMovementModeChange()
		end),
		UserGameSettings:GetPropertyChangedSignal("ComputerMovementMode"):Connect(function()
			self:OnComputerMovementModeChange()
		end),
		Players.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
			self:OnComputerMovementModeChange()
		end)
	}
	self.playerGui = nil
	self.touchGui = nil
	self.playerGuiAddedConn = nil
	if UserInputService.TouchEnabled then
		self.playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
		if self.playerGui then
			self:CreateTouchGuiContainer()
			self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
		else
			self.playerGuiAddedConn = Players.LocalPlayer.ChildAdded:Connect(function(child)
				if child:IsA("PlayerGui") then
					self.playerGui = child
					self:CreateTouchGuiContainer()
					self.playerGuiAddedConn:Disconnect()
					self.playerGuiAddedConn = nil
					self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
				end
			end)
		end
	else
		self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
	end
	return self
end
function ControlModule:GetMoveVector()
	if self.activeController then
		return self.activeController:GetMoveVector()
	end
	return Vector3.new(0, 0, 0)
end
function ControlModule:GetActiveController()
	return self.activeController
end
function ControlModule:EnableActiveControlModule()
	if self.activeControlModule == ClickToMove then
		self.activeController:Enable(true, Players.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice, self.touchJumpController)
	elseif self.touchControlFrame then
		self.activeController:Enable(true, self.touchControlFrame)
	else
		self.activeController:Enable(true)
	end
end
function ControlModule:Enable(enable)
	if not self.activeController then
		return
	end
	if enable == nil then
		enable = true
	end
	if enable then
		self:EnableActiveControlModule()
	else
		self:Disable()
	end
end
function ControlModule:Disable()
	if self.activeController then
		self.activeController:Enable(false)
		if self.moveFunction then
			self.moveFunction(Players.LocalPlayer, Vector3.new(0, 0, 0), self.cameraRelative)
		end
	end
end
function ControlModule:SelectComputerMovementModule()
	if not UserInputService.KeyboardEnabled and not UserInputService.GamepadEnabled then
		return nil, false
	end
	local computerModule
	local DevMovementMode = Players.LocalPlayer.DevComputerMovementMode
	if DevMovementMode == Enum.DevComputerMovementMode.UserChoice then
		computerModule = computerInputTypeToModuleMap[lastInputType]
		if UserGameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove and computerModule == Keyboard then
			computerModule = ClickToMove
		end
	else
		computerModule = movementEnumToModuleMap[DevMovementMode]
		if not computerModule and DevMovementMode ~= Enum.DevComputerMovementMode.Scriptable then
			warn("No character control module is associated with DevComputerMovementMode ", DevMovementMode)
		end
	end
	if computerModule then
		return computerModule, true
	elseif DevMovementMode == Enum.DevComputerMovementMode.Scriptable then
		return nil, true
	else
		return nil, false
	end
end
function ControlModule:SelectTouchModule()
	if not UserInputService.TouchEnabled then
		return nil, false
	end
	local touchModule
	local DevMovementMode = Players.LocalPlayer.DevTouchMovementMode
	if DevMovementMode == Enum.DevTouchMovementMode.UserChoice then
		touchModule = movementEnumToModuleMap[UserGameSettings.TouchMovementMode]
	elseif DevMovementMode == Enum.DevTouchMovementMode.Scriptable then
		return nil, true
	else
		touchModule = movementEnumToModuleMap[DevMovementMode]
	end
	return touchModule, true
end
function ControlModule:OnRenderStepped(dt)
	if self.activeController and self.activeController.enabled and self.humanoid then
		local moveVector = self.activeController:GetMoveVector()
		local vehicleConsumedInput = false
		if self.vehicleController then
			moveVector, vehicleConsumedInput = self.vehicleController:Update(moveVector, self.activeControlModule == Gamepad)
		end
		self.moveFunction(Players.LocalPlayer, moveVector, self.cameraRelative)
		self.humanoid.Jump = not self.activeController:GetIsJumping() and self.touchJumpController and self.touchJumpController:GetIsJumping()
	end
end
function ControlModule:OnHumanoidSeated(active, currentSeatPart)
	if active then
		if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
			if not self.vehicleController then
				self.vehicleController = self.vehicleController.new(CONTROL_ACTION_PRIORITY)
			end
			self.vehicleController:Enable(true, currentSeatPart)
		end
	elseif self.vehicleController then
		self.vehicleController:Enable(false, currentSeatPart)
	end
end
function ControlModule:OnCharacterAdded(char)
	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	while not self.humanoid do
		char.ChildAdded:wait()
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
	end
	if self.humanoidSeatedConn then
		self.humanoidSeatedConn:Disconnect()
		self.humanoidSeatedConn = nil
	end
	self.humanoidSeatedConn = self.humanoid.Seated:Connect(function(active, currentSeatPart)
		self:OnHumanoidSeated(active, currentSeatPart)
	end)
end
function ControlModule:OnCharacterRemoving(char)
	self.humanoid = nil
end
function ControlModule:SwitchToController(controlModule)
	if not controlModule then
		if self.activeController then
			self.activeController:Enable(false)
		end
		self.activeController = nil
		self.activeControlModule = nil
	else
		if not self.controllers[controlModule] then
			self.controllers[controlModule] = controlModule.new(CONTROL_ACTION_PRIORITY)
		end
		if self.activeController ~= self.controllers[controlModule] then
			if self.activeController then
				self.activeController:Enable(false)
			end
			self.activeController = self.controllers[controlModule]
			self.activeControlModule = controlModule
			if self.touchControlFrame and (self.activeControlModule == TouchThumbpad or self.activeControlModule == TouchThumbstick or self.activeControlModule == ClickToMove or self.activeControlModule == DynamicThumbstick) then
				if not self.controllers[TouchJump] then
					self.controllers[TouchJump] = TouchJump.new()
				end
				self.touchJumpController = self.controllers[TouchJump]
				self.touchJumpController:Enable(true, self.touchControlFrame)
			elseif self.touchJumpController then
				self.touchJumpController:Enable(false)
			end
			self:EnableActiveControlModule()
		end
	end
end
function ControlModule:OnLastInputTypeChanged(newLastInputType)
	if lastInputType == newLastInputType then
		warn("LastInputType Change listener called with current type.")
	end
	lastInputType = newLastInputType
	if lastInputType == Enum.UserInputType.Touch then
		local touchModule, success = self:SelectTouchModule()
		if success then
			while not self.touchControlFrame do
				wait()
			end
			self:SwitchToController(touchModule)
		end
	elseif computerInputTypeToModuleMap[lastInputType] ~= nil then
		local computerModule = self:SelectComputerMovementModule()
		if computerModule then
			self:SwitchToController(computerModule)
		end
	end
end
function ControlModule:OnComputerMovementModeChange()
	local controlModule, success = self:SelectComputerMovementModule()
	if success then
		self:SwitchToController(controlModule)
	end
end
function ControlModule:OnTouchMovementModeChange()
	local touchModule, success = self:SelectTouchModule()
	if success then
		while not self.touchControlFrame do
			wait()
		end
		self:SwitchToController(touchModule)
	end
end
function ControlModule:CreateTouchGuiContainer()
	if self.touchGui then
		self.touchGui:Destroy()
	end
	self.touchGui = Instance.new("ScreenGui")
	self.touchGui.Name = "TouchGui"
	self.touchGui.ResetOnSpawn = false
	self.touchControlFrame = Instance.new("Frame")
	self.touchControlFrame.Name = "TouchControlFrame"
	self.touchControlFrame.Size = UDim2.new(1, 0, 1, 0)
	self.touchControlFrame.BackgroundTransparency = 1
	self.touchControlFrame.Parent = self.touchGui
	self.touchGui.Parent = self.playerGui
end
function ControlModule:GetClickToMoveController()
	if not self.controllers[ClickToMove] then
		self.controllers[ClickToMove] = ClickToMove.new(CONTROL_ACTION_PRIORITY)
	end
	return self.controllers[ClickToMove]
end
return ControlModule.new()
]]></ProtectedString><string name="Name">ControlModule</string></Properties><Item class="ModuleScript" referent="RBX350"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchJump = setmetatable({}, BaseCharacterController)
TouchJump.__index = TouchJump
function TouchJump.new()
	local self = setmetatable(BaseCharacterController.new(), TouchJump)
	self.parentUIFrame = nil
	self.jumpButton = nil
	self.characterAddedConn = nil
	self.humanoidStateEnabledChangedConn = nil
	self.humanoidJumpPowerConn = nil
	self.humanoidParentConn = nil
	self.externallyEnabled = false
	self.jumpPower = 0
	self.jumpStateEnabled = true
	self.isJumping = false
	self.humanoid = nil
	return self
end
function TouchJump:EnableButton(enable)
	if enable then
		if not self.jumpButton then
			self:Create()
		end
		local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
		if humanoid and self.externallyEnabled and self.externallyEnabled and humanoid.JumpPower > 0 then
			self.jumpButton.Visible = true
		end
	else
		self.jumpButton.Visible = false
		self.isJumping = false
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	end
end
function TouchJump:UpdateEnabled()
	if self.jumpPower > 0 and self.jumpStateEnabled then
		self:EnableButton(true)
	else
		self:EnableButton(false)
	end
end
function TouchJump:HumanoidChanged(prop)
	local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if prop == "JumpPower" then
			self.jumpPower = humanoid.JumpPower
			self:UpdateEnabled()
		elseif prop == "Parent" and not humanoid.Parent then
			self.humanoidChangeConn:Disconnect()
		end
	end
end
function TouchJump:HumanoidStateEnabledChanged(state, isEnabled)
	if state == Enum.HumanoidStateType.Jumping then
		self.jumpStateEnabled = isEnabled
		self:UpdateEnabled()
	end
end
function TouchJump:CharacterAdded(char)
	if self.humanoidChangeConn then
		self.humanoidChangeConn:Disconnect()
		self.humanoidChangeConn = nil
	end
	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	while not self.humanoid do
		char.ChildAdded:wait()
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
	end
	self.humanoidJumpPowerConn = self.humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
		self.jumpPower = self.humanoid.JumpPower
		self:UpdateEnabled()
	end)
	self.humanoidParentConn = self.humanoid:GetPropertyChangedSignal("Parent"):Connect(function()
		if not self.humanoid.Parent then
			self.humanoidJumpPowerConn:Disconnect()
			self.humanoidJumpPowerConn = nil
			self.humanoidParentConn:Disconnect()
			self.humanoidParentConn = nil
		end
	end)
	self.humanoidStateEnabledChangedConn = self.humanoid.StateEnabledChanged:Connect(function(state, enabled)
		self:HumanoidStateEnabledChanged(state, enabled)
	end)
	self.jumpPower = self.humanoid.JumpPower
	self.jumpStateEnabled = self.humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping)
	self:UpdateEnabled()
end
function TouchJump:SetupCharacterAddedFunction()
	self.characterAddedConn = Players.LocalPlayer.CharacterAdded:Connect(function(char)
		self:CharacterAdded(char)
	end)
	if Players.LocalPlayer.Character then
		self:CharacterAdded(Players.LocalPlayer.Character)
	end
end
function TouchJump:Enable(enable, parentFrame)
	if parentFrame then
		self.parentUIFrame = parentFrame
	end
	self.externallyEnabled = enable
	self:EnableButton(enable)
end
function TouchJump:Create()
	if not self.parentUIFrame then
		return
	end
	if self.jumpButton then
		self.jumpButton:Destroy()
		self.jumpButton = nil
	end
	local minAxis = math.min(self.parentUIFrame.AbsoluteSize.x, self.parentUIFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	local jumpButtonSize = isSmallScreen and 70 or 120
	self.jumpButton = Instance.new("ImageButton")
	self.jumpButton.Name = "JumpButton"
	self.jumpButton.Visible = false
	self.jumpButton.BackgroundTransparency = 1
	self.jumpButton.Image = TOUCH_CONTROL_SHEET
	self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	self.jumpButton.ImageRectSize = Vector2.new(144, 144)
	self.jumpButton.Size = UDim2.new(0, jumpButtonSize, 0, jumpButtonSize)
	self.jumpButton.Position = isSmallScreen and UDim2.new(1, -(jumpButtonSize * 1.5 - 10), 1, -jumpButtonSize - 20) or UDim2.new(1, -(jumpButtonSize * 1.5 - 10), 1, -jumpButtonSize * 1.75)
	local touchObject
	self.jumpButton.InputBegan:connect(function(inputObject)
		if touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		touchObject = inputObject
		self.jumpButton.ImageRectOffset = Vector2.new(146, 146)
		self.isJumping = true
	end)
	local function OnInputEnded()
		touchObject = nil
		self.isJumping = false
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	end
	self.jumpButton.InputEnded:connect(function(inputObject)
		if inputObject == touchObject then
			OnInputEnded()
		end
	end)
	GuiService.MenuOpened:connect(function()
		if touchObject then
			OnInputEnded()
		end
	end)
	if not self.characterAddedConn then
		self:SetupCharacterAddedFunction()
	end
	self.jumpButton.Parent = self.parentUIFrame
end
return TouchJump
]]></ProtectedString><string name="Name">TouchJump</string></Properties></Item><Item class="ModuleScript" referent="RBX355"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local Keyboard = setmetatable({}, BaseCharacterController)
Keyboard.__index = Keyboard
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
function Keyboard.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new(), Keyboard)
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	self.textFocusReleasedConn = nil
	self.textFocusGainedConn = nil
	self.windowFocusReleasedConn = nil
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.jumpEnabled = true
	return self
end
function Keyboard:Enable(enable)
	if not UserInputService.KeyboardEnabled then
		return false
	end
	if enable == self.enabled then
		return true
	end
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		self:BindContextActions()
		self:ConnectFocusEventListeners()
	else
		self:UnbindContextActions()
		self:DisconnectFocusEventListeners()
	end
	self.enabled = enable
	return true
end
function Keyboard:UpdateMovement(inputState)
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector = ZERO_VECTOR3
	else
		self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
	end
end
function Keyboard:BindContextActions()
	local function handleMoveForward(actionName, inputState, inputObject)
		self.forwardValue = inputState == Enum.UserInputState.Begin and -1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleMoveBackward(actionName, inputState, inputObject)
		self.backwardValue = inputState == Enum.UserInputState.Begin and 1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleMoveLeft(actionName, inputState, inputObject)
		self.leftValue = inputState == Enum.UserInputState.Begin and -1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleMoveRight(actionName, inputState, inputObject)
		self.rightValue = inputState == Enum.UserInputState.Begin and 1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleJumpAction(actionName, inputState, inputObject)
		self.isJumping = self.jumpEnabled and inputState == Enum.UserInputState.Begin
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		ContextActionService:BindActionAtPriority("moveForwardAction", handleMoveForward, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterForward)
		ContextActionService:BindActionAtPriority("moveBackwardAction", handleMoveBackward, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterBackward)
		ContextActionService:BindActionAtPriority("moveLeftAction", handleMoveLeft, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterLeft)
		ContextActionService:BindActionAtPriority("moveRightAction", handleMoveRight, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterRight)
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterJump)
	else
		ContextActionService:BindAction("moveForwardAction", handleMoveForward, false, Enum.PlayerActions.CharacterForward)
		ContextActionService:BindAction("moveBackwardAction", handleMoveBackward, false, Enum.PlayerActions.CharacterBackward)
		ContextActionService:BindAction("moveLeftAction", handleMoveLeft, false, Enum.PlayerActions.CharacterLeft)
		ContextActionService:BindAction("moveRightAction", handleMoveRight, false, Enum.PlayerActions.CharacterRight)
		ContextActionService:BindAction("jumpAction", handleJumpAction, false, Enum.PlayerActions.CharacterJump)
	end
end
function Keyboard:UnbindContextActions()
	ContextActionService:UnbindAction("moveForwardAction")
	ContextActionService:UnbindAction("moveBackwardAction")
	ContextActionService:UnbindAction("moveLeftAction")
	ContextActionService:UnbindAction("moveRightAction")
	ContextActionService:UnbindAction("jumpAction")
end
function Keyboard:ConnectFocusEventListeners()
	local function onFocusReleased()
		self.moveVector = ZERO_VECTOR3
		self.forwardValue = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.isJumping = false
	end
	local function onTextFocusGained(textboxFocused)
		self.isJumping = false
	end
	self.textFocusReleasedConn = UserInputService.TextBoxFocusReleased:Connect(onFocusReleased)
	self.textFocusGainedConn = UserInputService.TextBoxFocused:Connect(onTextFocusGained)
	self.windowFocusReleasedConn = UserInputService.WindowFocused:Connect(onFocusReleased)
end
function Keyboard:DisconnectFocusEventListeners()
	if self.textFocusReleasedCon then
		self.textFocusReleasedCon:Disconnect()
		self.textFocusReleasedCon = nil
	end
	if self.textFocusGainedConn then
		self.textFocusGainedConn:Disconnect()
		self.textFocusGainedConn = nil
	end
	if self.windowFocusReleasedConn then
		self.windowFocusReleasedConn:Disconnect()
		self.windowFocusReleasedConn = nil
	end
end
return Keyboard
]]></ProtectedString><string name="Name">Keyboard</string></Properties></Item><Item class="ModuleScript" referent="RBX360"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ClickToMoveDisplay = {}
local FAILURE_ANIMATION_ID = "rbxassetid://2874840706"
local TrailDotIcon = "rbxasset://textures/ui/traildot.png"
local EndWaypointIcon = "rbxasset://textures/ui/waypoint.png"
local WaypointsAlwaysOnTop = false
local WAYPOINT_INCLUDE_FACTOR = 2
local LAST_DOT_DISTANCE = 3
local WAYPOINT_BILLBOARD_SIZE = UDim2.new(0, 42, 0, 50)
local ENDWAYPOINT_SIZE_OFFSET_MIN = Vector2.new(0, 0.5)
local ENDWAYPOINT_SIZE_OFFSET_MAX = Vector2.new(0, 1)
local FAIL_WAYPOINT_SIZE_OFFSET_CENTER = Vector2.new(0, 0.5)
local FAIL_WAYPOINT_SIZE_OFFSET_LEFT = Vector2.new(0.1, 0.5)
local FAIL_WAYPOINT_SIZE_OFFSET_RIGHT = Vector2.new(-0.1, 0.5)
local FAILURE_TWEEN_LENGTH = 0.125
local FAILURE_TWEEN_COUNT = 4
local TWEEN_WAYPOINT_THRESHOLD = 5
local TRAIL_DOT_PARENT_NAME = "ClickToMoveDisplay"
local TrailDotSize = Vector2.new(1.5, 1.5)
local TRAIL_DOT_MIN_SCALE = 1
local TRAIL_DOT_MIN_DISTANCE = 10
local TRAIL_DOT_MAX_SCALE = 2.5
local TRAIL_DOT_MAX_DISTANCE = 100
local PlayersService = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = PlayersService.LocalPlayer
local function CreateWaypointTemplates()
	local TrailDotTemplate = Instance.new("Part")
	TrailDotTemplate.Size = Vector3.new(1, 1, 1)
	TrailDotTemplate.Anchored = true
	TrailDotTemplate.CanCollide = false
	TrailDotTemplate.Name = "TrailDot"
	TrailDotTemplate.Transparency = 1
	local TrailDotImage = Instance.new("ImageHandleAdornment")
	TrailDotImage.Name = "TrailDotImage"
	TrailDotImage.Size = TrailDotSize
	TrailDotImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
	TrailDotImage.AlwaysOnTop = WaypointsAlwaysOnTop
	TrailDotImage.Image = TrailDotIcon
	TrailDotImage.Adornee = TrailDotTemplate
	TrailDotImage.Parent = TrailDotTemplate
	local EndWaypointTemplate = Instance.new("Part")
	EndWaypointTemplate.Size = Vector3.new(2, 2, 2)
	EndWaypointTemplate.Anchored = true
	EndWaypointTemplate.CanCollide = false
	EndWaypointTemplate.Name = "EndWaypoint"
	EndWaypointTemplate.Transparency = 1
	local EndWaypointImage = Instance.new("ImageHandleAdornment")
	EndWaypointImage.Name = "TrailDotImage"
	EndWaypointImage.Size = TrailDotSize
	EndWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
	EndWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
	EndWaypointImage.Image = TrailDotIcon
	EndWaypointImage.Adornee = EndWaypointTemplate
	EndWaypointImage.Parent = EndWaypointTemplate
	local EndWaypointBillboard = Instance.new("BillboardGui")
	EndWaypointBillboard.Name = "EndWaypointBillboard"
	EndWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
	EndWaypointBillboard.LightInfluence = 0
	EndWaypointBillboard.SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MIN
	EndWaypointBillboard.AlwaysOnTop = true
	EndWaypointBillboard.Adornee = EndWaypointTemplate
	EndWaypointBillboard.Parent = EndWaypointTemplate
	local EndWaypointImageLabel = Instance.new("ImageLabel")
	EndWaypointImageLabel.Image = EndWaypointIcon
	EndWaypointImageLabel.BackgroundTransparency = 1
	EndWaypointImageLabel.Size = UDim2.new(1, 0, 1, 0)
	EndWaypointImageLabel.Parent = EndWaypointBillboard
	local FailureWaypointTemplate = Instance.new("Part")
	FailureWaypointTemplate.Size = Vector3.new(2, 2, 2)
	FailureWaypointTemplate.Anchored = true
	FailureWaypointTemplate.CanCollide = false
	FailureWaypointTemplate.Name = "FailureWaypoint"
	FailureWaypointTemplate.Transparency = 1
	local FailureWaypointImage = Instance.new("ImageHandleAdornment")
	FailureWaypointImage.Name = "TrailDotImage"
	FailureWaypointImage.Size = TrailDotSize
	FailureWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
	FailureWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
	FailureWaypointImage.Image = TrailDotIcon
	FailureWaypointImage.Adornee = FailureWaypointTemplate
	FailureWaypointImage.Parent = FailureWaypointTemplate
	local FailureWaypointBillboard = Instance.new("BillboardGui")
	FailureWaypointBillboard.Name = "FailureWaypointBillboard"
	FailureWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
	FailureWaypointBillboard.LightInfluence = 0
	FailureWaypointBillboard.SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER
	FailureWaypointBillboard.AlwaysOnTop = true
	FailureWaypointBillboard.Adornee = FailureWaypointTemplate
	FailureWaypointBillboard.Parent = FailureWaypointTemplate
	local FailureWaypointFrame = Instance.new("Frame")
	FailureWaypointFrame.BackgroundTransparency = 1
	FailureWaypointFrame.Size = UDim2.new(0, 0, 0, 0)
	FailureWaypointFrame.Position = UDim2.new(0.5, 0, 1, 0)
	FailureWaypointFrame.Parent = FailureWaypointBillboard
	local FailureWaypointImageLabel = Instance.new("ImageLabel")
	FailureWaypointImageLabel.Image = EndWaypointIcon
	FailureWaypointImageLabel.BackgroundTransparency = 1
	FailureWaypointImageLabel.Position = UDim2.new(0, -WAYPOINT_BILLBOARD_SIZE.X.Offset / 2, 0, -WAYPOINT_BILLBOARD_SIZE.Y.Offset)
	FailureWaypointImageLabel.Size = WAYPOINT_BILLBOARD_SIZE
	FailureWaypointImageLabel.Parent = FailureWaypointFrame
	return TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate
end
local TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
local function getTrailDotParent()
	local camera = Workspace.CurrentCamera
	local trailParent = camera:FindFirstChild(TRAIL_DOT_PARENT_NAME)
	if not trailParent then
		trailParent = Instance.new("Model")
		trailParent.Name = TRAIL_DOT_PARENT_NAME
		trailParent.Parent = camera
	end
	return trailParent
end
local function placePathWaypoint(waypointModel, position)
	local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
	local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(ray, {
		Workspace.CurrentCamera,
		LocalPlayer.Character
	})
	if hitPart then
		waypointModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
		waypointModel.Parent = getTrailDotParent()
	end
end
local TrailDot = {}
TrailDot.__index = TrailDot
function TrailDot:Destroy()
	self.DisplayModel:Destroy()
end
function TrailDot:NewDisplayModel(position)
	local newDisplayModel = TrailDotTemplate:Clone()
	placePathWaypoint(newDisplayModel, position)
	return newDisplayModel
end
function TrailDot.new(position, closestWaypoint)
	local self = setmetatable({}, TrailDot)
	self.DisplayModel = self:NewDisplayModel(position)
	self.ClosestWayPoint = closestWaypoint
	return self
end
local EndWaypoint = {}
EndWaypoint.__index = EndWaypoint
function EndWaypoint:Destroy()
	self.Destroyed = true
	self.Tween:Cancel()
	self.DisplayModel:Destroy()
end
function EndWaypoint:NewDisplayModel(position)
	local newDisplayModel = EndWaypointTemplate:Clone()
	placePathWaypoint(newDisplayModel, position)
	return newDisplayModel
end
function EndWaypoint:CreateTween()
	local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, -1, true)
	local tween = TweenService:Create(self.DisplayModel.EndWaypointBillboard, tweenInfo, {SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MAX})
	tween:Play()
	return tween
end
function EndWaypoint:TweenInFrom(originalPosition)
	local currentPositon = self.DisplayModel.Position
	local studsOffset = originalPosition - currentPositon
	self.DisplayModel.EndWaypointBillboard.StudsOffset = Vector3.new(0, studsOffset.Y, 0)
	local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local tween = TweenService:Create(self.DisplayModel.EndWaypointBillboard, tweenInfo, {
		StudsOffset = Vector3.new(0, 0, 0)
	})
	tween:Play()
	return tween
end
function EndWaypoint.new(position, closestWaypoint, originalPosition)
	local self = setmetatable({}, EndWaypoint)
	self.DisplayModel = self:NewDisplayModel(position)
	self.Destroyed = false
	if originalPosition and (originalPosition - position).magnitude > TWEEN_WAYPOINT_THRESHOLD then
		self.Tween = self:TweenInFrom(originalPosition)
		coroutine.wrap(function()
			self.Tween.Completed:Wait()
			if not self.Destroyed then
				self.Tween = self:CreateTween()
			end
		end)()
	else
		self.Tween = self:CreateTween()
	end
	self.ClosestWayPoint = closestWaypoint
	return self
end
local FailureWaypoint = {}
FailureWaypoint.__index = FailureWaypoint
function FailureWaypoint:Hide()
	self.DisplayModel.Parent = nil
end
function FailureWaypoint:Destroy()
	self.DisplayModel:Destroy()
end
function FailureWaypoint:NewDisplayModel(position)
	local newDisplayModel = FailureWaypointTemplate:Clone()
	placePathWaypoint(newDisplayModel, position)
	local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
	local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(ray, {
		Workspace.CurrentCamera,
		LocalPlayer.Character
	})
	if hitPart then
		newDisplayModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
		newDisplayModel.Parent = getTrailDotParent()
	end
	return newDisplayModel
end
function FailureWaypoint:RunFailureTween()
	wait(FAILURE_TWEEN_LENGTH)
	local tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH / 2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local tweenLeft = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo, {SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_LEFT})
	tweenLeft:Play()
	local tweenLeftRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo, {Rotation = 10})
	tweenLeftRoation:Play()
	tweenLeft.Completed:wait()
	tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, FAILURE_TWEEN_COUNT - 1, true)
	local tweenSideToSide = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo, {SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_RIGHT})
	tweenSideToSide:Play()
	tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, FAILURE_TWEEN_COUNT - 1, true)
	local tweenFlash = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame.ImageLabel, tweenInfo, {
		ImageColor3 = Color3.new(0.75, 0.75, 0.75)
	})
	tweenFlash:Play()
	local tweenRotate = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo, {Rotation = -10})
	tweenRotate:Play()
	tweenSideToSide.Completed:wait()
	tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH / 2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local tweenCenter = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo, {SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER})
	tweenCenter:Play()
	local tweenRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo, {Rotation = 0})
	tweenRoation:Play()
	tweenCenter.Completed:wait()
	wait(FAILURE_TWEEN_LENGTH)
end
function FailureWaypoint.new(position)
	local self = setmetatable({}, FailureWaypoint)
	self.DisplayModel = self:NewDisplayModel(position)
	return self
end
local failureAnimation = Instance.new("Animation")
failureAnimation.AnimationId = FAILURE_ANIMATION_ID
local lastHumanoid, lastFailureAnimationTrack
local function getFailureAnimationTrack(myHumanoid)
	if myHumanoid == lastHumanoid then
		return lastFailureAnimationTrack
	end
	lastFailureAnimationTrack = myHumanoid:LoadAnimation(failureAnimation)
	lastFailureAnimationTrack.Priority = Enum.AnimationPriority.Action
	lastFailureAnimationTrack.Looped = false
	return lastFailureAnimationTrack
end
local function findPlayerHumanoid()
	local character = LocalPlayer.Character
	if character then
		return character:FindFirstChildOfClass("Humanoid")
	end
end
local function createTrailDots(wayPoints, originalEndWaypoint)
	local newTrailDots = {}
	local count = 1
	for i = 1, #wayPoints - 1 do
		local closeToEnd = (wayPoints[i].Position - wayPoints[#wayPoints].Position).magnitude < LAST_DOT_DISTANCE
		local includeWaypoint = i % WAYPOINT_INCLUDE_FACTOR == 0 and not closeToEnd
		if includeWaypoint then
			local trailDot = TrailDot.new(wayPoints[i].Position, i)
			newTrailDots[count] = trailDot
			count = count + 1
		end
	end
	local newEndWaypoint = EndWaypoint.new(wayPoints[#wayPoints].Position, #wayPoints, originalEndWaypoint)
	table.insert(newTrailDots, newEndWaypoint)
	local reversedTrailDots = {}
	count = 1
	for i = #newTrailDots, 1, -1 do
		reversedTrailDots[count] = newTrailDots[i]
		count = count + 1
	end
	return reversedTrailDots
end
local function getTrailDotScale(distanceToCamera, defaultSize)
	local rangeLength = TRAIL_DOT_MAX_DISTANCE - TRAIL_DOT_MIN_DISTANCE
	local inRangePoint = math.clamp(distanceToCamera - TRAIL_DOT_MIN_DISTANCE, 0, rangeLength) / rangeLength
	local scale = TRAIL_DOT_MIN_SCALE + (TRAIL_DOT_MAX_SCALE - TRAIL_DOT_MIN_SCALE) * inRangePoint
	return defaultSize * scale
end
local createPathCount = 0
function ClickToMoveDisplay.CreatePathDisplay(wayPoints, originalEndWaypoint)
	createPathCount = createPathCount + 1
	local trailDots = createTrailDots(wayPoints, originalEndWaypoint)
	local function removePathBeforePoint(wayPointNumber)
		for i = #trailDots, 1, -1 do
			local trailDot = trailDots[i]
			if wayPointNumber >= trailDot.ClosestWayPoint then
				trailDot:Destroy()
				trailDots[i] = nil
			else
				break
			end
		end
	end
	local reiszeTrailDotsUpdateName = "ClickToMoveResizeTrail" .. createPathCount
	local function resizeTrailDots()
		if #trailDots == 0 then
			RunService:UnbindFromRenderStep(reiszeTrailDotsUpdateName)
			return
		end
		local cameraPos = Workspace.CurrentCamera.CFrame.p
		for i = 1, #trailDots do
			local trailDotImage = trailDots[i].DisplayModel:FindFirstChild("TrailDotImage")
			if trailDotImage then
				local distanceToCamera = (trailDots[i].DisplayModel.Position - cameraPos).magnitude
				trailDotImage.Size = getTrailDotScale(distanceToCamera, TrailDotSize)
			end
		end
	end
	RunService:BindToRenderStep(reiszeTrailDotsUpdateName, Enum.RenderPriority.Camera.Value - 1, resizeTrailDots)
	local function removePath()
		removePathBeforePoint(#wayPoints)
	end
	return removePath, removePathBeforePoint
end
local lastFailureWaypoint
function ClickToMoveDisplay.DisplayFailureWaypoint(position)
	if lastFailureWaypoint then
		lastFailureWaypoint:Hide()
	end
	local failureWaypoint = FailureWaypoint.new(position)
	lastFailureWaypoint = failureWaypoint
	coroutine.wrap(function()
		failureWaypoint:RunFailureTween()
		failureWaypoint:Destroy()
		failureWaypoint = nil
	end)()
end
function ClickToMoveDisplay.CreateEndWaypoint(position)
	return EndWaypoint.new(position)
end
function ClickToMoveDisplay.PlayFailureAnimation()
	local myHumanoid = findPlayerHumanoid()
	if myHumanoid then
		local animationTrack = getFailureAnimationTrack(myHumanoid)
		animationTrack:Play()
	end
end
function ClickToMoveDisplay.CancelFailureAnimation()
	if lastFailureAnimationTrack ~= nil and lastFailureAnimationTrack.IsPlaying then
		lastFailureAnimationTrack:Stop()
	end
end
function ClickToMoveDisplay.SetWaypointTexture(texture)
	TrailDotIcon = texture
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end
function ClickToMoveDisplay.GetWaypointTexture()
	return TrailDotIcon
end
function ClickToMoveDisplay.SetWaypointRadius(radius)
	TrailDotSize = Vector2.new(radius, radius)
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end
function ClickToMoveDisplay.GetWaypointRadius()
	return TrailDotSize.X
end
function ClickToMoveDisplay.SetEndWaypointTexture(texture)
	EndWaypointIcon = texture
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end
function ClickToMoveDisplay.GetEndWaypointTexture()
	return EndWaypointIcon
end
function ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
	WaypointsAlwaysOnTop = alwaysOnTop
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end
function ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
	return WaypointsAlwaysOnTop
end
return ClickToMoveDisplay
]]></ProtectedString><string name="Name">ClickToMoveDisplay</string></Properties></Item><Item class="ModuleScript" referent="RBX365"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local DPAD_SHEET = "rbxasset://textures/ui/DPadSheet.png"
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local UNIT_Z = Vector3.new(0, 0, 1)
local UNIT_X = Vector3.new(1, 0, 0)
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchThumbpad = setmetatable({}, BaseCharacterController)
TouchThumbpad.__index = TouchThumbpad
function TouchThumbpad.new()
	local self = setmetatable(BaseCharacterController.new(), TouchThumbpad)
	self.thumbpadFrame = nil
	self.touchChangedConn = nil
	self.touchEndedConn = nil
	self.menuOpenedConn = nil
	self.screenPos = nil
	self.isRight, self.isLeft, self.isUp, self.isDown = false, false, false, false
	self.smArrowSize = nil
	self.lgArrowSize = nil
	self.smImgOffset = nil
	self.lgImgOffset = nil
	return self
end
local doTween = function(guiObject, endSize, endPosition)
	guiObject:TweenSizeAndPosition(endSize, endPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, 0.15, true)
end
local function CreateArrowLabel(name, position, size, rectOffset, rectSize, parent)
	local image = Instance.new("ImageLabel")
	image.Name = name
	image.Image = DPAD_SHEET
	image.ImageRectOffset = rectOffset
	image.ImageRectSize = rectSize
	image.BackgroundTransparency = 1
	image.ImageColor3 = Color3.fromRGB(190, 190, 190)
	image.Size = size
	image.Position = position
	image.Parent = parent
	return image
end
function TouchThumbpad:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		if not self.thumbpadFrame then
			self:Create(uiParentFrame)
		end
		self.thumbpadFrame.Visible = true
	else
		self.thumbpadFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end
function TouchThumbpad:OnInputEnded()
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	self.thumbpadFrame.Position = self.screenPos
	self.touchObject = nil
	self.isUp, self.isDown, self.isLeft, self.isRight = false, false, false, false
	doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset))
	doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset))
	doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
	doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
end
function TouchThumbpad:Create(parentFrame)
	if self.thumbpadFrame then
		self.thumbpadFrame:Destroy()
		self.thumbpadFrame = nil
	end
	if self.touchChangedConn then
		self.touchChangedConn:Disconnect()
		self.touchChangedConn = nil
	end
	if self.touchEndedConn then
		self.touchEndedConn:Disconnect()
		self.touchEndedConn = nil
	end
	if self.menuOpenedConn then
		self.menuOpenedConn:Disconnect()
		self.menuOpenedConn = nil
	end
	local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	local thumbpadSize = isSmallScreen and 70 or 120
	self.screenPos = isSmallScreen and UDim2.new(0, thumbpadSize * 1.25, 1, -thumbpadSize - 20) or UDim2.new(0, thumbpadSize * 0.5 - 10, 1, -thumbpadSize * 1.75 - 10)
	self.thumbpadFrame = Instance.new("Frame")
	self.thumbpadFrame.Name = "ThumbpadFrame"
	self.thumbpadFrame.Visible = false
	self.thumbpadFrame.Active = true
	self.thumbpadFrame.Size = UDim2.new(0, thumbpadSize + 20, 0, thumbpadSize + 20)
	self.thumbpadFrame.Position = self.screenPos
	self.thumbpadFrame.BackgroundTransparency = 1
	local outerImage = Instance.new("ImageLabel")
	outerImage.Name = "OuterImage"
	outerImage.Image = TOUCH_CONTROL_SHEET
	outerImage.ImageRectOffset = Vector2.new(0, 0)
	outerImage.ImageRectSize = Vector2.new(220, 220)
	outerImage.BackgroundTransparency = 1
	outerImage.Size = UDim2.new(0, thumbpadSize, 0, thumbpadSize)
	outerImage.Position = UDim2.new(0, 10, 0, 10)
	outerImage.Parent = self.thumbpadFrame
	self.smArrowSize = isSmallScreen and UDim2.new(0, 32, 0, 32) or UDim2.new(0, 64, 0, 64)
	self.lgArrowSize = UDim2.new(0, self.smArrowSize.X.Offset * 2, 0, self.smArrowSize.Y.Offset * 2)
	local imgRectSize = Vector2.new(110, 110)
	self.smImgOffset = isSmallScreen and -4 or -9
	self.lgImgOffset = isSmallScreen and -28 or -55
	self.dArrow = CreateArrowLabel("DownArrow", UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset), self.smArrowSize, Vector2.new(8, 8), imgRectSize, outerImage)
	self.uArrow = CreateArrowLabel("UpArrow", UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset), self.smArrowSize, Vector2.new(8, 266), imgRectSize, outerImage)
	self.lArrow = CreateArrowLabel("LeftArrow", UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset), self.smArrowSize, Vector2.new(137, 137), imgRectSize, outerImage)
	self.rArrow = CreateArrowLabel("RightArrow", UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset), self.smArrowSize, Vector2.new(8, 137), imgRectSize, outerImage)
	local doTween = function(guiObject, endSize, endPosition)
		guiObject:TweenSizeAndPosition(endSize, endPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, 0.15, true)
	end
	local padOrigin
	local deadZone = 0.1
	self.isRight, self.isLeft, self.isUp, self.isDown = false, false, false, false
	local function doMove(pos)
		local moveDelta = pos - padOrigin
		local moveVector2 = 2 * moveDelta / thumbpadSize
		if moveVector2.Magnitude < deadZone then
			self.moveVector = ZERO_VECTOR3
		else
			moveVector2 = moveVector2.unit * ((moveVector2.Magnitude - deadZone) / (1 - deadZone))
			if moveVector2.Magnitude == 0 then
				self.moveVector = ZERO_VECTOR3
			else
				self.moveVector = Vector3.new(moveVector2.x, 0, moveVector2.y).Unit
			end
		end
		local forwardDot = self.moveVector:Dot(-UNIT_Z)
		local rightDot = self.moveVector:Dot(UNIT_X)
		if forwardDot > 0.5 then
			if not self.isUp then
				self.isUp, self.isDown = true, false
				doTween(self.uArrow, self.lgArrowSize, UDim2.new(0.5, -self.smArrowSize.X.Offset, 0, self.smImgOffset - 1.5 * self.smArrowSize.Y.Offset))
				doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset))
			end
		elseif forwardDot < -0.5 then
			if not self.isDown then
				self.isDown, self.isUp = true, false
				doTween(self.dArrow, self.lgArrowSize, UDim2.new(0.5, -self.smArrowSize.X.Offset, 1, self.lgImgOffset + 0.5 * self.smArrowSize.Y.Offset))
				doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset))
			end
		else
			self.isUp, self.isDown = false, false
			doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset))
			doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset))
		end
		if rightDot > 0.5 then
			if not self.isRight then
				self.isRight, self.isLeft = true, false
				doTween(self.rArrow, self.lgArrowSize, UDim2.new(1, self.lgImgOffset + 0.5 * self.smArrowSize.X.Offset, 0.5, -self.smArrowSize.Y.Offset))
				doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
			end
		elseif rightDot < -0.5 then
			if not self.isLeft then
				self.isLeft, self.isRight = true, false
				doTween(self.lArrow, self.lgArrowSize, UDim2.new(0, self.smImgOffset - 1.5 * self.smArrowSize.X.Offset, 0.5, -self.smArrowSize.Y.Offset))
				doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
			end
		else
			self.isRight, self.isLeft = false, false
			doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
			doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
		end
	end
	self.thumbpadFrame.InputBegan:connect(function(inputObject)
		if self.touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		self.thumbpadFrame.Position = UDim2.new(0, inputObject.Position.x - 0.5 * self.thumbpadFrame.AbsoluteSize.x, 0, inputObject.Position.y - 0.5 * self.thumbpadFrame.Size.Y.Offset)
		padOrigin = Vector3.new(self.thumbpadFrame.AbsolutePosition.x + 0.5 * self.thumbpadFrame.AbsoluteSize.x, self.thumbpadFrame.AbsolutePosition.y + 0.5 * self.thumbpadFrame.AbsoluteSize.y, 0)
		doMove(inputObject.Position)
		self.touchObject = inputObject
	end)
	self.touchChangedConn = UserInputService.TouchMoved:connect(function(inputObject, isProcessed)
		if inputObject == self.touchObject then
			doMove(self.touchObject.Position)
		end
	end)
	self.touchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject)
		if inputObject == self.touchObject then
			self:OnInputEnded()
		end
	end)
	self.menuOpenedConn = GuiService.MenuOpened:Connect(function()
		if self.touchObject then
			self:OnInputEnded()
		end
	end)
	self.thumbpadFrame.Parent = parentFrame
end
return TouchThumbpad
]]></ProtectedString><string name="Name">TouchThumbpad</string></Properties></Item><Item class="ModuleScript" referent="RBX370"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local VRService = game:GetService("VRService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local ContextActionService = game:GetService("ContextActionService")
local StarterGui = game:GetService("StarterGui")
local PathDisplay
local LocalPlayer = Players.LocalPlayer
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local RECALCULATE_PATH_THRESHOLD = 4
local NO_PATH_THRESHOLD = 12
local MAX_PATHING_DISTANCE = 200
local POINT_REACHED_THRESHOLD = 1
local OFFTRACK_TIME_THRESHOLD = 2
local THUMBSTICK_DEADZONE = 0.22
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local XZ_VECTOR3 = Vector3.new(1, 0, 1)
local IsFinite = function(num)
	return num == num and num ~= 1 / 0 and num ~= -1 / 0
end
local function IsFiniteVector3(vec3)
	return IsFinite(vec3.x) and IsFinite(vec3.y) and IsFinite(vec3.z)
end
local movementUpdateEvent = Instance.new("BindableEvent")
movementUpdateEvent.Name = "MovementUpdate"
movementUpdateEvent.Parent = script
coroutine.wrap(function()
	local PathDisplayModule = script.Parent:WaitForChild("PathDisplay")
	if PathDisplayModule then
		PathDisplay = require(PathDisplayModule)
	end
end)()
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local VRNavigation = setmetatable({}, BaseCharacterController)
VRNavigation.__index = VRNavigation
function VRNavigation.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new(), VRNavigation)
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	self.navigationRequestedConn = nil
	self.heartbeatConn = nil
	self.currentDestination = nil
	self.currentPath = nil
	self.currentPoints = nil
	self.currentPointIdx = 0
	self.expectedTimeToNextPoint = 0
	self.timeReachedLastPoint = tick()
	self.moving = false
	self.isJumpBound = false
	self.moveLatch = false
	self.userCFrameEnabledConn = nil
	return self
end
function VRNavigation:SetLaserPointerMode(mode)
	pcall(function()
		StarterGui:SetCore("VRLaserPointerMode", mode)
	end)
end
function VRNavigation:GetLocalHumanoid()
	local character = LocalPlayer.Character
	if not character then
		return
	end
	for _, child in pairs(character:GetChildren()) do
		if child:IsA("Humanoid") then
			return child
		end
	end
	return nil
end
function VRNavigation:HasBothHandControllers()
	return VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) and VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand)
end
function VRNavigation:HasAnyHandControllers()
	return VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) or VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand)
end
function VRNavigation:IsMobileVR()
	return UserInputService.TouchEnabled
end
function VRNavigation:HasGamepad()
	return UserInputService.GamepadEnabled
end
function VRNavigation:ShouldUseNavigationLaser()
	if self:IsMobileVR() then
		return true
	else
		if self:HasBothHandControllers() then
			return false
		end
		if not self:HasAnyHandControllers() then
			return not self:HasGamepad()
		end
		return true
	end
end
function VRNavigation:StartFollowingPath(newPath)
	currentPath = newPath
	currentPoints = currentPath:GetPointCoordinates()
	currentPointIdx = 1
	moving = true
	timeReachedLastPoint = tick()
	local humanoid = self:GetLocalHumanoid()
	if humanoid and humanoid.Torso and #currentPoints >= 1 then
		local dist = (currentPoints[1] - humanoid.Torso.Position).magnitude
		expectedTimeToNextPoint = dist / humanoid.WalkSpeed
	end
	movementUpdateEvent:Fire("targetPoint", self.currentDestination)
end
function VRNavigation:GoToPoint(point)
	currentPath = true
	currentPoints = {point}
	currentPointIdx = 1
	moving = true
	local humanoid = self:GetLocalHumanoid()
	local distance = (humanoid.Torso.Position - point).magnitude
	local estimatedTimeRemaining = distance / humanoid.WalkSpeed
	timeReachedLastPoint = tick()
	expectedTimeToNextPoint = estimatedTimeRemaining
	movementUpdateEvent:Fire("targetPoint", point)
end
function VRNavigation:StopFollowingPath()
	currentPath = nil
	currentPoints = nil
	currentPointIdx = 0
	moving = false
	self.moveVector = ZERO_VECTOR3
end
function VRNavigation:TryComputePath(startPos, destination)
	local numAttempts = 0
	local newPath
	while not newPath and numAttempts < 5 do
		newPath = PathfindingService:ComputeSmoothPathAsync(startPos, destination, MAX_PATHING_DISTANCE)
		numAttempts = numAttempts + 1
		if newPath.Status == Enum.PathStatus.ClosestNoPath or newPath.Status == Enum.PathStatus.ClosestOutOfRange then
			newPath = nil
			break
		end
		if newPath and newPath.Status == Enum.PathStatus.FailStartNotEmpty then
			startPos = startPos + (destination - startPos).unit
			newPath = nil
		end
		if newPath and newPath.Status == Enum.PathStatus.FailFinishNotEmpty then
			destination = destination + Vector3.new(0, 1, 0)
			newPath = nil
		end
	end
	return newPath
end
function VRNavigation:OnNavigationRequest(destinationCFrame, inputUserCFrame)
	local destinationPosition = destinationCFrame.p
	local lastDestination = self.currentDestination
	if not IsFiniteVector3(destinationPosition) then
		return
	end
	self.currentDestination = destinationPosition
	local humanoid = self:GetLocalHumanoid()
	if not humanoid or not humanoid.Torso then
		return
	end
	local currentPosition = humanoid.Torso.Position
	local distanceToDestination = (self.currentDestination - currentPosition).magnitude
	if distanceToDestination < NO_PATH_THRESHOLD then
		self:GoToPoint(self.currentDestination)
		return
	end
	if not lastDestination or (self.currentDestination - lastDestination).magnitude > RECALCULATE_PATH_THRESHOLD then
		local newPath = self:TryComputePath(currentPosition, self.currentDestination)
		if newPath then
			self:StartFollowingPath(newPath)
			if PathDisplay then
				PathDisplay.setCurrentPoints(self.currentPoints)
				PathDisplay.renderPath()
			end
		else
			self:StopFollowingPath()
			if PathDisplay then
				PathDisplay.clearRenderedPath()
			end
		end
	elseif moving then
		self.currentPoints[#currentPoints] = self.currentDestination
	else
		self:GoToPoint(self.currentDestination)
	end
end
function VRNavigation:OnJumpAction(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin then
		self.isJumping = true
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Sink
	end
end
function VRNavigation:BindJumpAction(active)
	if active then
		if not self.isJumpBound then
			self.isJumpBound = true
			if FFlagPlayerScriptsBindAtPriority2 then
				ContextActionService:BindActionAtPriority("VRJumpAction", function()
					return self:OnJumpAction()
				end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
			else
				ContextActionService:BindAction("VRJumpAction", function()
					self:OnJumpAction()
				end, false, Enum.KeyCode.ButtonA)
			end
		end
	elseif self.isJumpBound then
		self.isJumpBound = false
		ContextActionService:UnbindAction("VRJumpAction")
	end
end
function VRNavigation:ControlCharacterGamepad(actionName, inputState, inputObject)
	if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then
		return
	end
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector = ZERO_VECTOR3
		return
	end
	if inputState ~= Enum.UserInputState.End then
		self:StopFollowingPath()
		if PathDisplay then
			PathDisplay.clearRenderedPath()
		end
		if self:ShouldUseNavigationLaser() then
			self:BindJumpAction(true)
			self:SetLaserPointerMode("Hidden")
		end
		if inputObject.Position.magnitude > THUMBSTICK_DEADZONE then
			self.moveVector = Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
			if self.moveVector.magnitude > 0 then
				self.moveVector = self.moveVector.unit * math.min(1, inputObject.Position.magnitude)
			end
			self.moveLatch = true
		end
	else
		self.moveVector = ZERO_VECTOR3
		if self:ShouldUseNavigationLaser() then
			self:BindJumpAction(false)
			self:SetLaserPointerMode("Navigation")
		end
		if self.moveLatch then
			self.moveLatch = false
			movementUpdateEvent:Fire("offtrack")
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Sink
	end
end
function VRNavigation:OnHeartbeat(dt)
	local newMoveVector = self.moveVector
	local humanoid = self:GetLocalHumanoid()
	if not humanoid or not humanoid.Torso then
		return
	end
	if self.moving and self.currentPoints then
		local currentPosition = humanoid.Torso.Position
		local goalPosition = currentPoints[1]
		local vectorToGoal = (goalPosition - currentPosition) * XZ_VECTOR3
		local moveDist = vectorToGoal.magnitude
		local moveDir = vectorToGoal / moveDist
		if moveDist < POINT_REACHED_THRESHOLD then
			local estimatedTimeRemaining = 0
			local prevPoint = currentPoints[1]
			for i, point in pairs(currentPoints) do
				if i ~= 1 then
					local dist = (point - prevPoint).magnitude
					prevPoint = point
					estimatedTimeRemaining = estimatedTimeRemaining + dist / humanoid.WalkSpeed
				end
			end
			table.remove(currentPoints, 1)
			currentPointIdx = currentPointIdx + 1
			if #currentPoints == 0 then
				self:StopFollowingPath()
				if PathDisplay then
					PathDisplay.clearRenderedPath()
				end
				return
			else
				if PathDisplay then
					PathDisplay.setCurrentPoints(currentPoints)
					PathDisplay.renderPath()
				end
				local newGoal = currentPoints[1]
				local distanceToGoal = (newGoal - currentPosition).magnitude
				expectedTimeToNextPoint = distanceToGoal / humanoid.WalkSpeed
				timeReachedLastPoint = tick()
			end
		else
			local ignoreTable = {
				game.Players.LocalPlayer.Character,
				workspace.CurrentCamera
			}
			local obstructRay = Ray.new(currentPosition - Vector3.new(0, 1, 0), moveDir * 3)
			local obstructPart, obstructPoint, obstructNormal = workspace:FindPartOnRayWithIgnoreList(obstructRay, ignoreTable)
			if obstructPart then
				local heightOffset = Vector3.new(0, 100, 0)
				local jumpCheckRay = Ray.new(obstructPoint + moveDir * 0.5 + heightOffset, -heightOffset)
				local jumpCheckPart, jumpCheckPoint, jumpCheckNormal = workspace:FindPartOnRayWithIgnoreList(jumpCheckRay, ignoreTable)
				local heightDifference = jumpCheckPoint.Y - currentPosition.Y
				if heightDifference < 6 and heightDifference > -2 then
					humanoid.Jump = true
				end
			end
			local timeSinceLastPoint = tick() - timeReachedLastPoint
			if timeSinceLastPoint > expectedTimeToNextPoint + OFFTRACK_TIME_THRESHOLD then
				self:StopFollowingPath()
				if PathDisplay then
					PathDisplay.clearRenderedPath()
				end
				movementUpdateEvent:Fire("offtrack")
			end
			newMoveVector = self.moveVector:Lerp(moveDir, dt * 10)
		end
	end
	if IsFiniteVector3(newMoveVector) then
		self.moveVector = newMoveVector
	end
end
function VRNavigation:OnUserCFrameEnabled()
	if self:ShouldUseNavigationLaser() then
		self:BindJumpAction(false)
		self:SetLaserPointerMode("Navigation")
	else
		self:BindJumpAction(true)
		self:SetLaserPointerMode("Hidden")
	end
end
function VRNavigation:Enable(enable)
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		self.navigationRequestedConn = VRService.NavigationRequested:Connect(function(destinationCFrame, inputUserCFrame)
			self:OnNavigationRequest(destinationCFrame, inputUserCFrame)
		end)
		self.heartbeatConn = RunService.Heartbeat:Connect(function(dt)
			self:OnHeartbeat(dt)
		end)
		if FFlagPlayerScriptsBindAtPriority2 then
			ContextActionService:BindAction("MoveThumbstick", function(actionName, inputState, inputObject)
				return self:ControlCharacterGamepad(actionName, inputState, inputObject)
			end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
		else
			ContextActionService:BindAction("MoveThumbstick", function(actionName, inputState, inputObject)
				self:ControlCharacterGamepad(actionName, inputState, inputObject)
			end, false, Enum.KeyCode.Thumbstick1)
		end
		ContextActionService:BindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)
		self.userCFrameEnabledConn = VRService.UserCFrameEnabled:Connect(function()
			self:OnUserCFrameEnabled()
		end)
		self:OnUserCFrameEnabled()
		VRService:SetTouchpadMode(Enum.VRTouchpad.Left, Enum.VRTouchpadMode.VirtualThumbstick)
		VRService:SetTouchpadMode(Enum.VRTouchpad.Right, Enum.VRTouchpadMode.ABXY)
		self.enabled = true
	else
		self:StopFollowingPath()
		ContextActionService:UnbindAction("MoveThumbstick")
		ContextActionService:UnbindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)
		self:BindJumpAction(false)
		self:SetLaserPointerMode("Disabled")
		if self.navigationRequestedConn then
			self.navigationRequestedConn:Disconnect()
			self.navigationRequestedConn = nil
		end
		if self.heartbeatConn then
			self.heartbeatConn:Disconnect()
			self.heartbeatConn = nil
		end
		if self.userCFrameEnabledConn then
			self.userCFrameEnabledConn:Disconnect()
			self.userCFrameEnabledConn = nil
		end
		self.enabled = false
	end
end
return VRNavigation
]]></ProtectedString><string name="Name">VRNavigation</string></Properties></Item><Item class="ModuleScript" referent="RBX375"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local NONE = Enum.UserInputType.None
local thumbstickDeadzone = 0.2
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local Gamepad = setmetatable({}, BaseCharacterController)
Gamepad.__index = Gamepad
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
function Gamepad.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new(), Gamepad)
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.activeGamepad = NONE
	self.gamepadConnectedConn = nil
	self.gamepadDisconnectedConn = nil
	return self
end
function Gamepad:Enable(enable)
	if not UserInputService.GamepadEnabled then
		return false
	end
	if enable == self.enabled then
		return true
	end
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		self.activeGamepad = self:GetHighestPriorityGamepad()
		if self.activeGamepad ~= NONE then
			self:BindContextActions()
			self:ConnectGamepadConnectionListeners()
		else
			return false
		end
	else
		self:UnbindContextActions()
		self:DisconnectGamepadConnectionListeners()
		self.activeGamepad = NONE
	end
	self.enabled = enable
	return true
end
function Gamepad:GetHighestPriorityGamepad()
	local connectedGamepads = UserInputService:GetConnectedGamepads()
	local bestGamepad = NONE
	for _, gamepad in pairs(connectedGamepads) do
		if gamepad.Value < bestGamepad.Value then
			bestGamepad = gamepad
		end
	end
	return bestGamepad
end
function Gamepad:BindContextActions()
	if self.activeGamepad == NONE then
		return false
	end
	local function updateMovement(inputState)
		if inputState == Enum.UserInputState.Cancel then
			self.moveVector = ZERO_VECTOR3
		else
			self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		end
	end
	local function handleMoveForward(actionName, inputState, inputObject)
		self.forwardValue = inputState == Enum.UserInputState.Begin and -1 or 0
		updateMovement(inputState)
	end
	local function handleMoveBackward(actionName, inputState, inputObject)
		self.backwardValue = inputState == Enum.UserInputState.Begin and 1 or 0
		updateMovement(inputState)
	end
	local function handleMoveLeft(actionName, inputState, inputObject)
		self.leftValue = inputState == Enum.UserInputState.Begin and -1 or 0
		updateMovement(inputState)
	end
	local function handleMoveRight(actionName, inputState, inputObject)
		self.rightValue = inputState == Enum.UserInputState.Begin and 1 or 0
		updateMovement(inputState)
	end
	local function handleJumpAction(actionName, inputState, inputObject)
		self.isJumping = inputState == Enum.UserInputState.Begin
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	local function handleThumbstickInput(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.Cancel then
			self.moveVector = ZERO_VECTOR3
			return FFlagPlayerScriptsBindAtPriority2 and Enum.ContextActionResult.Sink or nil
		end
		if self.activeGamepad ~= inputObject.UserInputType then
			return FFlagPlayerScriptsBindAtPriority2 and Enum.ContextActionResult.Pass or nil
		end
		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then
			return
		end
		if inputObject.Position.magnitude > thumbstickDeadzone then
			self.moveVector = Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
		else
			self.moveVector = ZERO_VECTOR3
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	if FFlagPlayerScriptsBindAtPriority2 then
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
		ContextActionService:BindActionAtPriority("moveThumbstick", handleThumbstickInput, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
	else
		ContextActionService:BindAction("jumpAction", handleJumpAction, false, Enum.KeyCode.ButtonA)
		ContextActionService:BindAction("moveThumbstick", handleThumbstickInput, false, Enum.KeyCode.Thumbstick1)
	end
	return true
end
function Gamepad:UnbindContextActions()
	if self.activeGamepad ~= NONE then
		ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
	ContextActionService:UnbindAction("moveThumbstick")
	ContextActionService:UnbindAction("jumpAction")
end
function Gamepad:OnNewGamepadConnected()
	local bestGamepad = self:GetHighestPriorityGamepad()
	if bestGamepad == self.activeGamepad then
		return
	end
	if bestGamepad == NONE then
		warn("Gamepad:OnNewGamepadConnected found no connected gamepads")
		self:UnbindContextActions()
		return
	end
	if self.activeGamepad ~= NONE then
		self:UnbindContextActions()
	end
	self.activeGamepad = bestGamepad
	self:BindContextActions()
end
function Gamepad:OnCurrentGamepadDisconnected()
	if self.activeGamepad ~= NONE then
		ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
	local bestGamepad = self:GetHighestPriorityGamepad()
	if self.activeGamepad ~= NONE and bestGamepad == self.activeGamepad then
		warn("Gamepad:OnCurrentGamepadDisconnected found the supposedly disconnected gamepad in connectedGamepads.")
		self:UnbindContextActions()
		self.activeGamepad = NONE
		return
	end
	if bestGamepad == NONE then
		self:UnbindContextActions()
		self.activeGamepad = NONE
	else
		self.activeGamepad = bestGamepad
		ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
end
function Gamepad:ConnectGamepadConnectionListeners()
	self.gamepadConnectedConn = UserInputService.GamepadConnected:Connect(function(gamepadEnum)
		self:OnNewGamepadConnected()
	end)
	self.gamepadDisconnectedConn = UserInputService.GamepadDisconnected:Connect(function(gamepadEnum)
		if self.activeGamepad == gamepadEnum then
			self:OnCurrentGamepadDisconnected()
		end
	end)
end
function Gamepad:DisconnectGamepadConnectionListeners()
	if self.gamepadConnectedConn then
		self.gamepadConnectedConn:Disconnect()
		self.gamepadConnectedConn = nil
	end
	if self.gamepadDisconnectedConn then
		self.gamepadDisconnectedConn:Disconnect()
		self.gamepadDisconnectedConn = nil
	end
end
return Gamepad
]]></ProtectedString><string name="Name">Gamepad</string></Properties></Item><Item class="ModuleScript" referent="RBX380"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UserInputService = game:GetService("UserInputService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Play TaggedInstanceAddedConnection then
		TaggedInstanceAddedConnection:Disconnect()
		TaggedInstanceAddedConnection = nil
	end
	if TaggedInstanceRemovedConnection then
		TaggedInstanceRemovedConnection:Disconnect()
		TaggedInstanceRemovedConnection = nil
	end
	CurrentIgnoreTag = newIgnoreTag
	CurrentIgnoreList = {
		GetCharacter()
	}
	if CurrentIgnoreTag ~= nil then
		local ignoreParts = CollectionService:GetTagged(CurrentIgnoreTag)
		for _, ignorePart in ipairs(ignoreParts) do
			table.insert(CurrentIgnoreList, ignorePart)
		end
		TaggedInstanceAddedConnection = CollectionService:GetInstanceAddedSignal(CurrentIgnoreTag):Connect(function(ignorePart)
			table.insert(CurrentIgnoreList, ignorePart)
		end)
		TaggedInstanceRemovedConnection = CollectionService:GetInstanceRemovedSignal(CurrentIgnoreTag):Connect(function(ignorePart)
			for i = 1, #CurrentIgnoreList do
				if CurrentIgnoreList[i] == ignorePart then
					CurrentIgnoreList[i] = CurrentIgnoreList[#CurrentIgnoreList]
					table.remove(CurrentIgnoreList)
					break
				end
			end
		end)
	end
end
local function getIgnoreList()
	if CurrentIgnoreList then
		return CurrentIgnoreList
	end
	CurrentIgnoreList = {}
	table.insert(CurrentIgnoreList, GetCharacter())
	return CurrentIgnoreList
end
local popupAdornee
local function getPopupAdorneePart()
	if popupAdornee and not popupAdornee.Parent then
		popupAdornee = nil
	end
	if not popupAdornee then
		popupAdornee = Instance.new("Part")
		popupAdornee.Name = "ClickToMovePopupAdornee"
		popupAdornee.Transparency = 1
		popupAdornee.CanCollide = false
		popupAdornee.Anchored = true
		popupAdornee.Size = Vector3.new(2, 2, 2)
		popupAdornee.CFrame = CFrame.new()
		popupAdornee.Parent = Workspace.CurrentCamera
	end
	return popupAdornee
end
local activePopups = {}
local function createNewPopup(popupType)
	local newModel = Instance.new("ImageHandleAdornment")
	newModel.AlwaysOnTop = false
	newModel.Transparency = 1
	newModel.Size = ZERO_VECTOR2
	newModel.SizeRelativeOffset = ZERO_VECTOR3
	newModel.Image = "rbxasset://textures/ui/move.png"
	newModel.ZIndex = 20
	local radius = 0
	if popupType == "DestinationPopup" then
		newModel.Color3 = Color3.fromRGB(0, 175, 255)
		radius = 1.25
	elseif popupType == "DirectWalkPopup" then
		newModel.Color3 = Color3.fromRGB(0, 175, 255)
		radius = 1.25
	elseif popupType == "FailurePopup" then
		newModel.Color3 = Color3.fromRGB(255, 100, 100)
		radius = 1.25
	elseif popupType == "PatherPopup" then
		newModel.Color3 = Color3.fromRGB(255, 255, 255)
		radius = 1
		newModel.ZIndex = 10
	end
	newModel.Size = Vector2.new(5, 0.1) * radius
	local dataStructure = {}
	dataStructure.Model = newModel
	activePopups[#activePopups + 1] = newModel
	function dataStructure:TweenIn()
		local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out)
		local tween1 = TweenService:Create(newModel, tweenInfo, {
			Size = Vector2.new(2, 2) * radius
		})
		tween1:Play()
		TweenService:Create(newModel, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, 0.1), {
			Transparency = 0,
			SizeRelativeOffset = Vector3.new(0, radius * 1.5, 0)
		}):Play()
		return tween1
	end
	function dataStructure:TweenOut()
		local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
		local tween1 = TweenService:Create(newModel, tweenInfo, {Size = ZERO_VECTOR2})
		tween1:Play()
		coroutine.wrap(function()
			tween1.Completed:Wait()
			for i = 1, #activePopups do
				if activePopups[i] == newModel then
					table.remove(activePopups, i)
					break
				end
			end
		end)()
		return tween1
	end
	function dataStructure:Place(position)
		if not self.Model.Parent then
			local popupAdorneePart = getPopupAdorneePart()
			self.Model.Parent = popupAdorneePart
			self.Model.Adornee = popupAdorneePart
			local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
			local _, hitPoint = Workspace:FindPartOnRayWithIgnoreList(ray, {
				Workspace.CurrentCamera,
				Player.Character
			})
			self.Model.CFrame = CFrame.new(hitPoint) + Vector3.new(0, -radius, 0)
		end
	end
	return dataStructure
end
local function createPopupPath(points, numCircles)
	local popups = {}
	local stopTraversing = false
	local function killPopup(i)
		for iter, v in pairs(popups) do
			if iter <= i then
				do
					local tween = v:TweenOut()
					coroutine.wrap(function()
						tween.Completed:Wait()
						v.Model:Destroy()
					end)()
					popups[iter] = nil
				end
			end
		end
	end
	local function stopFunction()
		stopTraversing = true
		killPopup(#points)
	end
	coroutine.wrap(function()
		for i = 1, #points do
			if stopTraversing then
				break
			end
			local includeWaypoint = i % numCircles == 0 and i < #points and (points[#points].Position - points[i].Position).magnitude > 4
			if includeWaypoint then
				local popup = createNewPopup("PatherPopup")
				popups[i] = popup
				popup:Place(points[i].Position)
				popup:TweenIn()
				wait(0.2)
			end
		end
	end)()
	return stopFunction, killPopup
end
local function Pather(character, endPoint, surfaceNormal)
	local this = {}
	this.Cancelled = false
	this.Started = false
	this.Finished = Instance.new("BindableEvent")
	this.PathFailed = Instance.new("BindableEvent")
	this.PathComputing = false
	this.PathComputed = false
	this.OriginalPoint = endPoint
	this.TargetPoint = endPoint
	this.TargetSurfaceNormal = surfaceNormal
	this.DiedConn = nil
	this.SeatedConn = nil
	this.MoveToConn = nil
	this.BlockedConn = nil
	this.CurrentPoint = 0
	function this:Cleanup()
		if this.stopTraverseFunc then
			this.stopTraverseFunc()
			this.stopTraverseFunc = nil
		end
		if this.MoveToConn then
			this.MoveToConn:Disconnect()
			this.MoveToConn = nil
		end
		if this.BlockedConn then
			this.BlockedConn:Disconnect()
			this.BlockedConn = nil
		end
		if this.DiedConn then
			this.DiedConn:Disconnect()
			this.DiedConn = nil
		end
		if this.SeatedConn then
			this.SeatedConn:Disconnect()
			this.SeatedConn = nil
		end
		this.humanoid = nil
	end
	function this:Cancel()
		this.Cancelled = true
		this:Cleanup()
	end
	function this:IsActive()
		return this.humanoid and this.Started and not this.Cancelled
	end
	function this:OnPathInterrupted()
		this.Cancelled = true
		this:OnPointReached(false)
	end
	function this:ComputePath()
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if torso then
			if this.PathComputed or this.PathComputing then
				return
			end
			this.PathComputing = true
			pcall(function()
				this.pathResult = PathfindingService:FindPathAsync(torso.CFrame.p, this.TargetPoint)
			end)
			this.pointList = this.pathResult and this.pathResult:GetWaypoints()
			if this.pathResult then
				this.BlockedConn = this.pathResult.Blocked:Connect(function(blockedIdx)
					this:OnPathBlocked(blockedIdx)
				end)
			end
			this.PathComputing = false
			this.PathComputed = this.pathResult and this.pathResult.Status == Enum.PathStatus.Success or false
		end
		return true
	end
	function this:IsValidPath()
		if not this.pathResult then
			this:ComputePath()
		end
		return this.pathResult.Status == Enum.PathStatus.Success
	end
	this.Recomputing = false
	function this:OnPathBlocked(blockedWaypointIdx)
		local pathBlocked = blockedWaypointIdx >= this.CurrentPoint
		if not pathBlocked or this.Recomputing then
			return
		end
		this.Recomputing = true
		if this.stopTraverseFunc then
			this.stopTraverseFunc()
			this.stopTraverseFunc = nil
		end
		this.pathResult:ComputeAsync(this.humanoid.Torso.CFrame.p, this.TargetPoint)
		this.pointList = this.pathResult:GetWaypoints()
		this.PathComputed = this.pathResult and this.pathResult.Status == Enum.PathStatus.Success or false
		if ShowPath then
			if FFlagUserNewClickToMoveDisplay then
				this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList)
			else
				this.stopTraverseFunc, this.setPointFunc = createPopupPath(this.pointList, 4, true)
			end
		end
		if this.PathComputed then
			this.humanoid = findPlayerHumanoid(Player)
			this.CurrentPoint = 1
			this:OnPointReached(true)
		else
			this.PathFailed:Fire()
			this:Cleanup()
		end
		this.Recomputing = false
	end
	function this:OnPointReached(reached)
		if reached and not this.Cancelled then
			local nextWaypointIdx = this.CurrentPoint + 1
			if nextWaypointIdx > #this.pointList then
				if this.stopTraverseFunc then
					this.stopTraverseFunc()
				end
				this.Finished:Fire()
				this:Cleanup()
			else
				local currentWaypoint = this.pointList[this.CurrentPoint]
				local nextWaypoint = this.pointList[nextWaypointIdx]
				local currentState = this.humanoid:GetState()
				local isInAir = currentState == Enum.HumanoidStateType.FallingDown or currentState == Enum.HumanoidStateType.Freefall or currentState == Enum.HumanoidStateType.Jumping
				if isInAir then
					local shouldWaitForGround = nextWaypoint.Action == Enum.PathWaypointAction.Jump
					shouldWaitForGround = shouldWaitForGround
					if shouldWaitForGround then
						this.humanoid.FreeFalling:Wait()
						wait(0.1)
					end
				end
				if FFlagUserNavigationClickToMoveSkipPassedWaypoints then
					local nextWaypointAlreadyReached
					local planeNormal = currentWaypoint.Position - nextWaypoint.Position
					if planeNormal.Magnitude > 1.0E-6 then
						planeNormal = planeNormal.Unit
						local planeDistance = planeNormal:Dot(nextWaypoint.Position)
						local humanoidPosition = this.humanoid.RootPart.Position - Vector3.new(0, 0.5 * this.humanoid.RootPart.Size.y + this.humanoid.HipHeight, 0)
						local dist = planeNormal:Dot(humanoidPosition) - planeDistance
						nextWaypointAlreadyReached = dist < 1
					else
						nextWaypointAlreadyReached = true
					end
					if this.setPointFunc then
						this.setPointFunc(nextWaypointIdx)
					end
					this.CurrentPoint = nextWaypointIdx
					if nextWaypointAlreadyReached then
						this:OnPointReached(true)
					else
						if nextWaypoint.Action == Enum.PathWaypointAction.Jump then
							this.humanoid.Jump = true
						end
						this.humanoid:MoveTo(nextWaypoint.Position)
					end
				else
					if this.setPointFunc then
						this.setPointFunc(nextWaypointIdx)
					end
					if nextWaypoint.Action == Enum.PathWaypointAction.Jump then
						this.humanoid.Jump = true
					end
					this.humanoid:MoveTo(nextWaypoint.Position)
					this.CurrentPoint = nextWaypointIdx
				end
			end
		else
			this.PathFailed:Fire()
			this:Cleanup()
		end
	end
	function this:Start(overrideShowPath)
		if CurrentSeatPart then
			return
		end
		this.humanoid = findPlayerHumanoid(Player)
		if not this.humanoid then
			this.PathFailed:Fire()
			return
		end
		if this.Started then
			return
		end
		this.Started = true
		if FFlagUserNewClickToMoveDisplay then
			ClickToMoveDisplay.CancelFailureAnimation()
		end
		if ShowPath then
			if FFlagUserNewClickToMoveDisplay then
				if overrideShowPath == nil or overrideShowPath then
					this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList, this.OriginalPoint)
				end
			else
				this.stopTraverseFunc, this.setPointFunc = createPopupPath(this.pointList, 4)
			end
		end
		if #this.pointList > 0 then
			this.SeatedConn = this.humanoid.Seated:Connect(function(reached)
				this:OnPathInterrupted()
			end)
			this.DiedConn = this.humanoid.Died:Connect(function(reached)
				this:OnPathInterrupted()
			end)
			this.MoveToConn = this.humanoid.MoveToFinished:Connect(function(reached)
				this:OnPointReached(reached)
			end)
			this.CurrentPoint = 1
			this:OnPointReached(true)
		else
			this.PathFailed:Fire()
			if this.stopTraverseFunc then
				this.stopTraverseFunc()
			end
		end
	end
	if FFlagUserNewClickToMoveDisplay then
		local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal * 1.5
		local ray = Ray.new(offsetPoint, Vector3.new(0, -1, 0) * 50)
		local newHitPart, newHitPos = Workspace:FindPartOnRayWithIgnoreList(ray, getIgnoreList())
		if newHitPart then
			this.TargetPoint = newHitPos
		end
		this:ComputePath()
	else
		this:ComputePath()
		if not this.PathComputed then
			local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal * 1.5
			local ray = Ray.new(offsetPoint, Vector3.new(0, -1, 0) * 50)
			local newHitPart, newHitPos = Workspace:FindPartOnRayWithIgnoreList(ray, getIgnoreList())
			if newHitPart then
				this.TargetPoint = newHitPos
			end
			this:ComputePath()
		end
	end
	return this
end
local function CheckAlive()
	local humanoid = findPlayerHumanoid(Player)
	return humanoid ~= nil and humanoid.Health > 0
end
local GetEquippedTool = function(character)
	if character ~= nil then
		for _, child in pairs(character:GetChildren()) do
			if child:IsA("Tool") then
				return child
			end
		end
	end
end
local ExistingPather, ExistingIndicator, PathCompleteListener, PathFailedListener
local function CleanupPath()
	DrivingTo = nil
	if ExistingPather then
		ExistingPather:Cancel()
	end
	if PathCompleteListener then
		PathCompleteListener:Disconnect()
		PathCompleteListener = nil
	end
	if PathFailedListener then
		PathFailedListener:Disconnect()
		PathFailedListener = nil
	end
	if ExistingIndicator then
		if FFlagUserNewClickToMoveDisplay then
			ExistingIndicator:Destroy()
		else
			do
				local obj = ExistingIndicator
				local tween = obj:TweenOut()
				local tweenCompleteEvent
				tweenCompleteEvent = tween.Completed:connect(function()
					tweenCompleteEvent:Disconnect()
					obj.Model:Destroy()
				end)
				ExistingIndicator = nil
			end
		end
	end
end
local getExtentsSize = function(Parts)
	local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge
	local minX, minY, minZ = math.huge, math.huge, math.huge
	for i = 1, #Parts do
		local position = Parts[i].Position
		maxX = math.max(maxX, position.X)
		maxY = math.max(maxY, position.Y)
		maxZ = math.max(maxZ, position.Z)
		minX = math.min(minX, position.X)
		minY = math.min(minY, position.Y)
		minZ = math.min(minZ, position.Z)
	end
	return Region3.new(Vector3.new(minX, minY, minZ), Vector3.new(maxX, maxY, maxZ))
end
local inExtents = function(Extents, Position)
	if Position.X < Extents.CFrame.p.X - Extents.Size.X / 2 or Position.X > Extents.CFrame.p.X + Extents.Size.X / 2 then
		return false
	end
	if Position.Z < Extents.CFrame.p.Z - Extents.Size.Z / 2 or Position.Z > Extents.CFrame.p.Z + Extents.Size.Z / 2 then
		return false
	end
	return true
end
local function showQuickPopupAsync(position, popupType)
	local popup = createNewPopup(popupType)
	popup:Place(position)
	local tweenIn = popup:TweenIn()
	tweenIn.Completed:Wait()
	local tweenOut = popup:TweenOut()
	tweenOut.Completed:Wait()
	popup.Model:Destroy()
end
local function HandleDirectMoveTo(hitPt, myHumanoid)
	if myHumanoid then
		if myHumanoid.Sit then
			myHumanoid.Jump = true
		end
		myHumanoid:MoveTo(hitPt)
	end
	local endWaypoint = ClickToMoveDisplay.CreateEndWaypoint(hitPt)
	ExistingIndicator = endWaypoint
	coroutine.wrap(function()
		myHumanoid.MoveToFinished:wait()
		endWaypoint:Destroy()
	end)
end
local OnTap
local function HandleDriveTo(tapPositions, hitPt, character)
	local destinationPopup
	if FFlagUserNewClickToMoveDisplay then
		destinationPopup = ClickToMoveDisplay.CreateEndWaypoint(hitPt)
	else
		destinationPopup = createNewPopup("DestinationPopup")
		ExistingIndicator = destinationPopup
		destinationPopup:Place(hitPt)
		destinationPopup:TweenIn()
	end
	DrivingTo = hitPt
	local ConnectedParts = CurrentSeatPart:GetConnectedParts(true)
	local heartBeatConnection
	heartBeatConnection = RunService.Heartbeat:Connect(function()
		if CurrentSeatPart and ExistingIndicator == destinationPopup then
			local ExtentsSize = getExtentsSize(ConnectedParts)
			if inExtents(ExtentsSize, hitPt) then
				if FFlagUserNewClickToMoveDisplay then
					destinationPopup:Destroy()
				else
					do
						local popup = destinationPopup
						coroutine.wrap(function()
							local tweenOut = popup:TweenOut()
							tweenOut.Completed:Wait()
							popup.Model:Destroy()
						end)()
					end
				end
				DrivingTo = nil
				heartBeatConnection:Disconnect()
			end
		else
			if CurrentSeatPart == nil and destinationPopup == ExistingIndicator then
				DrivingTo = nil
				OnTap(tapPositions, hitPt)
			end
			if FFlagUserNewClickToMoveDisplay then
				destinationPopup:Destroy()
			else
				do
					local popup = destinationPopup
					coroutine.wrap(function()
						local tweenOut = popup:TweenOut()
						tweenOut.Completed:Wait()
						popup.Model:Destroy()
					end)()
				end
			end
			heartBeatConnection:Disconnect()
		end
	end)
end
local function HandleMoveTo(thisPather, hitPt, hitChar, character, overrideShowPath)
	thisPather:Start(overrideShowPath)
	CleanupPath()
	local destinationPopup, failurePopup
	if not FFlagUserNewClickToMoveDisplay then
		destinationPopup = createNewPopup("DestinationPopup")
		destinationPopup:Place(hitPt, Vector3.new(0, hitPt.y, 0))
		failurePopup = createNewPopup("FailurePopup")
		destinationPopup:TweenIn()
		ExistingIndicator = destinationPopup
	end
	ExistingPather = thisPather
	PathCompleteListener = thisPather.Finished.Event:Connect(function()
		if destinationPopup then
			if ExistingIndicator == destinationPopup then
				ExistingIndicator = nil
			end
			do
				local tween = destinationPopup:TweenOut()
				local tweenCompleteEvent
				tweenCompleteEvent = tween.Completed:Connect(function()
					tweenCompleteEvent:Disconnect()
					destinationPopup.Model:Destroy()
					destinationPopup = nil
				end)
			end
		end
		if hitChar then
			local currentWeapon = GetEquippedTool(character)
			if currentWeapon then
				currentWeapon:Activate()
			end
		end
	end)
	PathFailedListener = thisPather.PathFailed.Event:Connect(function()
		CleanupPath()
		if FFlagUserNewClickToMoveDisplay then
			if overrideShowPath == nil or overrideShowPath then
				local shouldPlayFailureAnim = PlayFailureAnimation and (not ExistingPather or not ExistingPather:IsActive())
				if shouldPlayFailureAnim then
					ClickToMoveDisplay.PlayFailureAnimation()
				end
				ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
			end
		elseif failurePopup then
			failurePopup:Place(hitPt, Vector3.new(0, hitPt.y, 0))
			local failTweenIn = failurePopup:TweenIn()
			failTweenIn.Completed:Wait()
			local failTweenOut = failurePopup:TweenOut()
			failTweenOut.Completed:Wait()
			failurePopup.Model:Destroy()
			failurePopup = nil
		end
	end)
end
local function ShowPathFailedFeedback(hitPt)
	if ExistingPather and ExistingPather:IsActive() then
		ExistingPather:Cancel()
	end
	if PlayFailureAnimation then
		ClickToMoveDisplay.PlayFailureAnimation()
	end
	ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
end
function OnTap(tapPositions, goToPoint, wasTouchTap)
	local camera = Workspace.CurrentCamera
	local character = Player.Character
	if not CheckAlive() then
		return
	end
	if #tapPositions == 1 or goToPoint then
		if camera then
			local unitRay = camera:ScreenPointToRay(tapPositions[1].x, tapPositions[1].y)
			local ray = Ray.new(unitRay.Origin, unitRay.Direction * 1000)
			local myHumanoid = findPlayerHumanoid(Player)
			local hitPart, hitPt, hitNormal = Utility.Raycast(ray, true, getIgnoreList())
			local hitChar, hitHumanoid = Utility.FindCharacterAncestor(hitPart)
			if FFlagUserFixClickToMoveWithACM and wasTouchTap and hitHumanoid and StarterGui:GetCore("AvatarContextMenuEnabled") then
				local clickedPlayer = Players:GetPlayerFromCharacter(hitHumanoid.Parent)
				if clickedPlayer then
					CleanupPath()
					return
				end
			end
			if goToPoint then
				hitPt = goToPoint
				hitChar = nil
			end
			if UseDirectPath and hitPt and character and not CurrentSeatPart then
				HandleDirectMoveTo(hitPt, myHumanoid)
			elseif hitPt and character and not CurrentSeatPart then
				local thisPather = Pather(character, hitPt, hitNormal)
				if thisPather:IsValidPath() then
					HandleMoveTo(thisPather, hitPt, hitChar, character)
				elseif hitPt then
					if FFlagUserNewClickToMoveDisplay then
						ShowPathFailedFeedback(hitPt)
					else
						coroutine.wrap(showQuickPopupAsync)(hitPt, "FailurePopup")
					end
				end
			elseif hitPt and character and CurrentSeatPart then
				HandleDriveTo(tapPositions, hitPt, character)
			end
		end
	elseif #tapPositions >= 2 and camera then
		local currentWeapon = GetEquippedTool(character)
		if currentWeapon then
			currentWeapon:Activate()
		end
	end
end
local DisconnectEvent = function(event)
	if event then
		event:Disconnect()
	end
end
local KeyboardController = require(script.Parent:WaitForChild("Keyboard"))
local ClickToMove = setmetatable({}, KeyboardController)
ClickToMove.__index = ClickToMove
function ClickToMove.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(KeyboardController.new(CONTROL_ACTION_PRIORITY), ClickToMove)
	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	self.mouse1Down = tick()
	self.mouse1DownPos = Vector2.new()
	self.mouse2DownTime = tick()
	self.mouse2DownPos = Vector2.new()
	self.mouse2UpTime = tick()
	self.tapConn = nil
	self.inputBeganConn = nil
	self.inputChangedConn = nil
	self.inputEndedConn = nil
	self.humanoidDiedConn = nil
	self.characterChildAddedConn = nil
	self.onCharacterAddedConn = nil
	self.characterChildRemovedConn = nil
	self.renderSteppedConn = nil
	self.humanoidSeatedConn = nil
	self.running = false
	self.wasdEnabled = false
	return self
end
function ClickToMove:DisconnectEvents()
	DisconnectEvent(self.tapConn)
	DisconnectEvent(self.inputBeganConn)
	DisconnectEvent(self.inputChangedConn)
	DisconnectEvent(self.inputEndedConn)
	DisconnectEvent(self.humanoidDiedConn)
	DisconnectEvent(self.characterChildAddedConn)
	DisconnectEvent(self.onCharacterAddedConn)
	DisconnectEvent(self.renderSteppedConn)
	DisconnectEvent(self.characterChildRemovedConn)
	DisconnectEvent(self.humanoidSeatedConn)
	RunService:UnbindFromRenderStep("ClickToMoveRenderUpdate")
end
function ClickToMove:OnTouchBegan(input, processed)
	if self.fingerTouches[input] == nil and not processed then
		self.numUnsunkTouches = self.numUnsunkTouches + 1
	end
	self.fingerTouches[input] = processed
end
function ClickToMove:OnTouchChanged(input, processed)
	if self.fingerTouches[input] == nil then
		self.fingerTouches[input] = processed
		if not processed then
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
end
function ClickToMove:OnTouchEnded(input, processed)
	if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
		self.numUnsunkTouches = self.numUnsunkTouches - 1
	end
	self.fingerTouches[input] = nil
end
function ClickToMove:OnCharacterAdded(character)
	self:DisconnectEvents()
	self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchBegan(input, processed)
		end
		if processed == false and input.UserInputType == Enum.UserInputType.Keyboard and movementKeys[input.KeyCode] then
			CleanupPath()
		end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			self.mouse1DownTime = tick()
			self.mouse1DownPos = input.Position
		end
		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.mouse2DownTime = tick()
			self.mouse2DownPos = input.Position
		end
	end)
	self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchChanged(input, processed)
		end
	end)
	self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchEnded(input, processed)
		end
		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.mouse2UpTime = tick()
			local currPos = input.Position
			if self.mouse2UpTime - self.mouse2DownTime < 0.25 and (currPos - self.mouse2DownPos).magnitude < 5 and self.moveVector.Magnitude <= 0 then
				local positions = {currPos}
				OnTap(positions)
			end
		end
	end)
	self.tapConn = UserInputService.TouchTap:Connect(function(touchPositions, processed)
		if not processed then
			OnTap(touchPositions, nil, true)
		end
	end)
	local computeThrottle = function(dist)
		if dist > 0.2 then
			return 0.5 + dist ^ 2 / 2
		else
			return 0
		end
	end
	local kP = 1
	local kD = 0.5
	local function getThrottleAndSteer(object, point)
		local oCF = object.CFrame
		local relativePosition = oCF:pointToObjectSpace(point)
		local relativeZDirection = -relativePosition.z
		local relativeDistance = relativePosition.magnitude
		local throttle = computeThrottle(math.min(1, relativeDistance / 50)) * math.sign(relativeZDirection)
		local steerAngle = -math.atan2(-relativePosition.x, -relativePosition.z)
		local steer = steerAngle / (math.pi / 4)
		local pdSteer = kP * steer + kD * steer
		return throttle, pdSteer
	end
	local function Update()
		if CurrentSeatPart then
			if DrivingTo then
				local throttle, steer = getThrottleAndSteer(CurrentSeatPart, DrivingTo)
				CurrentSeatPart.ThrottleFloat = throttle
				CurrentSeatPart.SteerFloat = steer
			else
				CurrentSeatPart.ThrottleFloat = 0
				CurrentSeatPart.SteerFloat = 0
			end
		end
		local cameraPos = Workspace.CurrentCamera.CFrame.p
		for i = 1, #activePopups do
			local popup = activePopups[i]
			popup.CFrame = CFrame.new(popup.CFrame.p, cameraPos)
		end
	end
	RunService:BindToRenderStep("ClickToMoveRenderUpdate", Enum.RenderPriority.Camera.Value - 1, Update)
	local function onSeated(active, currentSeatPart)
		if active then
			if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
				CurrentSeatPart = currentSeatPart
			end
		else
			CurrentSeatPart = nil
		end
	end
	local function OnCharacterChildAdded(child)
		if UserInputService.TouchEnabled and child:IsA("Tool") then
			child.ManualActivationOnly = true
		end
		if child:IsA("Humanoid") then
			DisconnectEvent(self.humanoidDiedConn)
			self.humanoidDiedConn = child.Died:Connect(function()
				if ExistingIndicator then
					DebrisService:AddItem(ExistingIndicator.Model, 1)
				end
			end)
			if FFlagUserNewClickToMoveDisplay then
			end
		end
	end
	self.characterChildAddedConn = character.ChildAdded:Connect(function(child)
		OnCharacterChildAdded(child)
	end)
	self.characterChildRemovedConn = character.ChildRemoved:Connect(function(child)
		if UserInputService.TouchEnabled and child:IsA("Tool") then
			child.ManualActivationOnly = false
		end
	end)
	for _, child in pairs(character:GetChildren()) do
		OnCharacterChildAdded(child)
	end
end
function ClickToMove:Start()
	self:Enable(true)
end
function ClickToMove:Stop()
	self:Enable(false)
end
function ClickToMove:Enable(enable, enableWASD, touchJumpController)
	if enable then
		if not self.running then
			if Player.Character then
				self:OnCharacterAdded(Player.Character)
			end
			self.onCharacterAddedConn = Player.CharacterAdded:Connect(function(char)
				self:OnCharacterAdded(char)
			end)
			self.running = true
		end
		self.touchJumpController = touchJumpController
		if self.touchJumpController then
			self.touchJumpController:Enable(self.jumpEnabled)
		end
	else
		if self.running then
			self:DisconnectEvents()
			CleanupPath()
			if UserInputService.TouchEnabled then
				local character = Player.Character
				if character then
					for _, child in pairs(character:GetChildren()) do
						if child:IsA("Tool") then
							child.ManualActivationOnly = false
						end
					end
				end
			end
			DrivingTo = nil
			self.running = false
		end
		if self.touchJumpController and not self.jumpEnabled then
			self.touchJumpController:Enable(true)
		end
		self.touchJumpController = nil
	end
	if UserInputService.KeyboardEnabled and enable ~= self.enabled then
		self.forwardValue = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.moveVector = ZERO_VECTOR3
		if enable then
			self:BindContextActions()
			self:ConnectFocusEventListeners()
		else
			self:UnbindContextActions()
			self:DisconnectFocusEventListeners()
		end
	end
	self.wasdEnabled = enable and enableWASD or false
	self.enabled = enable
end
function ClickToMove:UpdateMovement(inputState)
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector = ZERO_VECTOR3
	elseif self.wasdEnabled then
		self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		if FFlagUserNewClickToMoveDisplay and 0 < self.moveVector.magnitude then
			CleanupPath()
			ClickToMoveDisplay.CancelFailureAnimation()
		end
	end
end
function ClickToMove:SetShowPath(value)
	ShowPath = value
end
function ClickToMove:GetShowPath()
	return ShowPath
end
function ClickToMove:SetWaypointTexture(texture)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetWaypointTexture(texture)
	end
end
function ClickToMove:GetWaypointTexture()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetWaypointTexture()
	end
	return ""
end
function ClickToMove:SetWaypointRadius(radius)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetWaypointRadius(radius)
	end
end
function ClickToMove:GetWaypointRadius()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetWaypointRadius()
	end
	return 0
end
function ClickToMove:SetEndWaypointTexture(texture)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetEndWaypointTexture(texture)
	end
end
function ClickToMove:GetEndWaypointTexture()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetEndWaypointTexture()
	end
	return ""
end
function ClickToMove:SetWaypointsAlwaysOnTop(alwaysOnTop)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
	end
end
function ClickToMove:GetWaypointsAlwaysOnTop()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
	end
	return false
end
function ClickToMove:SetFailureAnimationEnabled(enabled)
	PlayFailureAnimation = enabled
end
function ClickToMove:GetFailureAnimationEnabled()
	return PlayFailureAnimation
end
function ClickToMove:SetIgnoredPartsTag(tag)
	UpdateIgnoreTag(tag)
end
function ClickToMove:GetIgnoredPartsTag()
	return CurrentIgnoreTag
end
function ClickToMove:SetUseDirectPath(directPath)
	UseDirectPath = directPath
end
function ClickToMove:GetUseDirectPath()
	return UseDirectPath
end
function ClickToMove:SetUserJumpEnabled(jumpEnabled)
	self.jumpEnabled = jumpEnabled
	if self.touchJumpController then
		self.touchJumpController:Enable(jumpEnabled)
	end
end
function ClickToMove:GetUserJumpEnabled()
	return self.jumpEnabled
end
function ClickToMove:MoveTo(position, showPath)
	local character = Player.Character
	if character == nil then
		return false
	end
	local thisPather = Pather(character, position, Vector3.new(0, 1, 0))
	if thisPather:IsValidPath() then
		HandleMoveTo(thisPather, position, nil, character, showPath)
		return true
	end
	return false
end
return ClickToMove
]]></ProtectedString><string name="Name">ClickToMoveController</string></Properties></Item><Item class="ModuleScript" referent="RBX385"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchThumbstick = setmetatable({}, BaseCharacterController)
TouchThumbstick.__index = TouchThumbstick
function TouchThumbstick.new()
	local self = setmetatable(BaseCharacterController.new(), TouchThumbstick)
	self.isFollowStick = false
	self.thumbstickFrame = nil
	self.moveTouchObject = nil
	self.onTouchMovedConn = nil
	self.onTouchEndedConn = nil
	self.screenPos = nil
	self.stickImage = nil
	self.thumbstickSize = nil
	return self
end
function TouchThumbstick:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		if not self.thumbstickFrame then
			self:Create(uiParentFrame)
		end
		self.thumbstickFrame.Visible = true
	else
		self.thumbstickFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end
function TouchThumbstick:OnInputEnded()
	self.thumbstickFrame.Position = self.screenPos
	self.stickImage.Position = UDim2.new(0, self.thumbstickFrame.Size.X.Offset / 2 - self.thumbstickSize / 4, 0, self.thumbstickFrame.Size.Y.Offset / 2 - self.thumbstickSize / 4)
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	self.thumbstickFrame.Position = self.screenPos
	self.moveTouchObject = nil
end
function TouchThumbstick:Create(parentFrame)
	if self.thumbstickFrame then
		self.thumbstickFrame:Destroy()
		self.thumbstickFrame = nil
		if self.onTouchMovedConn then
			self.onTouchMovedConn:Disconnect()
			self.onTouchMovedConn = nil
		end
		if self.onTouchEndedConn then
			self.onTouchEndedConn:Disconnect()
			self.onTouchEndedConn = nil
		end
	end
	local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	self.thumbstickSize = isSmallScreen and 70 or 120
	self.screenPos = isSmallScreen and UDim2.new(0, self.thumbstickSize / 2 - 10, 1, -self.thumbstickSize - 20) or UDim2.new(0, self.thumbstickSize / 2, 1, -self.thumbstickSize * 1.75)
	self.thumbstickFrame = Instance.new("Frame")
	self.thumbstickFrame.Name = "ThumbstickFrame"
	self.thumbstickFrame.Active = true
	self.thumbstickFrame.Visible = false
	self.thumbstickFrame.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
	self.thumbstickFrame.Position = self.screenPos
	self.thumbstickFrame.BackgroundTransparency = 1
	local outerImage = Instance.new("ImageLabel")
	outerImage.Name = "OuterImage"
	outerImage.Image = TOUCH_CONTROL_SHEET
	outerImage.ImageRectOffset = Vector2.new()
	outerImage.ImageRectSize = Vector2.new(220, 220)
	outerImage.BackgroundTransparency = 1
	outerImage.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
	outerImage.Position = UDim2.new(0, 0, 0, 0)
	outerImage.Parent = self.thumbstickFrame
	self.stickImage = Instance.new("ImageLabel")
	self.stickImage.Name = "StickImage"
	self.stickImage.Image = TOUCH_CONTROL_SHEET
	self.stickImage.ImageRectOffset = Vector2.new(220, 0)
	self.stickImage.ImageRectSize = Vector2.new(111, 111)
	self.stickImage.BackgroundTransparency = 1
	self.stickImage.Size = UDim2.new(0, self.thumbstickSize / 2, 0, self.thumbstickSize / 2)
	self.stickImage.Position = UDim2.new(0, self.thumbstickSize / 2 - self.thumbstickSize / 4, 0, self.thumbstickSize / 2 - self.thumbstickSize / 4)
	self.stickImage.ZIndex = 2
	self.stickImage.Parent = self.thumbstickFrame
	local centerPosition
	local deadZone = 0.05
	local function DoMove(direction)
		local currentMoveVector = direction / (self.thumbstickSize / 2)
		local inputAxisMagnitude = currentMoveVector.magnitude
		if inputAxisMagnitude < deadZone then
			currentMoveVector = Vector3.new()
		else
			currentMoveVector = currentMoveVector.unit * ((inputAxisMagnitude - deadZone) / (1 - deadZone))
			currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
		end
		self.moveVector = currentMoveVector
	end
	local function MoveStick(pos)
		local relativePosition = Vector2.new(pos.x - centerPosition.x, pos.y - centerPosition.y)
		local length = relativePosition.magnitude
		local maxLength = self.thumbstickFrame.AbsoluteSize.x / 2
		if self.isFollowStick and length > maxLength then
			local offset = relativePosition.unit * maxLength
			self.thumbstickFrame.Position = UDim2.new(0, pos.x - self.thumbstickFrame.AbsoluteSize.x / 2 - offset.x, 0, pos.y - self.thumbstickFrame.AbsoluteSize.y / 2 - offset.y)
		else
			length = math.min(length, maxLength)
			relativePosition = relativePosition.unit * length
		end
		self.stickImage.Position = UDim2.new(0, relativePosition.x + self.stickImage.AbsoluteSize.x / 2, 0, relativePosition.y + self.stickImage.AbsoluteSize.y / 2)
	end
	self.thumbstickFrame.InputBegan:Connect(function(inputObject)
		if self.moveTouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		self.moveTouchObject = inputObject
		self.thumbstickFrame.Position = UDim2.new(0, inputObject.Position.x - self.thumbstickFrame.Size.X.Offset / 2, 0, inputObject.Position.y - self.thumbstickFrame.Size.Y.Offset / 2)
		centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x / 2, self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y / 2)
		local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
	end)
	self.onTouchMovedConn = UserInputService.TouchMoved:Connect(function(inputObject, isProcessed)
		if inputObject == self.moveTouchObject then
			centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x / 2, self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y / 2)
			local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
			DoMove(direction)
			MoveStick(inputObject.Position)
		end
	end)
	self.onTouchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject, isProcessed)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	GuiService.MenuOpened:Connect(function()
		if self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	self.thumbstickFrame.Parent = parentFrame
end
return TouchThumbstick
]]></ProtectedString><string name="Name">TouchThumbstick</string></Properties></Item><Item class="ModuleScript" referent="RBX390"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local DPAD_SHEET = "rbxasset://textures/ui/DPadSheet.png"
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local COMPASS_DIR = {
	Vector3.new(1, 0, 0),
	Vector3.new(1, 0, 1).unit,
	Vector3.new(0, 0, 1),
	Vector3.new(-1, 0, 1).unit,
	Vector3.new(-1, 0, 0),
	Vector3.new(-1, 0, -1).unit,
	Vector3.new(0, 0, -1),
	Vector3.new(1, 0, -1).unit
}
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchDPad = setmetatable({}, BaseCharacterController)
TouchDPad.__index = TouchDPad
function TouchDPad.new()
	local self = setmetatable(BaseCharacterController.new(), TouchDPad)
	self.DPadFrame = nil
	self.touchObject = nil
	self.flBtn = nil
	self.frBtn = nil
	return self
end
local function CreateArrowLabel(name, position, size, rectOffset, rectSize, parent)
	local image = Instance.new("ImageLabel")
	image.Name = name
	image.Image = DPAD_SHEET
	image.ImageRectOffset = rectOffset
	image.ImageRectSize = rectSize
	image.BackgroundTransparency = 1
	image.Size = size
	image.Position = position
	image.Parent = parent
	return image
end
function TouchDPad:GetCenterPosition()
	return Vector2.new(self.DPadFrame.AbsolutePosition.x + self.DPadFrame.AbsoluteSize.x * 0.5, self.DPadFrame.AbsolutePosition.y + self.DPadFrame.AbsoluteSize.y * 0.5)
end
function TouchDPad:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		if not self.DPadFrame then
			self:Create(uiParentFrame)
		end
		self.DPadFrame.Visible = true
	else
		self.DPadFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end
function TouchDPad:GetIsJumping()
	local wasJumping = self.isJumping
	self.isJumping = false
	return wasJumping
end
function TouchDPad:OnInputEnded()
	self.touchObject = nil
	if self.flBtn then
		self.flBtn.Visible = false
	end
	if self.frBtn then
		self.frBtn.Visible = false
	end
	self.moveVector = ZERO_VECTOR3
end
function TouchDPad:Create(parentFrame)
	if self.DPadFrame then
		self.DPadFrame:Destroy()
		self.DPadFrame = nil
	end
	local position = UDim2.new(0, 10, 1, -230)
	self.DPadFrame = Instance.new("Frame")
	self.DPadFrame.Name = "DPadFrame"
	self.DPadFrame.Active = true
	self.DPadFrame.Visible = false
	self.DPadFrame.Size = UDim2.new(0, 192, 0, 192)
	self.DPadFrame.Position = position
	self.DPadFrame.BackgroundTransparency = 1
	local smArrowSize = UDim2.new(0, 23, 0, 23)
	local lgArrowSize = UDim2.new(0, 64, 0, 64)
	local smImgOffset = Vector2.new(46, 46)
	local lgImgOffset = Vector2.new(128, 128)
	local bBtn = CreateArrowLabel("BackButton", UDim2.new(0.5, -32, 1, -64), lgArrowSize, Vector2.new(0, 0), lgImgOffset, self.DPadFrame)
	local fBtn = CreateArrowLabel("ForwardButton", UDim2.new(0.5, -32, 0, 0), lgArrowSize, Vector2.new(0, 258), lgImgOffset, self.DPadFrame)
	local lBtn = CreateArrowLabel("LeftButton", UDim2.new(0, 0, 0.5, -32), lgArrowSize, Vector2.new(129, 129), lgImgOffset, self.DPadFrame)
	local rBtn = CreateArrowLabel("RightButton", UDim2.new(1, -64, 0.5, -32), lgArrowSize, Vector2.new(0, 129), lgImgOffset, self.DPadFrame)
	local jumpBtn = CreateArrowLabel("JumpButton", UDim2.new(0.5, -32, 0.5, -32), lgArrowSize, Vector2.new(129, 0), lgImgOffset, self.DPadFrame)
	self.flBtn = CreateArrowLabel("ForwardLeftButton", UDim2.new(0, 35, 0, 35), smArrowSize, Vector2.new(129, 258), smImgOffset, self.DPadFrame)
	self.frBtn = CreateArrowLabel("ForwardRightButton", UDim2.new(1, -55, 0, 35), smArrowSize, Vector2.new(176, 258), smImgOffset, self.DPadFrame)
	self.flBtn.Visible = false
	self.frBtn.Visible = false
	jumpBtn.InputBegan:Connect(function(inputObject)
		self.isJumping = true
	end)
	local function normalizeDirection(inputPosition)
		local jumpRadius = jumpBtn.AbsoluteSize.x * 0.5
		local centerPosition = self:GetCenterPosition()
		local direction = Vector2.new(inputPosition.x - centerPosition.x, inputPosition.y - centerPosition.y)
		if jumpRadius < direction.magnitude then
			local angle = math.atan2(direction.y, direction.x)
			local octant = math.floor(8 * angle / (2 * math.pi) + 8.5) % 8 + 1
			self.moveVector = COMPASS_DIR[octant]
		end
		if not self.flBtn.Visible and self.moveVector == COMPASS_DIR[7] then
			self.flBtn.Visible = true
			self.frBtn.Visible = true
		end
	end
	self.DPadFrame.InputBegan:Connect(function(inputObject)
		if self.touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		self.touchObject = inputObject
		normalizeDirection(self.touchObject.Position)
	end)
	self.DPadFrame.InputChanged:Connect(function(inputObject)
		if inputObject == self.touchObject then
			normalizeDirection(self.touchObject.Position)
			self.isJumping = false
		end
	end)
	self.DPadFrame.InputEnded:connect(function(inputObject)
		if inputObject == self.touchObject then
			self:OnInputEnded()
		end
	end)
	GuiService.MenuOpened:Connect(function()
		if self.touchObject then
			self:OnInputEnded()
		end
	end)
	self.DPadFrame.Parent = parentFrame
end
return TouchDPad
]]></ProtectedString><string name="Name">TouchDPad</string></Properties></Item><Item class="ModuleScript" referent="RBX395"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local TOUCH_CONTROLS_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
local DYNAMIC_THUMBSTICK_ACTION_NAME = "DynamicThumbstickAction"
local DYNAMIC_THUMBSTICK_ACTION_PRIORITY = Enum.ContextActionPriority.High.Value
local MIDDLE_TRANSPARENCIES = {
	0.10999999999999999,
	0.30000000000000004,
	0.4,
	0.5,
	0.6,
	0.7,
	0.75
}
local NUM_MIDDLE_IMAGES = #MIDDLE_TRANSPARENCIES
local FADE_IN_OUT_BACKGROUND = true
local FADE_IN_OUT_MAX_ALPHA = 0.35
local FADE_IN_OUT_HALF_DURATION_DEFAULT = 0.3
local FADE_IN_OUT_BALANCE_DEFAULT = 0.5
local ThumbstickFadeTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local thumbstickUseCASFlagSuccess, thumbstickUseCASFlagValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserDynamicThumbstickUseContextActionSevice")
end)
local FFlagDynamicThumbstickUseContextActionSevice = thumbstickUseCASFlagSuccess and thumbstickUseCASFlagValue
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local DynamicThumbstick = setmetatable({}, BaseCharacterController)
DynamicThumbstick.__index = DynamicThumbstick
function DynamicThumbstick.new()
	local self = setmetatable(BaseCharacterController.new(), DynamicThumbstick)
	self.humanoid = nil
	self.tools = {}
	self.toolEquipped = nil
	self.revertAutoJumpEnabledToFalse = false
	self.moveTouchObject = nil
	self.moveTouchFirstChanged = false
	self.moveTouchStartPosition = nil
	self.startImage = nil
	self.endImage = nil
	self.middleImages = {}
	self.startImageFadeTween = nil
	self.endImageFadeTween = nil
	self.middleImageFadeTweens = {}
	self.isFirstTouch = true
	self.isFollowStick = false
	self.thumbstickFrame = nil
	if not FFlagDynamicThumbstickUseContextActionSevice then
		self.onTouchMovedConn = nil
		self.onTouchEndedConn = nil
		self.onTouchActivateConn = nil
	end
	self.onRenderSteppedConn = nil
	self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
	self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
	self.hasFadedBackgroundInPortrait = false
	self.hasFadedBackgroundInLandscape = false
	self.tweenInAlphaStart = nil
	self.tweenOutAlphaStart = nil
	self.shouldRevertAutoJumpOnDisable = false
	return self
end
function DynamicThumbstick:GetIsJumping()
	local wasJumping = self.isJumping
	self.isJumping = false
	return wasJumping
end
function DynamicThumbstick:EnableAutoJump(enable)
	local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if enable then
			self.shouldRevertAutoJumpOnDisable = humanoid.AutoJumpEnabled == false and Players.LocalPlayer.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice
			humanoid.AutoJumpEnabled = true
		elseif self.shouldRevertAutoJumpOnDisable then
			humanoid.AutoJumpEnabled = false
		end
	end
end
function DynamicThumbstick:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	if enable then
		if not self.thumbstickFrame then
			self:Create(uiParentFrame)
		end
		if FFlagDynamicThumbstickUseContextActionSevice then
			self:BindContextActions()
		end
		if Players.LocalPlayer.Character then
			self:OnCharacterAdded(Players.LocalPlayer.Character)
		else
			Players.LocalPlayer.CharacterAdded:Connect(function(char)
				self:OnCharacterAdded(char)
			end)
		end
	else
		if FFlagDynamicThumbstickUseContextActionSevice then
			ContextActionService:UnbindAction(DYNAMIC_THUMBSTICK_ACTION_NAME)
		end
		self:OnInputEnded()
	end
	self.enabled = enable
	self.thumbstickFrame.Visible = enable
end
function DynamicThumbstick:OnCharacterAdded(char)
	for _, child in ipairs(char:GetChildren()) do
		if child:IsA("Tool") then
			self.toolEquipped = child
		end
	end
	char.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			self.toolEquipped = child
		elseif child:IsA("Humanoid") then
			self:EnableAutoJump(true)
		end
	end)
	char.ChildRemoved:Connect(function(child)
		if child == self.toolEquipped then
			self.toolEquipped = nil
		end
	end)
	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	if self.humanoid then
		self:EnableAutoJump(true)
	end
end
function DynamicThumbstick:OnInputEnded()
	self.moveTouchObject = nil
	self.moveVector = ZERO_VECTOR3
	self:FadeThumbstick(false)
	if not FFlagDynamicThumbstickUseContextActionSevice then
		self.thumbstickFrame.Active = true
	end
end
function DynamicThumbstick:FadeThumbstick(visible)
	if not visible and self.moveTouchObject then
		return
	end
	if self.isFirstTouch then
		return
	end
	if self.startImageFadeTween then
		self.startImageFadeTween:Cancel()
	end
	if self.endImageFadeTween then
		self.endImageFadeTween:Cancel()
	end
	for i = 1, #self.middleImages do
		if self.middleImageFadeTweens[i] then
			self.middleImageFadeTweens[i]:Cancel()
		end
	end
	if visible then
		self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, {ImageTransparency = 0})
		self.startImageFadeTween:Play()
		self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, {ImageTransparency = 0.2})
		self.endImageFadeTween:Play()
		for i = 1, #self.middleImages do
			self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, {
				ImageTransparency = MIDDLE_TRANSPARENCIES[i]
			})
			self.middleImageFadeTweens[i]:Play()
		end
	else
		self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, {ImageTransparency = 1})
		self.startImageFadeTween:Play()
		self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, {ImageTransparency = 1})
		self.endImageFadeTween:Play()
		for i = 1, #self.middleImages do
			self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, {ImageTransparency = 1})
			self.middleImageFadeTweens[i]:Play()
		end
	end
end
function DynamicThumbstick:FadeThumbstickFrame(fadeDuration, fadeRatio)
	self.fadeInAndOutHalfDuration = fadeDuration * 0.5
	self.fadeInAndOutBalance = fadeRatio
	self.tweenInAlphaStart = tick()
end
function DynamicThumbstick:InputInFrame(inputObject)
	local frameCornerTopLeft = self.thumbstickFrame.AbsolutePosition
	local frameCornerBottomRight = frameCornerTopLeft + self.thumbstickFrame.AbsoluteSize
	local inputPosition = inputObject.Position
	if inputPosition.X >= frameCornerTopLeft.X and inputPosition.Y >= frameCornerTopLeft.Y and inputPosition.X <= frameCornerBottomRight.X and inputPosition.Y <= frameCornerBottomRight.Y then
		return true
	end
	return false
end
function DynamicThumbstick:DoFadeInBackground()
	local playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
	local hasFadedBackgroundInOrientation = false
	if playerGui then
		if playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight then
			hasFadedBackgroundInOrientation = self.hasFadedBackgroundInLandscape
			self.hasFadedBackgroundInLandscape = true
		elseif playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait then
			hasFadedBackgroundInOrientation = self.hasFadedBackgroundInPortrait
			self.hasFadedBackgroundInPortrait = true
		end
	end
	if not hasFadedBackgroundInOrientation then
		self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
		self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
		self.tweenInAlphaStart = tick()
	end
end
function DynamicThumbstick:DoMove(direction)
	local currentMoveVector = direction
	local inputAxisMagnitude = currentMoveVector.magnitude
	if inputAxisMagnitude < self.radiusOfDeadZone then
		currentMoveVector = Vector3.new()
	else
		currentMoveVector = currentMoveVector.unit * (1 - math.max(0, (self.radiusOfMaxSpeed - currentMoveVector.magnitude) / self.radiusOfMaxSpeed))
		currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
	end
	self.moveVector = currentMoveVector
end
function DynamicThumbstick:LayoutMiddleImages(startPos, endPos)
	local startDist = self.thumbstickSize / 2 + self.middleSize
	local vector = endPos - startPos
	local distAvailable = vector.magnitude - self.thumbstickRingSize / 2 - self.middleSize
	local direction = vector.unit
	local distNeeded = self.middleSpacing * NUM_MIDDLE_IMAGES
	local spacing = self.middleSpacing
	if distAvailable > distNeeded then
		spacing = distAvailable / NUM_MIDDLE_IMAGES
	end
	for i = 1, NUM_MIDDLE_IMAGES do
		local image = self.middleImages[i]
		local distWithout = startDist + spacing * (i - 2)
		local currentDist = startDist + spacing * (i - 1)
		if distAvailable > distWithout then
			local pos = endPos - direction * currentDist
			local exposedFraction = math.clamp(1 - (currentDist - distAvailable) / spacing, 0, 1)
			image.Visible = true
			image.Position = UDim2.new(0, pos.X, 0, pos.Y)
			image.Size = UDim2.new(0, self.middleSize * exposedFraction, 0, self.middleSize * exposedFraction)
		else
			image.Visible = false
		end
	end
end
function DynamicThumbstick:MoveStick(pos)
	local vector2StartPosition = Vector2.new(self.moveTouchStartPosition.X, self.moveTouchStartPosition.Y)
	local startPos = vector2StartPosition - self.thumbstickFrame.AbsolutePosition
	local endPos = Vector2.new(pos.X, pos.Y) - self.thumbstickFrame.AbsolutePosition
	self.endImage.Position = UDim2.new(0, endPos.X, 0, endPos.Y)
	self:LayoutMiddleImages(startPos, endPos)
end
function DynamicThumbstick:BindContextActions()
	local function inputBegan(inputObject)
		if self.moveTouchObject then
			return Enum.ContextActionResult.Pass
		end
		if not self:InputInFrame(inputObject) then
			return Enum.ContextActionResult.Pass
		end
		if self.isFirstTouch then
			self.isFirstTouch = false
			local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0)
			TweenService:Create(self.startImage, tweenInfo, {
				Size = UDim2.new(0, 0, 0, 0)
			}):Play()
			TweenService:Create(self.endImage, tweenInfo, {
				Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize),
				ImageColor3 = Color3.new(0, 0, 0)
			}):Play()
		end
		self.moveTouchObject = inputObject
		self.moveTouchStartPosition = inputObject.Position
		self.moveTouchFirstChanged = true
		if FADE_IN_OUT_BACKGROUND then
			self:DoFadeInBackground()
		end
		return Enum.ContextActionResult.Pass
	end
	local function inputChanged(inputObject)
		if inputObject == self.moveTouchObject then
			if self.moveTouchFirstChanged then
				self.moveTouchFirstChanged = false
				local startPosVec2 = Vector2.new(inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X, inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y)
				self.startImage.Visible = true
				self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
				self.endImage.Visible = true
				self.endImage.Position = self.startImage.Position
				self:FadeThumbstick(true)
				self:MoveStick(inputObject.Position)
			end
			local direction = Vector2.new(inputObject.Position.x - self.moveTouchStartPosition.x, inputObject.Position.y - self.moveTouchStartPosition.y)
			if 0 < math.abs(direction.x) or 0 < math.abs(direction.y) then
				self:DoMove(direction)
				self:MoveStick(inputObject.Position)
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	local function inputEnded(inputObject)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
			if self.moveTouchLockedIn then
				return Enum.ContextActionResult.Sink
			end
		end
		return Enum.ContextActionResult.Pass
	end
	local function handleInput(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.Begin then
			return inputBegan(inputObject)
		elseif inputState == Enum.UserInputState.Change then
			return inputChanged(inputObject)
		elseif inputState == Enum.UserInputState.End then
			return inputEnded(inputObject)
		elseif inputState == Enum.UserInputState.Cancel then
			self:OnInputEnded()
		end
	end
	ContextActionService:BindActionAtPriority(DYNAMIC_THUMBSTICK_ACTION_NAME, handleInput, false, DYNAMIC_THUMBSTICK_ACTION_PRIORITY, Enum.UserInputType.Touch)
end
function DynamicThumbstick:Create(parentFrame)
	if self.thumbstickFrame then
		self.thumbstickFrame:Destroy()
		self.thumbstickFrame = nil
		if not FFlagDynamicThumbstickUseContextActionSevice then
			if self.onTouchMovedConn then
				self.onTouchMovedConn:Disconnect()
				self.onTouchMovedConn = nil
			end
			if self.onTouchEndedConn then
				self.onTouchEndedCon:Disconnect()
				self.onTouchEndedCon = nil
			end
			if self.onTouchActivateConn then
				self.onTouchActivateConn:Disconnect()
				self.onTouchActivateConn = nil
			end
		end
		if self.onRenderSteppedConn then
			self.onRenderSteppedConn:Disconnect()
			self.onRenderSteppedConn = nil
		end
	end
	self.thumbstickSize = 45
	self.thumbstickRingSize = 20
	self.middleSize = 10
	self.middleSpacing = self.middleSize + 4
	self.radiusOfDeadZone = 2
	self.radiusOfMaxSpeed = 20
	local screenSize = parentFrame.AbsoluteSize
	local isBigScreen = math.min(screenSize.x, screenSize.y) > 500
	if isBigScreen then
		self.thumbstickSize = self.thumbstickSize * 2
		self.thumbstickRingSize = self.thumbstickRingSize * 2
		self.middleSize = self.middleSize * 2
		self.middleSpacing = self.middleSpacing * 2
		self.radiusOfDeadZone = self.radiusOfDeadZone * 2
		self.radiusOfMaxSpeed = self.radiusOfMaxSpeed * 2
	end
	local function layoutThumbstickFrame(portraitMode)
		if portraitMode then
			self.thumbstickFrame.Size = UDim2.new(1, 0, 0.4, 0)
			self.thumbstickFrame.Position = UDim2.new(0, 0, 0.6, 0)
		else
			self.thumbstickFrame.Size = UDim2.new(0.4, 0, 0.6666666666666666, 0)
			self.thumbstickFrame.Position = UDim2.new(0, 0, 0.3333333333333333, 0)
		end
	end
	self.thumbstickFrame = Instance.new("TextButton")
	self.thumbstickFrame.Text = ""
	self.thumbstickFrame.Name = "DynamicThumbstickFrame"
	self.thumbstickFrame.Visible = false
	self.thumbstickFrame.BackgroundTransparency = 1
	self.thumbstickFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	if FFlagDynamicThumbstickUseContextActionSevice then
		self.thumbstickFrame.Active = false
	end
	layoutThumbstickFrame(false)
	self.startImage = Instance.new("ImageLabel")
	self.startImage.Name = "ThumbstickStart"
	self.startImage.Visible = true
	self.startImage.BackgroundTransparency = 1
	self.startImage.Image = TOUCH_CONTROLS_SHEET
	self.startImage.ImageRectOffset = Vector2.new(1, 1)
	self.startImage.ImageRectSize = Vector2.new(144, 144)
	self.startImage.ImageColor3 = Color3.new(0, 0, 0)
	self.startImage.AnchorPoint = Vector2.new(0.5, 0.5)
	self.startImage.Position = UDim2.new(0, self.thumbstickRingSize * 3.3, 1, -self.thumbstickRingSize * 2.8)
	self.startImage.Size = UDim2.new(0, self.thumbstickRingSize * 3.7, 0, self.thumbstickRingSize * 3.7)
	self.startImage.ZIndex = 10
	self.startImage.Parent = self.thumbstickFrame
	self.endImage = Instance.new("ImageLabel")
	self.endImage.Name = "ThumbstickEnd"
	self.endImage.Visible = true
	self.endImage.BackgroundTransparency = 1
	self.endImage.Image = TOUCH_CONTROLS_SHEET
	self.endImage.ImageRectOffset = Vector2.new(1, 1)
	self.endImage.ImageRectSize = Vector2.new(144, 144)
	self.endImage.AnchorPoint = Vector2.new(0.5, 0.5)
	self.endImage.Position = self.startImage.Position
	self.endImage.Size = UDim2.new(0, self.thumbstickSize * 0.8, 0, self.thumbstickSize * 0.8)
	self.endImage.ZIndex = 10
	self.endImage.Parent = self.thumbstickFrame
	for i = 1, NUM_MIDDLE_IMAGES do
		self.middleImages[i] = Instance.new("ImageLabel")
		self.middleImages[i].Name = "ThumbstickMiddle"
		self.middleImages[i].Visible = false
		self.middleImages[i].BackgroundTransparency = 1
		self.middleImages[i].Image = TOUCH_CONTROLS_SHEET
		self.middleImages[i].ImageRectOffset = Vector2.new(1, 1)
		self.middleImages[i].ImageRectSize = Vector2.new(144, 144)
		self.middleImages[i].ImageTransparency = MIDDLE_TRANSPARENCIES[i]
		self.middleImages[i].AnchorPoint = Vector2.new(0.5, 0.5)
		self.middleImages[i].ZIndex = 9
		self.middleImages[i].Parent = self.thumbstickFrame
	end
	local CameraChangedConn
	local function onCurrentCameraChanged()
		if CameraChangedConn then
			CameraChangedConn:Disconnect()
			CameraChangedConn = nil
		end
		local newCamera = workspace.CurrentCamera
		if newCamera then
			local function onViewportSizeChanged()
				local size = newCamera.ViewportSize
				local portraitMode = size.X < size.Y
				layoutThumbstickFrame(portraitMode)
			end
			CameraChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(onViewportSizeChanged)
			onViewportSizeChanged()
		end
	end
	workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(onCurrentCameraChanged)
	if workspace.CurrentCamera then
		onCurrentCameraChanged()
	end
	self.moveTouchStartPosition = nil
	self.startImageFadeTween = nil
	self.endImageFadeTween = nil
	self.middleImageFadeTweens = {}
	if not FFlagDynamicThumbstickUseContextActionSevice then
		self.thumbstickFrame.InputBegan:Connect(function(inputObject)
			if inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
				return
			end
			if self.moveTouchObject then
				return
			end
			if self.isFirstTouch then
				self.isFirstTouch = false
				local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0)
				TweenService:Create(self.startImage, tweenInfo, {
					Size = UDim2.new(0, 0, 0, 0)
				}):Play()
				TweenService:Create(self.endImage, tweenInfo, {
					Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize),
					ImageColor3 = Color3.new(0, 0, 0)
				}):Play()
			end
			self.moveTouchObject = inputObject
			self.moveTouchStartPosition = inputObject.Position
			local startPosVec2 = Vector2.new(inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X, inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y)
			self.startImage.Visible = true
			self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
			self.endImage.Visible = true
			self.endImage.Position = self.startImage.Position
			self:FadeThumbstick(true)
			self:MoveStick(inputObject.Position)
			if FADE_IN_OUT_BACKGROUND then
				self:DoFadeInBackground()
			end
		end)
		self.onTouchMovedConn = UserInputService.TouchMoved:connect(function(inputObject)
			if inputObject == self.moveTouchObject then
				self.thumbstickFrame.Active = false
				local direction = Vector2.new(inputObject.Position.x - self.moveTouchStartPosition.x, inputObject.Position.y - self.moveTouchStartPosition.y)
				if math.abs(direction.x) > 0 or math.abs(direction.y) > 0 then
					self:DoMove(direction)
					self:MoveStick(inputObject.Position)
				end
			end
		end)
	end
	self.onRenderSteppedConn = RunService.RenderStepped:Connect(function()
		if self.tweenInAlphaStart ~= nil then
			local delta = tick() - self.tweenInAlphaStart
			local fadeInTime = self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance
			self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA * math.min(delta / fadeInTime, 1)
			if delta > fadeInTime then
				self.tweenOutAlphaStart = tick()
				self.tweenInAlphaStart = nil
			end
		elseif self.tweenOutAlphaStart ~= nil then
			local delta = tick() - self.tweenOutAlphaStart
			local fadeOutTime = self.fadeInAndOutHalfDuration * 2 - self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance
			self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA + FADE_IN_OUT_MAX_ALPHA * math.min(delta / fadeOutTime, 1)
			if delta > fadeOutTime then
				self.tweenOutAlphaStart = nil
			end
		end
	end)
	self.onTouchEndedConn = UserInputService.TouchEnded:connect(function(inputObject)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	GuiService.MenuOpened:connect(function()
		if self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	local playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
	while not playerGui do
		Players.LocalPlayer.ChildAdded:wait()
		playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
	end
	local playerGuiChangedConn
	local originalScreenOrientationWasLandscape = playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight
	local function longShowBackground()
		self.fadeInAndOutHalfDuration = 2.5
		self.fadeInAndOutBalance = 0.05
		self.tweenInAlphaStart = tick()
	end
	playerGuiChangedConn = playerGui.Changed:connect(function(prop)
		if prop == "CurrentScreenOrientation" and (originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait or not originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation ~= Enum.ScreenOrientation.Portrait) then
			playerGuiChangedConn:disconnect()
			longShowBackground()
			if originalScreenOrientationWasLandscape then
				self.hasFadedBackgroundInPortrait = true
			else
				self.hasFadedBackgroundInLandscape = true
			end
		end
	end)
	self.thumbstickFrame.Parent = parentFrame
	spawn(function()
		if game:IsLoaded() then
			longShowBackground()
		else
			game.Loaded:wait()
			longShowBackground()
		end
	end)
end
return DynamicThumbstick
]]></ProtectedString><string name="Name">DynamicThumbstick</string></Properties></Item><Item class="ModuleScript" referent="RBX400"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local PathDisplay = {}
PathDisplay.spacing = 8
PathDisplay.image = "rbxasset://textures/Cursors/Gamepad/Pointer.png"
PathDisplay.imageSize = Vector2.new(2, 2)
local currentPoints = {}
local renderedPoints = {}
local pointModel = Instance.new("Model")
pointModel.Name = "PathDisplayPoints"
local adorneePart = Instance.new("Part")
adorneePart.Anchored = true
adorneePart.CanCollide = false
adorneePart.Transparency = 1
adorneePart.Name = "PathDisplayAdornee"
adorneePart.CFrame = CFrame.new(0, 0, 0)
adorneePart.Parent = pointModel
local pointPool = {}
local poolTop = 30
for i = 1, poolTop do
	local point = Instance.new("ImageHandleAdornment")
	point.Archivable = false
	point.Adornee = adorneePart
	point.Image = PathDisplay.image
	point.Size = PathDisplay.imageSize
	pointPool[i] = point
end
local function retrieveFromPool()
	local point = pointPool[1]
	if not point then
		return
	end
	pointPool[1], pointPool[poolTop] = pointPool[poolTop], nil
	poolTop = poolTop - 1
	return point
end
local function returnToPool(point)
	poolTop = poolTop + 1
	pointPool[poolTop] = point
end
local function renderPoint(point, isLast)
	if poolTop == 0 then
		return
	end
	local rayDown = Ray.new(point + Vector3.new(0, 2, 0), Vector3.new(0, -8, 0))
	local hitPart, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(rayDown, {
		game.Players.LocalPlayer.Character,
		workspace.CurrentCamera
	})
	if not hitPart then
		return
	end
	local pointCFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
	local point = retrieveFromPool()
	point.CFrame = pointCFrame
	point.Parent = pointModel
	return point
end
function PathDisplay.setCurrentPoints(points)
	if typeof(points) == "table" then
		currentPoints = points
	else
		currentPoints = {}
	end
end
function PathDisplay.clearRenderedPath()
	for _, oldPoint in ipairs(renderedPoints) do
		oldPoint.Parent = nil
		returnToPool(oldPoint)
	end
	renderedPoints = {}
	pointModel.Parent = nil
end
function PathDisplay.renderPath()
	PathDisplay.clearRenderedPath()
	if not currentPoints or #currentPoints == 0 then
		return
	end
	local currentIdx = #currentPoints
	local lastPos = currentPoints[currentIdx]
	local distanceBudget = 0
	renderedPoints[1] = renderPoint(lastPos, true)
	if not renderedPoints[1] then
		return
	end
	while true do
		local currentPoint = currentPoints[currentIdx]
		local nextPoint = currentPoints[currentIdx - 1]
		if currentIdx < 2 then
			break
		else
			local toNextPoint = nextPoint - currentPoint
			local distToNextPoint = toNextPoint.magnitude
			if distanceBudget > distToNextPoint then
				distanceBudget = distanceBudget - distToNextPoint
				currentIdx = currentIdx - 1
			else
				local dirToNextPoint = toNextPoint.unit
				local pointPos = currentPoint + dirToNextPoint * distanceBudget
				local point = renderPoint(pointPos, false)
				if point then
					renderedPoints[#renderedPoints + 1] = point
				end
				distanceBudget = distanceBudget + PathDisplay.spacing
			end
		end
	end
	pointModel.Parent = workspace.CurrentCamera
end
return PathDisplay
]]></ProtectedString><string name="Name">PathDisplay</string></Properties></Item><Item class="ModuleScript" referent="RBX405"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local Players = game:GetService("Players")
local BaseCharacterController = {}
BaseCharacterController.__index = BaseCharacterController
function BaseCharacterController.new()
	local self = setmetatable({}, BaseCharacterController)
	self.enabled = false
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	return self
end
function BaseCharacterController:GetMoveVector()
	return self.moveVector
end
function BaseCharacterController:GetIsJumping()
	return self.isJumping
end
function BaseCharacterController:Enable(enable)
	error("BaseCharacterController:Enable must be overridden in derived classes and should not be called.")
	return false
end
return BaseCharacterController
]]></ProtectedString><string name="Name">BaseCharacterController</string></Properties></Item><Item class="ModuleScript" referent="RBX410"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local useTriggersForThrottle = true
local onlyTriggersForThrottle = false
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local VehicleController = {}
VehicleController.__index = VehicleController
function VehicleController.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable({}, VehicleController)
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	self.enabled = false
	self.vehicleSeat = nil
	self.throttle = 0
	self.steer = 0
	self.acceleration = 0
	self.decceleration = 0
	self.turningRight = 0
	self.turningLeft = 0
	self.vehicleMoveVector = ZERO_VECTOR3
	return self
end
function VehicleController:BindContextActions()
	if useTriggersForThrottle then
		ContextActionService:BindActionAtPriority("throttleAccel", function(actionName, inputState, inputObject)
			self:OnThrottleAccel(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonR2)
		ContextActionService:BindActionAtPriority("throttleDeccel", function(actionName, inputState, inputObject)
			self:OnThrottleDeccel(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonL2)
	end
	ContextActionService:BindActionAtPriority("arrowSteerRight", function(actionName, inputState, inputObject)
		self:OnSteerRight(actionName, inputState, inputObject)
		return Enum.ContextActionResult.Pass
	end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Right)
	ContextActionService:BindActionAtPriority("arrowSteerLeft", function(actionName, inputState, inputObject)
		self:OnSteerLeft(actionName, inputState, inputObject)
		return Enum.ContextActionResult.Pass
	end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Left)
end
function VehicleController:Enable(enable, vehicleSeat)
	if enable == self.enabled and vehicleSeat == self.vehicleSeat then
		return
	end
	self.vehicleMoveVector = ZERO_VECTOR3
	if enable then
		if vehicleSeat then
			self.vehicleSeat = vehicleSeat
			if FFlagPlayerScriptsBindAtPriority2 then
				self:BindContextActions()
			else
				if useTriggersForThrottle then
					ContextActionService:BindAction("throttleAccel", function(actionName, inputState, inputObject)
						self:OnThrottleAccel(actionName, inputState, inputObject)
						return Enum.ContextActionResult.Pass
					end, false, Enum.KeyCode.ButtonR2)
					ContextActionService:BindAction("throttleDeccel", function(actionName, inputState, inputObject)
						self:OnThrottleDeccel(actionName, inputState, inputObject)
						return Enum.ContextActionResult.Pass
					end, false, Enum.KeyCode.ButtonL2)
				end
				ContextActionService:BindAction("arrowSteerRight", function(actionName, inputState, inputObject)
					self:OnSteerRight(actionName, inputState, inputObject)
					return Enum.ContextActionResult.Pass
				end, false, Enum.KeyCode.Right)
				ContextActionService:BindAction("arrowSteerLeft", function(actionName, inputState, inputObject)
					self:OnSteerLeft(actionName, inputState, inputObject)
					return Enum.ContextActionResult.Pass
				end, false, Enum.KeyCode.Left)
			end
		end
	else
		if useTriggersForThrottle then
			ContextActionService:UnbindAction("throttleAccel")
			ContextActionService:UnbindAction("throttleDeccel")
		end
		ContextActionService:UnbindAction("arrowSteerRight")
		ContextActionService:UnbindAction("arrowSteerLeft")
		self.vehicleSeat = nil
	end
end
function VehicleController:OnThrottleAccel(actionName, inputState, inputObject)
	self.acceleration = inputState ~= Enum.UserInputState.End and -1 or 0
	self.throttle = self.acceleration + self.decceleration
end
function VehicleController:OnThrottleDeccel(actionName, inputState, inputObject)
	self.decceleration = inputState ~= Enum.UserInputState.End and 1 or 0
	self.throttle = self.acceleration + self.decceleration
end
function VehicleController:OnSteerRight(actionName, inputState, inputObject)
	self.turningRight = inputState ~= Enum.UserInputState.End and 1 or 0
	self.steer = self.turningRight + self.turningLeft
end
function VehicleController:OnSteerLeft(actionName, inputState, inputObject)
	self.turningLeft = inputState ~= Enum.UserInputState.End and -1 or 0
	self.steer = self.turningRight + self.turningLeft
end
function VehicleController:Update(moveVector, usingGamepad)
	if self.vehicleSeat then
		moveVector = moveVector + Vector3.new(self.steer, 0, self.throttle)
		if usingGamepad and onlyTriggersForThrottle and useTriggersForThrottle then
			self.vehicleSeat.ThrottleFloat = -self.throttle
		else
			self.vehicleSeat.ThrottleFloat = -moveVector.Z
		end
		self.vehicleSeat.SteerFloat = moveVector.X
		return moveVector, true
	end
	return moveVector, false
end
return VehicleController
]]></ProtectedString><string name="Name">VehicleController</string></Properties></Item></Item></Item></Item><Item class="Folder" referent="RBX418"><Properties><string name="Name">PlayerGui</string></Properties><Item class="Folder" referent="RBX421"><Properties><string name="Name">TokenMenu</string></Properties><Item class="LocalScript" referent="RBX424"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

wait(1)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local MPS = game:GetService("MarketplaceService")
local TokenEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("TokenEvent")
local RippleEffect = require(script:WaitForChild("cl_circles"))
local UtilService = {}
local TS = game:GetService("TweenService")
local LocalPlayer = game:GetService("Players").LocalPlayer
repeat
	wait()
until LocalPlayer
local Interface = script.Parent
local BlipSound = script:WaitForChild("Blip")
local ClickSound = script:WaitForChild("Click")
local BuySound = script:WaitForChild("Purchase")
local SettingsButton = Interface:WaitForChild("SettingsButton")
local BalanceButton = SettingsButton:WaitForChild("Balance")
local BuyTokensButton = SettingsButton:WaitForChild("BuyMore")
local DonateButton = SettingsButton:WaitForChild("Donate")
local BuyTokensMenu = SettingsButton:WaitForChild("BuyFrame")
local DonateMenu = SettingsButton:WaitForChild("DonateFrame")
local Submenu = false
local SubMoveDB = false
local MakingPurchase = false
local AestheticHandled = false
local SubmenuShow = UDim2.new(-0.4, -160, 0.5, 58)
local SubmenuRetract = UDim2.new(-0.4, -400, 0.5, 58)
local moveDB = false
local SettingsState = false
local Black = Color3.fromRGB(27, 42, 53)
local White = Color3.fromRGB(247, 247, 247)
local Green = Color3.fromRGB(100, 200, 0)
local Red = Color3.fromRGB(255, 0, 27)
local Products = {
	Tokens10 = 410188006,
	Tokens20 = 431638162,
	Tokens50 = 431638590,
	Tokens100 = 431638989
}
local tokenDeveloperProducts = {}
tokenDeveloperProducts[410188006] = 10
tokenDeveloperProducts[431638162] = 20
tokenDeveloperProducts[431638590] = 50
tokenDeveloperProducts[431638989] = 100
local function TweenColor(Gui, Bg, Text)
	TS:Create(Gui, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundColor3 = Bg, TextColor3 = Text}):Play()
end
SettingsButton.MouseButton1Click:connect(function()
	if moveDB then
		return
	end
	ClickSound:Play()
	moveDB = true
	wait(0.05)
	SettingsButton:TweenPosition(SettingsState and UDim2.new(0, 10, 0.7, -150) or UDim2.new(0, 200, 0.7, -150), "Out", "Quad", 0.3)
	wait(0.3)
	SettingsState = not SettingsState
	moveDB = false
end)
local function OpenSubmenu(Button, Menu)
	return function()
		RippleEffect(Button, LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y, Submenu)
		wait(0.05)
		if not Submenu and not SubMoveDB then
			Submenu = Menu
			SubMoveDB = true
			TweenColor(Button, Black, White)
			Menu:TweenPosition(SubmenuShow, "Out", "Quart", 0.2)
			wait(0.3)
			SubMoveDB = false
		elseif Submenu == Menu and not SubMoveDB then
			SubMoveDB = true
			TweenColor(Button, White, Black)
			Menu:TweenPosition(SubmenuRetract, "In", "Quart", 0.2)
			wait(0.3)
			SubMoveDB = false
			Submenu = nil
		end
	end
end
local function RequestProduct(Button, PName)
	return function()
		RippleEffect(Button, LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y, MakingPurchase)
		wait(0.05)
		if not MakingPurchase then
			MakingPurchase = Button
			TweenColor(MakingPurchase, Black, White)
			MPS:PromptProductPurchase(LocalPlayer, Products[PName])
		end
	end
end
local function TokenUpdate(Type, Arg)
	if Type == "TokenAmountUpdate" then
		BuySound:Play()
		BalanceButton.Text = "BALANCE: " .. Arg
	elseif Type == "PurchaseUpdate" then
		local Success, Balance = unpack(Arg)
		if Balance then
			BalanceButton.Text = "BALANCE: " .. Balance
		end
		TweenColor(MakingPurchase, Green, White)
		BuySound:Play()
		wait(0.3)
		TweenColor(MakingPurchase, White, Black)
		wait(0.15)
		MakingPurchase = nil
	end
end
local function WhenCancelled(Plr, Aid, Confirm)
	if tokenDeveloperProducts[Aid] and MakingPurchase and not Confirm then
		TweenColor(MakingPurchase, Red, White)
		ClickSound:Play()
		wait(0.3)
		TweenColor(MakingPurchase, White, Black)
		MakingPurchase = nil
	end
end
for _, Button in pairs(BuyTokensMenu:GetChildren()) do
	Button.MouseButton1Click:Connect(RequestProduct(Button, Button.Name))
end
MPS.PromptProductPurchaseFinished:Connect(WhenCancelled)
BuyTokensButton.MouseButton1Click:Connect(OpenSubmenu(BuyTokensButton, BuyTokensMenu))
TokenEvent.OnClientEvent:Connect(TokenUpdate)
TokenEvent:FireServer("TokenUpdate")
]]></ProtectedString><string name="Name">MenuScript</string></Properties><Item class="ModuleScript" referent="RBX428"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

function CircleClick(Button, X, Y, Nah)
	coroutine.resume(coroutine.create(function()
		Button.ClipsDescendants = true
		local Circle = script:WaitForChild("Circle"):Clone()
		local Sound = script:WaitForChild("Sound"):Clone()
		local Klik = script:WaitForChild("Click"):Clone()
		Circle.Parent = Button
		Sound.Parent = Button
		Klik.Parent = Button
		if not Nah then
			Sound:Play()
		else
			Klik:Play()
		end
		local NewX = X - Circle.AbsolutePosition.X
		local NewY = Y - Circle.AbsolutePosition.Y
		Circle.Position = UDim2.new(0, NewX, 0, NewY)
		local Size = 0
		if Button.AbsoluteSize.Y < Button.AbsoluteSize.X then
			Size = Button.AbsoluteSize.X * 1.5
		elseif Button.AbsoluteSize.X < Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.Y * 1.5
		elseif Button.AbsoluteSize.X == Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.X * 1.5
		end
		local Time = 0.3
		Circle:TweenSizeAndPosition(UDim2.new(0, Size, 0, Size), UDim2.new(0.5, -Size / 2, 0.5, -Size / 2), "Out", "Quad", Time, false, nil)
		local toTween = Circle.ImageTransparency
		for i = 1, 10 do
			Circle.ImageTransparency = 1 - toTween + toTween / 1 * (i / 10)
			wait(Time / 10)
		end
		Circle:Destroy()
		Sound:Destroy()
	end))
end
return CircleClick
]]></ProtectedString><string name="Name">cl_circles</string></Properties></Item></Item></Item><Item class="Folder" referent="RBX435"><Properties><string name="Name">Menu</string></Properties><Item class="LocalScript" referent="RBX438"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

wait(1)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RS = game:GetService("RunService")
local CS = game:GetService("CollectionService")
local NetworkEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("MenuEvent")
local NetworkFunction = ReplicatedStorage:WaitForChild("Functions"):WaitForChild("TeamRequest")
local RippleEffect = require(script:WaitForChild("cl_circles"))
local UtilService = {}
local LocalPlayer = game:GetService("Players").LocalPlayer
repeat
	wait()
until LocalPlayer
local Interface = script.Parent
local BlipSound = script:WaitForChild("Blip")
local ClickSound = script:WaitForChild("Click")
local MapFrame = Interface:WaitForChild("MapFrame")
local SettingsButton = Interface:WaitForChild("SettingsButton")
local ButtonSizeX = SettingsButton:WaitForChild("VolumeSlider").AbsoluteSize.X
local Music = LocalPlayer.PlayerGui:WaitForChild("AmbientEmitter")
local VolumeChangeOff
if not _G.SCPFMusicVolume then
	_G.SCPFMusicVolume = 1
else
	SettingsButton.VolumeSlider.HowMuch.Size = UDim2.new(_G.SCPFMusicVolume, 0, 1, 0)
end
if _G.SCPFMusicSliderEnabled == nil then
	_G.SCPFMusicSliderEnabled = true
end
local moveDB = false
local SettingsState = false
local Mouse
local function ChangeVolume()
	if not _G.SCPFMusicSliderEnabled then
		VolumeChangeOff()
		return
	end
	if Mouse then
		local XDelta = Mouse.X - SettingsButton.VolumeSlider.HowMuch.AbsolutePosition.X
		if XDelta > ButtonSizeX then
			XDelta = ButtonSizeX
		elseif XDelta < 0 then
			XDelta = 0
		end
		local NewVol = XDelta / ButtonSizeX
		_G.SCPFMusicVolume = NewVol
		SettingsButton.VolumeSlider.HowMuch.Size = UDim2.new(NewVol, 0, 1, 0)
	end
end
SettingsButton.MouseButton1Click:connect(function()
	if moveDB then
		return
	end
	ClickSound:Play()
	moveDB = true
	wait(0.05)
	SettingsButton:TweenPosition(SettingsState and UDim2.new(0, 10, 0.5, -150) or UDim2.new(0, 200, 0.5, -150), "Out", "Quad", 0.3)
	wait(0.3)
	SettingsState = not SettingsState
	moveDB = false
end)
SettingsButton.HideName.MouseButton1Click:connect(function()
	RippleEffect(SettingsButton.HideName, LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y)
	SettingsButton.HideName.Text = NetworkFunction:InvokeServer("ChangeHideNameStatus")
end)
SettingsButton.Map.MouseButton1Click:connect(function()
	if moveDB then
		return
	end
	moveDB = true
	RippleEffect(SettingsButton.Map, LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y)
	wait(0.05)
	moveDB = false
	MapFrame.Visible = not MapFrame.Visible
	MapFrame.Active = not MapFrame.Visible
end)
local function VolumeChangeOn(Input)
	if Input:IsA("InputObject") and Input.UserInputState == Enum.UserInputState.Begin and Input.UserInputType == Enum.UserInputType.MouseButton1 and not CS:HasTag(LocalPlayer.Character, "ChangingVolume") then
		Mouse = LocalPlayer:GetMouse()
		RS:BindToRenderStep("VolumeChangeBinding", Enum.RenderPriority.Last.Value, ChangeVolume)
		CS:AddTag(LocalPlayer.Character, "ChangingVolume")
	end
end
local function VolumeChangeOff(Input)
	if Input:IsA("InputObject") and Input.UserInputState == Enum.UserInputState.End and Input.UserInputType == Enum.UserInputType.MouseButton1 then
		Mouse = nil
		RS:UnbindFromRenderStep("VolumeChangeBinding")
		CS:RemoveTag(LocalPlayer.Character, "ChangingVolume")
		Music.Volume = Music.OriginalVolume.Value * _G.SCPFMusicVolume
	end
end
CS:GetInstanceAddedSignal("ChangingVolume"):Connect(VolumeChangeOn)
CS:GetInstanceRemovedSignal("ChangingVolume"):Connect(VolumeChangeOff)
SettingsButton.VolumeSlider.InputBegan:Connect(VolumeChangeOn)
SettingsButton.VolumeSlider.InputEnded:Connect(VolumeChangeOff)
wait(5)
if LocalPlayer.Character and LocalPlayer.Character.Humanoid.DisplayDistanceType == Enum.HumanoidDisplayDistanceType.None then
	SettingsButton.HideName.Text = "SHOW NAME"
end
]]></ProtectedString><string name="Name">MenuScript</string></Properties><Item class="ModuleScript" referent="RBX442"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

function CircleClick(Button, X, Y)
	coroutine.resume(coroutine.create(function()
		Button.ClipsDescendants = true
		local Circle = script:WaitForChild("Circle"):Clone()
		local Sound = script:WaitForChild("Sound"):Clone()
		Circle.Parent = Button
		Sound.Parent = Button
		Sound:Play()
		local NewX = X - Circle.AbsolutePosition.X
		local NewY = Y - Circle.AbsolutePosition.Y
		Circle.Position = UDim2.new(0, NewX, 0, NewY)
		local Size = 0
		if Button.AbsoluteSize.Y < Button.AbsoluteSize.X then
			Size = Button.AbsoluteSize.X * 1.5
		elseif Button.AbsoluteSize.X < Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.Y * 1.5
		elseif Button.AbsoluteSize.X == Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.X * 1.5
		end
		local Time = 0.3
		Circle:TweenSizeAndPosition(UDim2.new(0, Size, 0, Size), UDim2.new(0.5, -Size / 2, 0.5, -Size / 2), "Out", "Quad", Time, false, nil)
		local toTween = Circle.ImageTransparency
		for i = 1, 10 do
			Circle.ImageTransparency = 1 - toTween + toTween / 1 * (i / 10)
			wait(Time / 10)
		end
		Circle:Destroy()
		Sound:Destroy()
	end))
end
return CircleClick
]]></ProtectedString><string name="Name">cl_circles</string></Properties></Item></Item><Item class="Folder" referent="RBX448"><Properties><string name="Name">MapFrame</string></Properties><Item class="LocalScript" referent="RBX451"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Player = game.Players.LocalPlayer
local Gui = script.Parent.Parent
local Map = script.Parent
local MapList = {
	"rbxassetid://2839137474",
	"rbxassetid://2431505905",
	"rbxassetid://2431504688",
	"rbxassetid://2431506141"
}
game.ContentProvider:PreloadAsync(script:GetChildren())
local Index = 0
local Max = #MapList
local function ScrollMap()
	Gui.MenuScript.Click:Play()
	Index = (Index + 1) % Max
	Map.Image = MapList[Index + 1]
end
local function ExitMap()
	Gui.MenuScript.Click:Play()
	Map.Visible = false
	Map.Active = false
end
Map.MouseButton1Click:Connect(ScrollMap)
Map.Exit.MouseButton1Click:Connect(ExitMap)
]]></ProtectedString><string name="Name">MapScroll</string></Properties></Item></Item></Item><Item class="Folder" referent="RBX458"><Properties><string name="Name">AlphaVoiceGui</string></Properties><Item class="LocalScript" referent="RBX461"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Reference = script.Parent.Selections
local Buttons = {
	Reference.buttonOne,
	Reference.buttonTwo,
	Reference.buttonThree,
	Reference.buttonFour,
	Reference.buttonFive,
	Reference.buttonSix
}
local function setTransp(VisibilityBool)
	for i, v in pairs(Buttons) do
		v.Visible = VisibilityBool
		v.Selectable = VisibilityBool
		v.Active = VisibilityBool
	end
end
local function PressFunction(actionName, userInputState, inputObject)
	print(game.Players.LocalPlayer.TeamColor)
	if game.Players.LocalPlayer:GetRankInGroup(2710915) >= 60 and tostring(game.Players.LocalPlayer.TeamColor) == "Storm blue" or game.Players.LocalPlayer:GetRankInGroup(2694395) >= 70 then
		if userInputState == Enum.UserInputState.Begin then
			script.Parent.Selections.Active = true
			setTransp(true)
		elseif userInputState == Enum.UserInputState.End then
			script.Parent.Selections.Active = false
			setTransp(false)
		end
	end
end
game.ContextActionService:BindAction("keyPress", PressFunction, false, Enum.KeyCode.K)
for i, v in pairs(Buttons) do
	v.MouseButton1Click:Connect(function()
		print("test", i)
		game.ReplicatedStorage.Events.AlphaSpeakEvent:FireServer(i)
	end)
	v.nameOfSVX.MouseButton1Click:Connect(function()
		print("test", i)
		game.ReplicatedStorage.Events.AlphaSpeakEvent:FireServer(i)
	end)
end
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item></Item><Item class="Folder" referent="RBX467"><Properties><string name="Name">LoadoutGui</string></Properties><Item class="LocalScript" referent="RBX470"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local CS = game:GetService("CollectionService")
local CAS = game:GetService("ContextActionService")
local CP = game:GetService("ContentProvider")
local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Cam = workspace.CurrentCamera
local Gui = script.Parent
if Plr.TeamColor == game.Teams["Class-D"].TeamColor then
	script.Disabled = true
end
local ToolsPane = Gui:WaitForChild("ToolsGui")
local ArmorPane = Gui:WaitForChild("ArmorGui")
local ToolOrderPane = Gui:WaitForChild("ToolOrder")
local ToolOrderList = ToolOrderPane:WaitForChild("ToolList")
local ExampleButton = script:WaitForChild("OmniButton")
local ExampleSort = script:WaitForChild("ExampleTool")
local SoundRoot = script:WaitForChild("Sounds")
local Sound = {
	Load = function(self, Dir)
		for _, Ch in pairs(Dir:GetChildren()) do
			self[Ch.Name] = Ch
		end
	end,
	Play = function(self, Name)
		if self[Name] and not self[Name].Playing then
			self[Name]:Play()
		end
	end
}
Sound:Load(SoundRoot)
local Map = workspace:WaitForChild("Map")
local CamPart = Map:WaitForChild("LoadoutCameraPart")
local CharPart = Map:WaitForChild("CharacterCopyPart")
local Shed = script:WaitForChild("LoadoutShed")
local Bloom = script:WaitForChild("Bloom")
local Func = game.ReplicatedStorage:WaitForChild("Functions"):WaitForChild("LoadoutFunction")
local Black = Color3.fromRGB(27, 42, 53)
local White = Color3.fromRGB(247, 247, 247)
local Visible = false
local Moving = false
local Background, CharClone
local BlurInTween = TS:Create(workspace.CurrentCamera:WaitForChild("Blur"), TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out, 0, true), {Size = 12})
local Changed = false
local IsInList = function(t, v)
	for _, v0 in pairs(t) do
		if v0 == v then
			return true
		end
	end
	return false
end
local function deepcopy(orig)
	local orig_type = type(orig)
	local copy
	if orig_type == "table" then
		copy = {}
		for orig_key, orig_value in next, orig, nil do
			copy[deepcopy(orig_key)] = deepcopy(orig_value)
		end
		setmetatable(copy, deepcopy(getmetatable(orig)))
	else
		copy = orig
	end
	return copy
end
function print_r(t, name, indent)
	local tableList = {}
	function table_r(t, name, indent, full)
		local id = not full and name or type(name) ~= "number" and tostring(name) or "[" .. name .. "]"
		local tag = indent .. id .. " = "
		local out = {}
		if type(t) == "table" then
			if tableList[t] ~= nil then
				table.insert(out, tag .. "{} -- " .. tableList[t] .. " (self reference)")
			else
				tableList[t] = full and full .. "." .. id or id
				if next(t) then
					table.insert(out, tag .. "{")
					for key, value in pairs(t) do
						table.insert(out, table_r(value, key, indent .. "|  ", tableList[t]))
					end
					table.insert(out, indent .. "}")
				else
					table.insert(out, tag .. "{}")
				end
			end
		else
			local val = type(t) ~= "number" and type(t) ~= "boolean" and "\"" .. tostring(t) .. "\"" or tostring(t)
			table.insert(out, tag .. val)
		end
		return table.concat(out, "\n")
	end
	return table_r(t, name or "Value", indent or "")
end
function pr(t, name)
	print(print_r(t, name))
end
local ConvertFromJSON = function(UnmixedTable, Debug)
	local MixedTable = {}
	for i, v in pairs(UnmixedTable) do
		if typeof(v) == "table" and v.Name and v.Set then
			if Debug then
				print(v.Name, v.Set)
			end
			MixedTable[v.Name] = v.Set
			MixedTable[i] = nil
		else
			MixedTable[i] = v
		end
	end
	return MixedTable
end
local Permitted = Func:InvokeServer("FetchAllowed")
local CurrentLoadout = Func:InvokeServer("FetchLoadout")
CurrentLoadout.Tools = ConvertFromJSON(CurrentLoadout.Tools)
local NewLoadout = deepcopy(CurrentLoadout)
Permitted.Tools = ConvertFromJSON(Permitted.Tools)
local ArmorRoot = workspace.Mechanics.Givers
local HelmetRoot = ArmorRoot.Helmets
local MorphTag = "WellDressed"
local HelmetTag = "NeitherPoorNorIrish"
local Correlation = {
	Arm1 = "Left Arm",
	Arm2 = "Right Arm",
	Leg1 = "Left Leg",
	Leg2 = "Right Leg",
	Chest = "Torso",
	Helm = "Head"
}
local ReverseCorrelation = {
	Arm1 = true,
	Arm2 = true,
	Leg1 = true,
	Leg2 = true,
	Chest = true,
	Helm = true
}
local WeldTo = function(A, B)
	local Weld = Instance.new("ManualWeld")
	Weld.Parent = A
	Weld.Part0, Weld.Part1 = A, B
	Weld.C0 = A.CFrame:inverse() * B.CFrame
	return Weld
end
local function RemoveArmor()
	if not CharClone then
		return
	end
	if not CS:HasTag(CharClone, MorphTag) then
		return
	end
	for _, m in pairs(CharClone:GetChildren()) do
		if m:IsA("Model") and ReverseCorrelation[m] then
			m:Destroy()
		end
	end
	CS:RemoveTag(CharClone, MorphTag)
end
local function RemoveHelmet()
	if not CharClone then
		return
	end
	if not CS:HasTag(CharClone, HelmetTag) then
		return
	end
	if CharClone:FindFirstChild("Helmet") then
		CharClone.Helmet:Destroy()
	end
	CS:RemoveTag(CharClone, HelmetTag)
end
local function GiveArmor(ArmorName)
	if not CharClone then
		return
	end
	if ArmorName == "None" then
		RemoveArmor()
		return
	end
	if CS:HasTag(CharClone, MorphTag) then
		RemoveArmor()
	end
	local Morph = ArmorRoot:FindFirstChild(ArmorName)
	if not Morph then
		return
	end
	for i, v in pairs(CharClone:GetChildren()) do
		if Correlation[v.Name] then
			v.Parent = CharClone
			for e, g in pairs(v:GetChildren()) do
				if g.Name ~= "Middle" then
					WeldTo(v.Middle, g)
					g.Anchored = false
					g.CanCollide = false
				end
			end
			for e, g in pairs(CharClone:GetChildren()) do
				if g:IsA("Accessory") and Morph:FindFirstChild("Helm") then
					g:Destroy()
				end
			end
			v.Middle.Anchored = false
			v.Middle.CanCollide = false
			v:SetPrimaryPartCFrame(CharClone:FindFirstChild(Correlation[v.Name]).CFrame)
			WeldTo(CharClone:FindFirstChild(Correlation[v.Name]), v.Middle)
		end
	end
	CS:AddTag(CharClone, MorphTag)
end
local function GiveHelmet(HelmetName)
	if not CharClone or not CharClone:FindFirstChild("Head") then
		return
	end
	if HelmetName == "None" then
		RemoveHelmet()
		return
	end
	if CS:HasTag(CharClone, HelmetTag) then
		RemoveHelmet()
	end
	local Helmet = HelmetRoot:FindFirstChild(HelmetName)
	if Helmet then
		Helmet = Helmet.Helmet:Clone()
	else
		return
	end
	Helmet.Parent = CharClone
	for e, n in pairs(CharClone:GetChildren()) do
		if n:IsA("Accoutrement") then
			n:Destroy()
		end
	end
	for e, n in pairs(Helmet:GetChildren()) do
		if n.Name ~= "Middle" and (n:IsA("UnionOperation") or n:IsA("BasePart")) then
			WeldTo(Helmet.Middle, n)
			n.Anchored = false
			n.CanCollide = false
		end
	end
	Helmet.Middle.Anchored = false
	Helmet.Middle.CanCollide = false
	Helmet:SetPrimaryPartCFrame(CharClone.Head.CFrame)
	WeldTo(Helmet.Middle, CharClone.Head)
	CS:AddTag(CharClone, HelmetTag)
end
local function SetClothing(ShirtId, PantsId, TShirtId)
	if not CharClone then
		return
	end
	local Shirt = CharClone:FindFirstChildWhichIsA("Shirt")
	Shirt = Shirt and Shirt or Instance.new("Shirt", Plr.Character)
	local Pants = CharClone:FindFirstChildWhichIsA("Pants")
	Pants = Pants and Pants or Instance.new("Pants", Plr.Character)
	if TShirtId then
		local TShirt = CharClone:FindFirstChildWhichIsA("ShirtGraphic")
		TShirt = TShirt and TShirt or Instance.new("ShirtGraphic", Plr.Character)
		TShirt.Graphic = TShirtId
	end
	if typeof(ShirtId) == "number" then
		ShirtId = "rbxassetid://" .. ShirtId
	end
	if typeof(PantsId) == "number" then
		PantsId = "rbxassetid://" .. PantsId
	end
	if ShirtId then
		Shirt.ShirtTemplate = ShirtId
	end
	if PantsId then
		Pants.PantsTemplate = PantsId
	end
end
local function RevertClothing()
	if not CharClone then
		return
	end
	if not Plr.Character then
		return
	end
	local Chr = Plr.Character
	local ShirtId, PantsId, TShirtId
	local Shirt = CharClone:FindFirstChildWhichIsA("Shirt")
	local Pants = CharClone:FindFirstChildWhichIsA("Pants")
	local TShirt = CharClone:FindFirstChildWhichIsA("ShirtGraphic")
	if Shirt then
		ShirtId = Shirt.ShirtTemplate
	end
	if Pants then
		PantsId = Pants.PantsTemplate
	end
	if TShirt then
		TShirtId = TShirt.Graphic
	end
	SetClothing(ShirtId, PantsId, TShirtId)
end
local DualListDisplay = {
	H = nil,
	Category = nil,
	Gui = nil,
	EntryList = nil,
	SettingsList = nil
}
function DualListDisplay:ClearList()
	local List = self.EntryList
	local ULL = List.UIListLayout
	local UP = List.UIPadding
	ULL.Parent = nil
	UP.Parent = nil
	List:ClearAllChildren()
	ULL.Parent, UP.Parent = List, List
end
function DualListDisplay:ChangeEntry(Value)
	return function()
		if NewLoadout[self.H][self.Category] ~= Value then
			Sound:Play("Navigate")
			NewLoadout[self.H][self.Category] = Value
			if self.Category == "Armor" then
				GiveArmor(Value)
			end
			if self.Category == "Helmet" then
				GiveHelmet(Value)
			end
			if self.Category == "Clothing" then
				local TheClothe = Permitted.Armor.Clothing[Value]
				if TheClothe == "None" then
					RevertClothing()
				else
					SetClothing(TheClothe.Shirt, TheClothe.Pants, TheClothe.TShirt)
				end
			end
			Changed = true
			for _, B in pairs(self.EntryList:GetChildren()) do
				if B:IsA("GuiButton") then
					if B.Text == Value then
						B.BackgroundColor3 = White
						B.TextColor3 = Black
					else
						B.BackgroundColor3 = Black
						B.TextColor3 = White
					end
				end
			end
		else
			Sound:Play("Click")
		end
	end
end
function DualListDisplay:ChangeCategory(Value)
	return function()
		if self.Category == Value then
			Sound:Play("Click")
			return
		end
		self.Category = Value
		Sound:Play("Navigate")
		for _, B in pairs(self.SettingsList:GetChildren()) do
			if B:IsA("GuiButton") then
				if B.Text == Value then
					B.BackgroundColor3 = White
					B.TextColor3 = Black
				else
					B.BackgroundColor3 = Black
					B.TextColor3 = White
				end
			end
		end
		self:ClearList()
		for K, Entry in pairs(Permitted[self.H][self.Category]) do
			local NewButton = ExampleButton:Clone()
			Entry = typeof(Entry) ~= "table" and Entry or K
			if NewLoadout[self.H][self.Category] == Entry then
				NewButton.BackgroundColor3 = White
				NewButton.TextColor3 = Black
			end
			NewButton.Name = Entry
			NewButton.Text = Entry
			NewButton.Parent = self.EntryList
			NewButton.MouseButton1Click:Connect(self:ChangeEntry(Entry))
		end
	end
end
function DualListDisplay.new(Menu, Name)
	local T = setmetatable({
		Gui = Menu,
		H = Name,
		EntryList = Menu:WaitForChild("EntryList"),
		SettingsList = Menu:WaitForChild("SettingsList")
	}, DualListDisplay)
	local Count = 0
	for i, v in pairs(Permitted[Name]) do
		if typeof(i) == "string" and not T.SettingsList:FindFirstChild(i) then
			Count = Count + 1
			local NewButton = ExampleButton:Clone()
			NewButton.Name = i
			NewButton.Text = i
			NewButton.Parent = T.SettingsList
			NewButton.MouseButton1Click:Connect(T:ChangeCategory(i))
		end
	end
	if Count == 0 then
		Menu.NoneText.Visible = true
	end
	return T
end
DualListDisplay.__index = DualListDisplay
local ArrangeList = {}
function ArrangeList:GetButtonAtIndex(Ind)
	for _, Button in pairs(self.Gui:GetChildren()) do
		if Button:IsA("GuiButton") and Button.LayoutOrder == Ind then
			return Button
		end
	end
end
function ArrangeList:MoveAhead(Button)
	return function()
		local ButtonInd = Button.LayoutOrder
		local NextButton = self:GetButtonAtIndex(ButtonInd + 1)
		if NextButton then
			Sound:Play("Navigate")
			Changed = true
			NextButton.LayoutOrder = NextButton.LayoutOrder - 1
			Button.LayoutOrder = Button.LayoutOrder + 1
		else
			Sound:Play("Click")
		end
	end
end
function ArrangeList:MoveBehind(Button)
	return function()
		local ButtonInd = Button.LayoutOrder
		local NextButton = self:GetButtonAtIndex(ButtonInd - 1)
		if NextButton then
			Sound:Play("Navigate")
			Changed = true
			NextButton.LayoutOrder = NextButton.LayoutOrder + 1
			Button.LayoutOrder = Button.LayoutOrder - 1
		else
			Sound:Play("Click")
		end
	end
end
function ArrangeList.new(Gui, DataSet)
	local T = setmetatable({Gui = Gui}, ArrangeList)
	local Ind = next(DataSet)
	local AbsoluteInd = 0
	while Ind do
		local Button = ExampleSort:Clone()
		local ToStr = typeof(Ind) == "number" and DataSet[Ind] or Ind
		Button.Name, Button.Text = ToStr, ToStr
		Button.LayoutOrder = AbsoluteInd
		Button.Parent = Gui
		Button.MouseButton1Click:Connect(T:MoveAhead(Button))
		Button.MouseButton2Click:Connect(T:MoveBehind(Button))
		AbsoluteInd = AbsoluteInd + 1
		Ind = next(DataSet, Ind)
	end
end
ArrangeList.__index = ArrangeList
local function SendData()
	local ToolsOrder = {}
	for _, Button in pairs(ToolOrderList:GetChildren()) do
		if Button:IsA("GuiButton") then
			table.insert(ToolsOrder, {
				Button.Name,
				Button.LayoutOrder
			})
		end
	end
	table.sort(ToolsOrder, function(a, b)
		return a[2] < b[2]
	end)
	for K, Tool in pairs(ToolsOrder) do
		ToolsOrder[K] = ToolsOrder[K][1]
	end
	local NewTools = NewLoadout.Tools
	local NewArmor = NewLoadout.Armor
	local ReturnTools = {}
	local ReturnArmor = {}
	for _, Tool in pairs(ToolsOrder) do
		if NewTools[Tool] then
			table.insert(ReturnTools, {
				Name = Tool,
				Set = NewTools[Tool]
			})
		else
			table.insert(ReturnTools, Tool)
		end
	end
	ReturnArmor = deepcopy(NewArmor)
	if ReturnArmor.Clothing then
		ReturnArmor.Clothing = deepcopy(Permitted.Armor.Clothing[ReturnArmor.Clothing])
	end
	local Ret = {Tools = ReturnTools, Armor = ReturnArmor}
	return Ret
end
local function ToggleOn()
	if Moving then
		return
	end
	Moving = true
	Background = Shed:Clone()
	for _, Part in pairs(Background:GetChildren()) do
		Part.BrickColor = Plr.TeamColor
	end
	Background.Parent = Cam
	Sound:Play("Open")
	BlurInTween:Play()
	Bloom.Parent = Cam
	if CS:HasTag(workspace.CurrentCamera, "GUIOccupied") then
		return
	end
	CS:AddTag(workspace.CurrentCamera, "GUIOccupied")
	Plr.Character.Archivable = true
	CharClone = Plr.Character:Clone()
	CharClone.Name = "_UIClone" .. Plr.Name
	Plr.Character.Archivable = false
	for _, Part in pairs(CharClone:GetDescendants()) do
		if Part:IsA("BasePart") then
			Part.Anchored = true
		end
	end
	CharClone:SetPrimaryPartCFrame(CharPart.CFrame)
	if NewLoadout.Armor.Armor then
		GiveArmor(NewLoadout.Armor.Armor)
	end
	if NewLoadout.Armor.Helmet then
		GiveHelmet(NewLoadout.Armor.Helmet)
	end
	if NewLoadout.Armor.Clothing then
		local TheClothe = Permitted.Armor.Clothing[NewLoadout.Armor.Clothing]
		if not TheClothe or TheClothe == "None" then
			RevertClothing()
		else
			SetClothing(TheClothe.Shirt, TheClothe.Pants, TheClothe.TShirt)
		end
	end
	CharClone.Parent = Cam
	wait(0.5)
	Cam.CameraType = Enum.CameraType.Scriptable
	Cam.CFrame = CamPart.CFrame
	ToolsPane.Visible = true
	ArmorPane.Visible = true
	ToolOrderPane.Visible = true
	wait(0.5)
	Moving = false
	Visible = true
end
local function ToggleOff()
	if Moving then
		return
	end
	Moving = true
	if Changed then
		Func:InvokeServer("SetLoadout", SendData())
	end
	Changed = false
	BlurInTween:Play()
	Sound:Play("Close")
	wait(0.5)
	if CS:HasTag(workspace.CurrentCamera, "GUIOccupied") then
		CS:RemoveTag(workspace.CurrentCamera, "GUIOccupied")
	end
	if CharClone then
		CharClone:Destroy()
		CharClone = nil
	end
	ToolsPane.Visible = false
	ArmorPane.Visible = false
	ToolOrderPane.Visible = false
	Cam.CameraType = Enum.CameraType.Custom
	Bloom.Parent = script
	wait(0.5)
	if Background then
		Background:Destroy()
		Background = nil
	end
	Moving = false
	Visible = false
end
local function OnPress(Name, State, Obj)
	if State == Enum.UserInputState.Begin then
		if Visible then
			ToggleOff()
		else
			ToggleOn()
		end
	end
end
local ToolsList = DualListDisplay.new(ToolsPane, "Tools")
local ArmorList = DualListDisplay.new(ArmorPane, "Armor")
local ToolSort = ArrangeList.new(ToolOrderList, CurrentLoadout.Tools)
Plr.Character:WaitForChild("Humanoid").Died:Connect(function()
	CAS:UnbindAction("LoadoutMenu")
	if Visible then
		ToggleOff()
	end
end)
CAS:BindAction("LoadoutMenu", OnPress, false, Enum.KeyCode.N)
CP:PreloadAsync(SoundRoot:GetChildren())
]]></ProtectedString><string name="Name">UIScript</string><bool name="Disabled">true</bool></Properties></Item></Item><Item class="Folder" referent="RBX477"><Properties><string name="Name">PianoGui</string></Properties><Item class="LocalScript" referent="RBX480"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

Gui = script.Parent
Player = game.Players.LocalPlayer
PlayingEnabled = false
ScriptReady = false
PianoId = nil
Connector = game.Workspace:FindFirstChild("GlobalPianoConnector")
function Receive(action, ...)
	local args = {
		...
	}
	if not ScriptReady then
		return
	end
	if action == "activate" then
		if not PlayingEnabled then
			Activate(args[1], args[2])
		end
	elseif action == "deactivate" then
		if PlayingEnabled then
			Deactivate()
		end
	elseif action == "play" and Player ~= args[1] then
		PlayNoteServer(args[2], args[3], args[4], args[5])
	end
end
function Activate(cameraCFrame, sounds)
	PlayingEnabled = true
	MakeHumanoidConnections()
	MakeKeyboardConnections()
	MakeGuiConnections()
	SetCamera(cameraCFrame)
	SetSounds(sounds)
	ShowPiano()
end
function Deactivate()
	PlayingEnabled = false
	BreakHumanoidConnections()
	BreakKeyboardConnections()
	BreakGuiConnections()
	HidePiano()
	HideSheets()
	ReturnCamera()
	Jump()
end
function PlayNoteClient(note)
	PlayNoteSound(note)
	HighlightPianoKey(note)
	Connector:FireServer("play", note)
end
function PlayNoteServer(note, point, range)
	PlayNoteSound(note, point, range)
end
function Abort()
	Connector:FireServer("abort")
end
Connector.OnClientEvent:connect(Receive)
InputService = game:GetService("UserInputService")
Mouse = Player:GetMouse()
TextBoxFocused = false
FocusLost = false
ShiftLock = false
function LetterToNote(key, shift)
	local letterNoteMap = "1!2@34$5%6^78*9(0qQwWeErtTyYuiIoOpPasSdDfgGhHjJklLzZxcCvVbBnm"
	local capitalNumberMap = ")!@#$%^&*("
	local letter = string.char(key)
	if shift then
		if tonumber(letter) then
			letter = string.sub(capitalNumberMap, tonumber(letter) + 1, tonumber(letter) + 1)
		else
			letter = string.upper(letter)
		end
	end
	local note = string.find(letterNoteMap, letter, 1, true)
	if note then
		return note
	end
end
function KeyDown(Object)
	if TextBoxFocused then
		return
	end
	local key = Object.KeyCode.Value
	local shift = (InputService:IsKeyDown(303) or InputService:IsKeyDown(304)) == not ShiftLock
	if key >= 97 and key <= 122 or key >= 48 and key <= 57 then
		local note = LetterToNote(key, shift)
		if note then
			PlayNoteClient(note)
		end
	elseif key == 8 then
		Deactivate()
	elseif key == 32 then
		ToggleSheets()
	elseif key == 13 then
		ToggleCaps()
	end
end
function Input(Object)
	local type = Object.UserInputType.Name
	local state = Object.UserInputState.Name
	if type == "Keyboard" and state == "Begin" then
		if FocusLost then
			FocusLost = false
			return
		end
		KeyDown(Object)
	end
end
function TextFocus()
	TextBoxFocused = true
end
function TextUnfocus()
	FocusLost = true
	TextBoxFocused = false
end
KeyboardConnection = nil
JumpConnection = nil
FocusConnection = InputService.TextBoxFocused:connect(TextFocus)
UnfocusConnection = InputService.TextBoxFocusReleased:connect(TextUnfocus)
function MakeKeyboardConnections()
	KeyboardConnection = InputService.InputBegan:connect(Input)
end
function BreakKeyboardConnections()
	KeyboardConnection:disconnect()
end
PianoGui = Gui.PianoGui
SheetsGui = Gui.SheetsGui
SheetsVisible = false
function ShowPiano()
	PianoGui:TweenPosition(UDim2.new(0.5, -380, 1, -220), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.5, true)
end
function HidePiano()
	PianoGui:TweenPosition(UDim2.new(0.5, -380, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.5, true)
end
function ShowSheets()
	SheetsGui:TweenPosition(UDim2.new(0.5, -200, 1, -520), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.5, true)
end
function HideSheets()
	SheetsGui:TweenPosition(UDim2.new(0.5, -200, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.5, true)
end
function ToggleSheets()
	SheetsVisible = not SheetsVisible
	if SheetsVisible then
		ShowSheets()
	else
		HideSheets()
	end
end
function IsBlack(note)
	if note % 12 == 2 or note % 12 == 4 or note % 12 == 7 or note % 12 == 9 or note % 12 == 11 then
		return true
	end
end
function HighlightPianoKey(note)
	local keyGui = PianoGui.Keys[note]
	if IsBlack(note) then
		keyGui.BackgroundColor3 = Color3.new(0.19607843137254902, 0.19607843137254902, 0.19607843137254902)
	else
		keyGui.BackgroundColor3 = Color3.new(0.7843137254901961, 0.7843137254901961, 0.7843137254901961)
	end
	delay(0.5, function()
		RestorePianoKey(note)
	end)
end
function RestorePianoKey(note)
	local keyGui = PianoGui.Keys[note]
	if IsBlack(note) then
		keyGui.BackgroundColor3 = Color3.new(0, 0, 0)
	else
		keyGui.BackgroundColor3 = Color3.new(1, 1, 1)
	end
end
function PianoKeyPressed(Object, note)
	local type = Object.UserInputType.Name
	if type == "MouseButton1" or type == "Touch" then
		PlayNoteClient(note)
	end
end
function ExitButtonPressed(Object)
	local type = Object.UserInputType.Name
	if type == "MouseButton1" or type == "Touch" then
		Deactivate()
	end
end
function SheetsButtonPressed(Object)
	local type = Object.UserInputType.Name
	if type == "MouseButton1" or type == "Touch" then
		ToggleSheets()
	end
end
function SheetsEdited(property)
	if property == "Text" then
		local bounds = SheetsGui.Sheet.ScrollingFrame.TextBox.TextBounds
		SheetsGui.Sheet.ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, math.max(14, bounds.Y))
	end
end
function ToggleCaps()
	ShiftLock = not ShiftLock
	if ShiftLock then
		PianoGui.CapsButton.BackgroundColor3 = Color3.new(1, 0.6666666666666666, 0)
		PianoGui.CapsButton.BorderColor3 = Color3.new(0.6039215686274509, 0.403921568627451, 0)
		PianoGui.CapsButton.TextColor3 = Color3.new(1, 1, 1)
	else
		PianoGui.CapsButton.BackgroundColor3 = Color3.new(0.5490196078431373, 0.5490196078431373, 0.5490196078431373)
		PianoGui.CapsButton.BorderColor3 = Color3.new(0.26666666666666666, 0.26666666666666666, 0.26666666666666666)
		PianoGui.CapsButton.TextColor3 = Color3.new(0.7058823529411765, 0.7058823529411765, 0.7058823529411765)
	end
end
function CapsButtonPressed(Object)
	local type = Object.UserInputType.Name
	if type == "MouseButton1" or type == "Touch" then
		ToggleCaps()
	end
end
PianoKeysConnections = {}
ExitButtonConnection = nil
SheetsButtonConnection = nil
SheetsEditedConnection = nil
CapsButtonConnection = nil
function MakeGuiConnections()
	for i, v in pairs(PianoGui.Keys:GetChildren()) do
		PianoKeysConnections[i] = v.InputBegan:connect(function(Object)
			PianoKeyPressed(Object, tonumber(v.Name))
		end)
	end
	ExitButtonConnection = PianoGui.ExitButton.InputBegan:connect(ExitButtonPressed)
	SheetsButtonConnection = PianoGui.SheetsButton.InputBegan:connect(SheetsButtonPressed)
	SheetsEditedConnection = SheetsGui.Sheet.ScrollingFrame.TextBox.Changed:connect(SheetsEdited)
	CapsButtonConnection = PianoGui.CapsButton.InputBegan:connect(CapsButtonPressed)
end
function BreakGuiConnections()
	for i, v in pairs(PianoKeysConnections) do
		v:disconnect()
	end
	ExitButtonConnection:disconnect()
	SheetsButtonConnection:disconnect()
	SheetsEditedConnection:disconnect()
	CapsButtonConnection:disconnect()
end
ContentProvider = game:GetService("ContentProvider")
LocalSounds = {
	"233836579",
	"233844049",
	"233845680",
	"233852841",
	"233854135",
	"233856105"
}
SoundFolder = Gui.SoundFolder
ExistingSounds = {}
function PreloadAudio(sounds)
	for i, v in pairs(sounds) do
		ContentProvider:Preload("rbxassetid://" .. v)
	end
end
function SetSounds(sounds)
	PreloadAudio(sounds)
	LocalSounds = sounds
end
function PlayNoteSound(note, source, range, sounds)
	local SoundList = sounds or LocalSounds
	local note2 = (note - 1) % 12 + 1
	local octave = math.ceil(note / 12)
	local sound = math.ceil(note2 / 2)
	local offset = 16 * (octave - 1) + 8 * (1 - note2 % 2)
	local audio = Instance.new("Sound", SoundFolder)
	audio.SoundId = "rbxassetid://" .. SoundList[sound]
	if source then
		local a = 1 / range ^ 2
		local distance = (game.Workspace.CurrentCamera.CoordinateFrame.p - source).magnitude
		local volume = -a * distance ^ 2 + 1
		if volume < 0.05 then
			audio:remove()
			return
		end
		audio.Volume = volume
	end
	audio.TimePosition = offset + (octave - 0.9) / 15
	audio:Play()
	table.insert(ExistingSounds, 1, audio)
	if #ExistingSounds >= 10 then
		ExistingSounds[10]:Stop()
		ExistingSounds[10] = nil
	end
	delay(4, function()
		audio:Stop()
		audio:remove()
	end)
end
Camera = game.Workspace.CurrentCamera
function Jump()
	local character = Player.Character
	if character then
		local humanoid = character:FindFirstChild("Humanoid")
		if humanoid then
			humanoid.Jump = true
		end
	end
end
function HumanoidChanged(humanoid, property)
	if property == "Jump" then
		humanoid.Jump = false
	elseif property == "Sit" then
		humanoid.Sit = true
	elseif property == "Parent" then
		Deactivate()
		Abort()
	end
end
function HumanoidDied()
	Deactivate()
end
function SetCamera(cframe)
	Camera.CameraType = Enum.CameraType.Scriptable
	Camera:Interpolate(cframe, cframe + cframe.lookVector, 0.5)
end
function ReturnCamera()
	Camera.CameraType = Enum.CameraType.Custom
end
HumanoidChangedConnection = nil
HumanoidDiedConnection = nil
function MakeHumanoidConnections()
	local character = Player.Character
	if character then
		do
			local humanoid = character:FindFirstChild("Humanoid")
			if humanoid then
				HumanoidChangedConnection = humanoid.Changed:connect(function(property)
					HumanoidChanged(humanoid, property)
				end)
				HumanoidDiedConnection = humanoid.Died:connect(HumanoidDied)
			end
		end
	end
end
function BreakHumanoidConnections()
	HumanoidChangedConnection:disconnect()
	HumanoidDiedConnection:disconnect()
end
ScriptReady = true
]]></ProtectedString><string name="Name">Main</string></Properties></Item></Item><Item class="LocalScript" referent="RBX486"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local BulletModule = {}
BulletModule.Bullets = {}
BulletModule.StepSpeed = 1
local Trail, Light = script:WaitForChild("Trail"), script:WaitForChild("PointLight")
function BulletModule.new(BulletSettings, ReturnFunction)
	local OriginPart = Instance.new("Part")
	OriginPart.Size, OriginPart.CFrame, OriginPart.Transparency, OriginPart.CanCollide, OriginPart.Anchored = Vector3.new(0.05, 0.05, 0.05), CFrame.new(BulletSettings.OriginPos, BulletSettings.DirectionPos), 1, false, true
	OriginPart.Parent = workspace
	local Attach1, Attach2, Attach3, Attach4 = Instance.new("Attachment"), Instance.new("Attachment")
	Attach1.Parent, Attach2.Parent = OriginPart, OriginPart
	local EffectA, EffectB = Trail:Clone(), Trail:Clone()
	EffectA.Color = ColorSequence.new(BulletSettings.BulletColorA)
	EffectA.Parent = OriginPart
	EffectA.Attachment0, EffectA.Attachment1 = Attach1, Attach2
	local light = Light:Clone()
	light.Parent = Attach1
	if BulletSettings.BulletColorB then
		Attach3, Attach4 = Instance.new("Attachment"), Instance.new("Attachment")
		Attach3.Parent, Attach4.Parent = OriginPart, OriginPart
		EffectB = script.Trail:Clone()
		EffectB.Color = ColorSequence.new(BulletSettings.BulletColorB)
		EffectB.Attachment0, EffectB.Attachment1 = Attach3, Attach4
		EffectB.Parent = OriginPart
	end
	spawn(function()
		local Hit, virtualCF, Counter, Ignore = false, CFrame.new(), 0, BulletSettings.IgnoreList
		local deltaTime = 0.016666666666666666
		for i = 1, 100 do
			if not Hit then
				if Counter >= 100 then
					OriginPart:Destroy()
					return
				end
				local displacement = deltaTime / 0.01 * (deltaTime / 0.01 * 25)
				displacement = (0.25 + math.min(Counter, 2) / 2 * 0.75) * displacement
				local vCF = OriginPart.CFrame * virtualCF
				local bRay = Ray.new(vCF.p, (vCF.p - (vCF * CFrame.new(0, 0, 10)).p).unit * displacement)
				local hit, hitp = workspace:FindPartOnRayWithIgnoreList(bRay, Ignore)
				if hit and hit.Transparency ~= 1 then
					Hit = true
					ReturnFunction(hit, hitp)
					delay(0.1, function()
						light:Destroy()
						EffectA:Destroy()
						Attach1:Destroy()
						Attach2:Destroy()
						if EffectB then
							EffectB:Destroy()
							Attach3:Destroy()
							Attach4:Destroy()
						end
						OriginPart:Destroy()
						Hit, virtualCF, Counter, Ignore, deltaTime = nil, nil, nil, nil, nil
					end)
					virtualCF = OriginPart.CFrame:inverse() * CFrame.new(hitp)
					break
				else
					virtualCF = virtualCF * CFrame.new(0, 0, -displacement)
				end
				if Attach3 then
					Attach3.CFrame = virtualCF * CFrame.new(-0.2, 0, 0)
					Attach4.CFrame = virtualCF * CFrame.new(0.2, 0, 0)
					EffectB.Lifetime = 0.01
				end
				Attach1.CFrame = virtualCF * CFrame.new(-0.1, 0, 0)
				Attach2.CFrame = virtualCF * CFrame.new(0.1, 0, 0)
				EffectA.Lifetime = 0.01
				Counter = Counter + 1
			end
			game:GetService("RunService").RenderStepped:wait(deltaTime)
		end
	end)
end
wait(1)
shared.BulletModule = BulletModule
]]></ProtectedString><string name="Name">BulletRender</string></Properties></Item><Item class="Folder" referent="RBX491"><Properties><string name="Name">MenuUI</string></Properties><Item class="LocalScript" referent="RBX494"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

wait()
local Player = game:GetService("Players").LocalPlayer
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local NetworkEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("MenuEvent")
local NetworkFunction = ReplicatedStorage:WaitForChild("Functions"):WaitForChild("TeamRequest")
local Blur, Color = script:WaitForChild("Blur"), script:WaitForChild("ColorCorrection")
local VisionTag = "AnomalousVision"
Blur.Parent = workspace.CurrentCamera
Color.Parent = workspace.CurrentCamera
local GUI = script.Parent
GUI.ShowFrame.Visible = true
local GetShortenedTeamName = function(TeamName)
	local Output = ""
	for v in TeamName:gmatch("[^%s]+") do
		Output = Output .. v:sub(1, 1)
	end
	return Output
end
local Buttons, UpdateLog, XboxTips, Teams = GUI:WaitForChild("Buttons"), GUI:WaitForChild("UpdateLog"), GUI:WaitForChild("XboxTips"), GUI:WaitForChild("Teams")
local Cache = {TweeningMenu = false, CurrentMenu = "Home"}
local MenuVisible = false
Player:WaitForChild("PlayerGui"):SetTopbarTransparency(0)
local PlayerTeams = NetworkFunction:InvokeServer("GetPermittedTeams")
GUI.ShowFrame:WaitForChild("ServerWait").Visible = false
if PlayerTeams then
	local PT = {}
	for i, v in pairs(PlayerTeams) do
		PT[i] = {
			Name = v.Name,
			TeamShort = v.ShortHand or GetShortenedTeamName(v.Name),
			TeamColor = v.TeamColor.Color,
			Image = v.Image and "rbxassetid://" .. tostring(v.Image) or nil,
			Authorized = v.Authorized
		}
	end
	PlayerTeams = PT
else
	PlayerTeams = {}
end
local MenuFunctions = {
	Play = function()
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
		MenuVisible = false
		TweenMenuOut()
		if GUI.Music.IsPlaying then
			spawn(function()
				for i = 1, 50 do
					GUI.Music.Volume = 0.4 - 0.4 * (i / 50)
					wait()
				end
				GUI.Music:Stop()
			end)
		end
		workspace.CurrentCamera.CameraType = "Custom"
		workspace.CurrentCamera.CameraSubject = Player.Character:WaitForChild("Humanoid")
	end,
	Teams = function()
		TweenMenuOut(true)
		delay(0.1, function()
			Teams.Visible = true
			local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
			TweenService:Create(Teams.Title, tweenInfoA, {TextTransparency = 0}):Play()
			TweenService:Create(Teams.Title.TextLabel, tweenInfoA, {TextTransparency = 0}):Play()
			local UnauthedTeams = {}
			local AuthedTeams = {}
			for i, v in pairs(Teams.Frame:GetChildren()) do
				if v:IsA("ImageButton") then
					v:Destroy()
				end
			end
			for i, v in pairs(PlayerTeams) do
				if v.Authorized then
					AuthedTeams[#AuthedTeams + 1] = v
				else
					UnauthedTeams[#UnauthedTeams + 1] = v
				end
			end
			for i, v in pairs(AuthedTeams) do
				do
					local Button = script.TeamTemplate:Clone()
					Button.Parent = Teams.Frame
					Teams.Frame.CanvasSize = Teams.Frame.CanvasSize + UDim2.new(0, 0, 0, 120)
					Button.TeamName.Text = v.TeamShort
					Button.TeamName.TextLabel.Text = v.TeamShort
					if v.Image ~= nil then
						Button.TeamImage.Image = v.Image
						TweenService:Create(Button.TeamImage, tweenInfoA, {ImageTransparency = 0.8}):Play()
					end
					Button.MouseButton1Click:connect(function()
						local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
						TweenService:Create(Teams.Title, tweenInfoA, {TextTransparency = 1}):Play()
						TweenService:Create(Teams.Title.TextLabel, tweenInfoA, {TextTransparency = 1}):Play()
						delay(0.1, function()
							Teams.Visible = false
							NetworkEvent:FireServer("TeamChange", v.Name)
							StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
							StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
						end)
					end)
					TweenService:Create(Button.TeamName, tweenInfoA, {TextTransparency = 0}):Play()
					TweenService:Create(Button.TeamName.TextLabel, tweenInfoA, {TextTransparency = 0}):Play()
					TweenService:Create(Button, tweenInfoA, {ImageTransparency = 0}):Play()
					TweenService:Create(Button.Backing, tweenInfoA, {ImageTransparency = 0}):Play()
					wait(0.05)
				end
			end
			local conn
			conn = Teams.Back.MouseButton1Click:connect(function()
				conn:disconnect()
				Teams.Back.Visible = false
				local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
				TweenService:Create(Teams.Title, tweenInfoA, {TextTransparency = 1}):Play()
				TweenService:Create(Teams.Title.TextLabel, tweenInfoA, {TextTransparency = 1}):Play()
				delay(0.1, function()
					Teams.Visible = false
					Teams.Back.Visible = true
					TweenMenuIn(true)
				end)
			end)
		end)
	end
}
function TweenEffects(InOut)
	spawn(function()
		if CollectionService:HasTag(Player, VisionTag) then
			return
		end
		local TweenGoalA = {}
		TweenGoalA.Size = InOut and 12 or 0
		local tweenInfoA = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		local TweenGoalB = {
			Brightness = InOut and 0.2 or 0,
			Contrast = InOut and 0.6 or 0,
			Saturation = InOut and 1 or 0,
			TintColor = InOut and Color3.fromRGB(147, 147, 147) or Color3.new(1, 1, 1)
		}
		local tweenInfoB = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		TweenService:Create(Blur, tweenInfoA, TweenGoalA):Play()
		TweenService:Create(Color, tweenInfoB, TweenGoalB):Play()
	end)
end
function ListenOnButtons()
	local TheButtons = Buttons:GetChildren()
	local TweenGoalA, TweenGoalB = {
		TextColor3 = Color3.fromRGB(255, 255, 255)
	}, {
		TextColor3 = Color3.fromRGB(93, 93, 93)
	}
	local TextTweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
	for i, v in pairs(TheButtons) do
		v.MouseButton1Click:connect(function()
			if not MenuVisible then
				return
			end
			Cache.CurrentMenu = v.Name
			GUI.Click:Play()
			if MenuFunctions[v.Name] then
				MenuFunctions[v.Name]()
			end
		end)
		v.MouseEnter:connect(function()
			if not MenuVisible then
				return
			end
			if not CollectionService:HasTag(v, "TweeningIn") and not Cache.TweeningMenu then
				TweenService:Create(v, TextTweenInfo, TweenGoalA):Play()
				GUI.Navigate:Play()
				CollectionService:AddTag(v, "TweeningIn")
				delay(0.1, function()
					for e, g in pairs(TheButtons) do
						if not CollectionService:HasTag(g, "TweeningOut") and not CollectionService:HasTag(g, "TweeningIn") and g ~= v then
							CollectionService:AddTag(g, "TweeningOut")
							TweenService:Create(g, TextTweenInfo, TweenGoalB):Play()
							delay(0.1, function()
								CollectionService:RemoveTag(g, "TweeningOut")
							end)
						end
					end
					CollectionService:RemoveTag(v, "TweeningIn")
				end)
				for e, g in pairs(TheButtons) do
					if not CollectionService:HasTag(g, "TweeningIn") and g ~= v then
						CollectionService:AddTag(g, "TweeningOut")
						TweenService:Create(g, TextTweenInfo, TweenGoalB):Play()
						delay(0.1, function()
							CollectionService:RemoveTag(g, "TweeningOut")
						end)
					end
				end
			end
		end)
		v.MouseLeave:connect(function()
			if not MenuVisible then
				return
			end
			if not CollectionService:HasTag(v, "TweeningOut") and not Cache.TweeningMenu then
				for e, g in pairs(TheButtons) do
					if not CollectionService:HasTag(g, "TweeningOut") and g ~= v then
						CollectionService:AddTag(g, "TweeningOut")
						TweenService:Create(g, TextTweenInfo, TweenGoalB):Play()
						delay(0.1, function()
							CollectionService:RemoveTag(g, "TweeningOut")
						end)
					end
				end
			end
		end)
	end
end
function TweenMenuOut(DoEffects)
	if Cache.TweeningMenu then
		return
	end
	if CollectionService:HasTag(workspace.CurrentCamera, "GUIOccupied") then
		CollectionService:RemoveTag(workspace.CurrentCamera, "GUIOccupied")
	end
	local TweenGoalA, TweenGoalB = {
		TextColor3 = Color3.fromRGB(255, 255, 255)
	}, {
		TextColor3 = Color3.fromRGB(93, 93, 93)
	}
	local TextTweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
	Cache.TweeningMenu = true
	if not DoEffects then
		TweenEffects(false)
	end
	GUI.Close:Play()
	XboxTips.Visible = false
	delay(0.1, function()
		local order = {
			[4] = "Play",
			[3] = "Teams",
			[2] = "Credits",
			[1] = "Settings"
		}
		spawn(function()
			for i, v in pairs(Buttons:GetChildren()) do
				local oldPosition = Buttons[order[i]].Position
				local Position = UDim2.new(0.7, -60, 0.3, oldPosition.Y.Offset)
				Buttons[order[i]]:TweenPosition(Position, "Out", "Quad", 0.2, false)
				local TweenGoalA = {}
				TweenGoalA.TextTransparency = 1
				local tweenInfoA = TweenInfo.new(0.13, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
				TweenService:Create(Buttons[order[i]], tweenInfoA, TweenGoalA):Play()
				TweenService:Create(Buttons[order[i]].TextLabel, tweenInfoA, TweenGoalA):Play()
				wait()
			end
		end)
		local TweenGoalA = {}
		TweenGoalA.TextTransparency = 1
		local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		local function recurse(t)
			if t:IsA("TextLabel") then
				TweenService:Create(t, tweenInfoA, TweenGoalA):Play()
			end
			for i, v in pairs(t:GetChildren()) do
				recurse(v)
			end
		end
		local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		local oldPositionA, oldPositionB = UpdateLog.Frame1.Position, UpdateLog.Frame2.Position
		local PositionA, PositionB = UDim2.new(0, 20, 0.3, oldPositionA.Y.Offset + 20), UDim2.new(0, 20, 0.3, oldPositionB.Y.Offset + 20)
		TweenService:Create(UpdateLog.Frame1, tweenInfoA, {BackgroundTransparency = 1, Position = PositionA}):Play()
		TweenService:Create(UpdateLog.Frame2, tweenInfoA, {BackgroundTransparency = 1, Position = PositionB}):Play()
		recurse(UpdateLog)
		for e, g in pairs(Buttons:GetChildren()) do
			if not CollectionService:HasTag(g, "TweeningOut") and g.Name ~= "Play" then
				CollectionService:AddTag(g, "TweeningOut")
				TweenService:Create(g, TextTweenInfo, TweenGoalB):Play()
				delay(0.1, function()
					CollectionService:RemoveTag(g, "TweeningOut")
				end)
			end
		end
		if Cache.CurrentMenu == "Home" then
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		end
		wait(0.2)
		UpdateLog.Visible, Buttons.Visible = false, false
		Buttons.Play.TextColor3 = Color3.new(1, 1, 1)
		Cache.TweeningMenu = false
		if not DoEffects then
			Cache.CurrentMenu = "Home"
			Cache.MenuStatus = false
		end
	end)
end
function TweenMenuIn(DoEffects)
	if Cache.TweeningMenu then
		return
	end
	if CollectionService:HasTag(workspace.CurrentCamera, "GUIOccupied") then
		return
	end
	CollectionService:AddTag(workspace.CurrentCamera, "GUIOccupied")
	MenuVisible = true
	Cache.TweeningMenu = true
	if not DoEffects then
		TweenEffects(true)
	end
	GUI.Open:Play()
	workspace.CurrentCamera.CameraType = "Scriptable"
	local CamPartDir = workspace:WaitForChild("CamParts"):GetChildren()
	workspace.CurrentCamera.CFrame = CamPartDir[math.random(#CamPartDir)].CFrame
	UpdateLog.Visible, Buttons.Visible = true, true
	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
	delay(0.3, function()
		local order = {
			[1] = "Play",
			[2] = "Teams",
			[3] = "Credits",
			[4] = "Settings"
		}
		for i, v in pairs(Buttons:GetChildren()) do
			local oldPosition = Buttons[order[i]].Position
			local Position = UDim2.new(0.7, 0, 0.3, oldPosition.Y.Offset)
			Buttons[order[i]]:TweenPosition(Position, "Out", "Quad", 0.3, false)
			local TweenGoalA = {}
			TweenGoalA.TextTransparency = 0
			local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
			TweenService:Create(Buttons[order[i]], tweenInfoA, TweenGoalA):Play()
			TweenService:Create(Buttons[order[i]].TextLabel, tweenInfoA, TweenGoalA):Play()
			wait(0.05)
		end
		local TweenGoalA = {}
		TweenGoalA.TextTransparency = 0
		local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		local function recurse(t)
			if t:IsA("TextLabel") then
				TweenService:Create(t, tweenInfoA, TweenGoalA):Play()
			end
			for i, v in pairs(t:GetChildren()) do
				recurse(v)
			end
		end
		local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		local oldPositionA, oldPositionB = UpdateLog.Frame1.Position, UpdateLog.Frame2.Position
		local PositionA, PositionB = UDim2.new(0, 20, 0.3, oldPositionA.Y.Offset - 20), UDim2.new(0, 20, 0.3, oldPositionB.Y.Offset - 20)
		TweenService:Create(UpdateLog.Frame1, tweenInfoA, {BackgroundTransparency = 0.9, Position = PositionA}):Play()
		wait(0.1)
		TweenService:Create(UpdateLog.Frame2, tweenInfoA, {BackgroundTransparency = 0.9, Position = PositionB}):Play()
		recurse(UpdateLog)
		if game:GetService("GuiService"):IsTenFootInterface() then
			XboxTips.Visible = true
		end
		Cache.CurrentMenu = "Home"
		wait(0.2)
		Cache.TweeningMenu = false
		Cache.MenuStatus = true
	end)
end
game:GetService("UserInputService").InputBegan:connect(function(IO, GP)
	if GP then
		return
	end
	if IO.KeyCode == Enum.KeyCode.M and Cache.CurrentMenu == "Home" and not Cache.MenuStatus then
		TweenMenuIn()
	else
	end
end)
NetworkEvent.OnClientEvent:Connect(function(Push)
	if Push == "Close" then
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
		MenuVisible = false
		if GUI.Music.IsPlaying then
			spawn(function()
				for i = 1, 50 do
					GUI.Music.Volume = 0.4 - 0.4 * (i / 50)
					wait()
				end
				GUI.Music:Stop()
			end)
		end
		TweenMenuOut()
		workspace.CurrentCamera.CameraType = "Custom"
		workspace.CurrentCamera.CameraSubject = Player.Character:WaitForChild("Humanoid")
	end
end)
local Max = game:GetService("ContentProvider").RequestQueueSize
script.Parent.ShowFrame.SkipButton.MouseButton1Click:Connect(function()
	script.Parent.ShowFrame.Visible = false
end)
script.Parent.ShowFrame.Visible = true
repeat
	wait(0.1)
	local CurrentQueue = game:GetService("ContentProvider").RequestQueueSize
	Max = math.max(Max, CurrentQueue)
	script.Parent.ShowFrame.PercentLoaded.Text = math.floor(CurrentQueue / Max * 100) .. "% Left"
until script.Parent.ShowFrame.Visible == false or 0 >= game:GetService("ContentProvider").RequestQueueSize
Player:WaitForChild("PlayerGui"):SetTopbarTransparency(0.5)
script.Parent.ShowFrame.Visible = false
GUI.Music:Play()
TweenMenuIn()
spawn(ListenOnButtons)
]]></ProtectedString><string name="Name">MenuRunner</string></Properties></Item></Item></Item></Item></Item><Item class="Folder" referent="RBX503"><Properties><string name="Name">StarterPlayer</string></Properties><Item class="Folder" referent="RBX506"><Properties><string name="Name">StarterCharacterScripts</string></Properties><Item class="Folder" referent="RBX509"><Properties><string name="Name">Sound</string></Properties><Item class="LocalScript" referent="RBX512"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local SFX = {
	Died = 0,
	Running = 1,
	Swimming = 2,
	Climbing = 3,
	Jumping = 4,
	GettingUp = 5,
	FreeFalling = 6,
	FallingDown = 7,
	Landing = 8,
	Splash = 9
}
local useUpdatedLocalSoundFlag = UserSettings():IsUserFeatureEnabled("UserFixCharacterSoundIssues")
local Humanoid, Head
local Sounds = {}
local SoundService = game:GetService("SoundService")
local soundEventFolderName = "DefaultSoundEvents"
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local AddCharacterLoadedEvent, RemoveCharacterEvent
local soundEventFolder = ReplicatedStorage:FindFirstChild(soundEventFolderName)
local useSoundDispatcher = UserSettings():IsUserFeatureEnabled("UserUseSoundDispatcher")
if useSoundDispatcher then
	if not soundEventFolder then
		soundEventFolder = Instance.new("Folder", ReplicatedStorage)
		soundEventFolder.Name = soundEventFolderName
		soundEventFolder.Archivable = false
	end
	RemoveCharacterEvent = soundEventFolder:FindFirstChild("RemoveCharacterEvent")
	if RemoveCharacterEvent == nil then
		RemoveCharacterEvent = Instance.new("RemoteEvent", soundEventFolder)
		RemoveCharacterEvent.Name = "RemoveCharacterEvent"
	end
	AddCharacterLoadedEvent = soundEventFolder:FindFirstChild("AddCharacterLoadedEvent")
	if AddCharacterLoadedEvent == nil then
		AddCharacterLoadedEvent = Instance.new("RemoteEvent", soundEventFolder)
		AddCharacterLoadedEvent.Name = "AddCharacterLoadedEvent"
	end
	AddCharacterLoadedEvent:FireServer()
	game.Players.LocalPlayer.CharacterRemoving:connect(function(character)
		RemoveCharacterEvent:FireServer(game.Players.LocalPlayer)
	end)
end
do
	local Figure = script.Parent.Parent
	Head = Figure:WaitForChild("Head")
	while not Humanoid do
		for _, NewHumanoid in pairs(Figure:GetChildren()) do
			if NewHumanoid:IsA("Humanoid") then
				Humanoid = NewHumanoid
				break
			end
		end
		if Humanoid then
			break
		end
		Figure.ChildAdded:wait()
	end
	Sounds[SFX.Died] = Head:WaitForChild("Died")
	Sounds[SFX.Running] = Head:WaitForChild("Running")
	Sounds[SFX.Swimming] = Head:WaitForChild("Swimming")
	Sounds[SFX.Climbing] = Head:WaitForChild("Climbing")
	Sounds[SFX.Jumping] = Head:WaitForChild("Jumping")
	Sounds[SFX.GettingUp] = Head:WaitForChild("GettingUp")
	Sounds[SFX.FreeFalling] = Head:WaitForChild("FreeFalling")
	Sounds[SFX.Landing] = Head:WaitForChild("Landing")
	Sounds[SFX.Splash] = Head:WaitForChild("Splash")
	local DefaultServerSoundEvent
	if useSoundDispatcher then
		DefaultServerSoundEvent = soundEventFolder:FindFirstChild("DefaultServerSoundEvent")
	else
		DefaultServerSoundEvent = game:GetService("ReplicatedStorage"):FindFirstChild("DefaultServerSoundEvent")
	end
	if DefaultServerSoundEvent then
		DefaultServerSoundEvent.OnClientEvent:connect(function(sound, playing, resetPosition)
			if resetPosition and sound.TimePosition ~= 0 then
				sound.TimePosition = 0
			end
			if sound.IsPlaying ~= playing then
				sound.Playing = playing
			end
		end)
	end
end
local function IsSoundFilteringEnabled()
	return game.Workspace.FilteringEnabled and SoundService.RespectFilteringEnabled
end
local Util
Util = {
	YForLineGivenXAndTwoPts = function(x, pt1x, pt1y, pt2x, pt2y)
		local m = (pt1y - pt2y) / (pt1x - pt2x)
		local b = pt1y - m * pt1x
		return m * x + b
	end,
	Clamp = function(val, min, max)
		return math.min(max, math.max(min, val))
	end,
	HorizontalSpeed = function(Head)
		local hVel = Head.Velocity + Vector3.new(0, -Head.Velocity.Y, 0)
		return hVel.magnitude
	end,
	VerticalSpeed = function(Head)
		return math.abs(Head.Velocity.Y)
	end,
	Play = function(sound)
		if IsSoundFilteringEnabled() then
			sound.CharacterSoundEvent:FireServer(true, true)
		end
		if sound.TimePosition ~= 0 then
			sound.TimePosition = 0
		end
		if not sound.IsPlaying then
			sound.Playing = true
		end
	end,
	Pause = function(sound)
		if IsSoundFilteringEnabled() then
			sound.CharacterSoundEvent:FireServer(false, false)
		end
		if sound.IsPlaying then
			sound.Playing = false
		end
	end,
	Resume = function(sound)
		if IsSoundFilteringEnabled() then
			sound.CharacterSoundEvent:FireServer(true, false)
		end
		if not sound.IsPlaying then
			sound.Playing = true
		end
	end,
	Stop = function(sound)
		if IsSoundFilteringEnabled() then
			sound.CharacterSoundEvent:FireServer(false, true)
		end
		if sound.IsPlaying then
			sound.Playing = false
		end
		if sound.TimePosition ~= 0 then
			sound.TimePosition = 0
		end
	end
}
do
	local playingLoopedSounds = {}
	local activeState
	local fallSpeed = 0
	function setSoundInPlayingLoopedSounds(sound)
		for i = 1, #playingLoopedSounds do
			if playingLoopedSounds[i] == sound then
				return
			end
		end
		table.insert(playingLoopedSounds, sound)
	end
	function stopPlayingLoopedSoundsExcept(except)
		for i = #playingLoopedSounds, 1, -1 do
			if playingLoopedSounds[i] ~= except then
				Util.Pause(playingLoopedSounds[i])
				table.remove(playingLoopedSounds, i)
			end
		end
	end
	local stateUpdateHandler = {
		[Enum.HumanoidStateType.Dead] = function()
			stopPlayingLoopedSoundsExcept()
			local sound = Sounds[SFX.Died]
			Util.Play(sound)
		end,
		[Enum.HumanoidStateType.RunningNoPhysics] = function(speed)
			stateUpdated(Enum.HumanoidStateType.Running, speed)
		end,
		[Enum.HumanoidStateType.Running] = function(speed)
			local sound = Sounds[SFX.Running]
			stopPlayingLoopedSoundsExcept(sound)
			if useUpdatedLocalSoundFlag and activeState == Enum.HumanoidStateType.Freefall and fallSpeed > 0.1 then
				local vol = math.min(1, math.max(0, (fallSpeed - 50) / 110))
				local freeFallSound = Sounds[SFX.FreeFalling]
				freeFallSound.Volume = vol
				Util.Play(freeFallSound)
				fallSpeed = 0
			end
			if useUpdatedLocalSoundFlag then
				if speed ~= nil and speed > 0.5 then
					Util.Resume(sound)
					setSoundInPlayingLoopedSounds(sound)
				elseif speed ~= nil then
					stopPlayingLoopedSoundsExcept()
				end
			elseif 0.5 < Util.HorizontalSpeed(Head) then
				Util.Resume(sound)
				setSoundInPlayingLoopedSounds(sound)
			else
				stopPlayingLoopedSoundsExcept()
			end
		end,
		[Enum.HumanoidStateType.Swimming] = function(speed)
			local threshold
			if useUpdatedLocalSoundFlag then
				threshold = speed
			else
				threshold = Util.VerticalSpeed(Head)
			end
			if activeState ~= Enum.HumanoidStateType.Swimming and threshold > 0.1 then
				local splashSound = Sounds[SFX.Splash]
				splashSound.Volume = Util.Clamp(Util.YForLineGivenXAndTwoPts(Util.VerticalSpeed(Head), 100, 0.28, 350, 1), 0, 1)
				Util.Play(splashSound)
			end
			local sound = Sounds[SFX.Swimming]
			stopPlayingLoopedSoundsExcept(sound)
			Util.Resume(sound)
			setSoundInPlayingLoopedSounds(sound)
		end,
		[Enum.HumanoidStateType.Climbing] = function(speed)
			local sound = Sounds[SFX.Climbing]
			if useUpdatedLocalSoundFlag then
				if speed ~= nil and math.abs(speed) > 0.1 then
					Util.Resume(sound)
					stopPlayingLoopedSoundsExcept(sound)
				else
					Util.Pause(sound)
					stopPlayingLoopedSoundsExcept(sound)
				end
			elseif 0.1 < Util.VerticalSpeed(Head) then
				Util.Resume(sound)
				stopPlayingLoopedSoundsExcept(sound)
			else
				stopPlayingLoopedSoundsExcept()
			end
			setSoundInPlayingLoopedSounds(sound)
		end,
		[Enum.HumanoidStateType.Jumping] = function()
			if activeState == Enum.HumanoidStateType.Jumping then
				return
			end
			stopPlayingLoopedSoundsExcept()
			local sound = Sounds[SFX.Jumping]
			Util.Play(sound)
		end,
		[Enum.HumanoidStateType.GettingUp] = function()
			stopPlayingLoopedSoundsExcept()
			local sound = Sounds[SFX.GettingUp]
			Util.Play(sound)
		end,
		[Enum.HumanoidStateType.Freefall] = function()
			if activeState == Enum.HumanoidStateType.Freefall then
				return
			end
			local sound = Sounds[SFX.FreeFalling]
			sound.Volume = 0
			stopPlayingLoopedSoundsExcept()
			fallSpeed = math.max(fallSpeed, math.abs(Head.Velocity.y))
		end,
		[Enum.HumanoidStateType.FallingDown] = function()
			stopPlayingLoopedSoundsExcept()
		end,
		[Enum.HumanoidStateType.Landed] = function()
			stopPlayingLoopedSoundsExcept()
			if Util.VerticalSpeed(Head) > 75 then
				local landingSound = Sounds[SFX.Landing]
				landingSound.Volume = Util.Clamp(Util.YForLineGivenXAndTwoPts(Util.VerticalSpeed(Head), 50, 0, 100, 1), 0, 1)
				Util.Play(landingSound)
			end
		end,
		[Enum.HumanoidStateType.Seated] = function()
			stopPlayingLoopedSoundsExcept()
		end
	}
	function stateUpdated(state, speed)
		if stateUpdateHandler[state] ~= nil then
			if useUpdatedLocalSoundFlag and (state == Enum.HumanoidStateType.Running or state == Enum.HumanoidStateType.Climbing or state == Enum.HumanoidStateType.Swimming or state == Enum.HumanoidStateType.RunningNoPhysics) then
				stateUpdateHandler[state](speed)
			else
				stateUpdateHandler[state]()
			end
		end
		activeState = state
	end
	Humanoid.Died:connect(function()
		stateUpdated(Enum.HumanoidStateType.Dead)
	end)
	Humanoid.Running:connect(function(speed)
		stateUpdated(Enum.HumanoidStateType.Running, speed)
	end)
	Humanoid.Swimming:connect(function(speed)
		stateUpdated(Enum.HumanoidStateType.Swimming, speed)
	end)
	Humanoid.Climbing:connect(function(speed)
		stateUpdated(Enum.HumanoidStateType.Climbing, speed)
	end)
	Humanoid.Jumping:connect(function()
		stateUpdated(Enum.HumanoidStateType.Jumping)
	end)
	Humanoid.GettingUp:connect(function()
		stateUpdated(Enum.HumanoidStateType.GettingUp)
	end)
	Humanoid.FreeFalling:connect(function()
		stateUpdated(Enum.HumanoidStateType.Freefall)
	end)
	Humanoid.FallingDown:connect(function()
		stateUpdated(Enum.HumanoidStateType.FallingDown)
	end)
	Humanoid.StateChanged:connect(function(old, new)
		stateUpdated(new)
	end)
	function onUpdate(stepDeltaSeconds, tickSpeedSeconds)
		local stepScale = stepDeltaSeconds / tickSpeedSeconds
		do
			local sound = Sounds[SFX.FreeFalling]
			if activeState == Enum.HumanoidStateType.Freefall then
				if Head.Velocity.Y < 0 and Util.VerticalSpeed(Head) > 75 then
					Util.Resume(sound)
					local ANIMATION_LENGTH_SECONDS = 1.1
					local normalizedIncrement = tickSpeedSeconds / ANIMATION_LENGTH_SECONDS
					sound.Volume = Util.Clamp(sound.Volume + normalizedIncrement * stepScale, 0, 1)
				else
					sound.Volume = 0
				end
			else
				Util.Pause(sound)
			end
		end
		local sound = Sounds[SFX.Running]
		if activeState == Enum.HumanoidStateType.Running and Util.HorizontalSpeed(Head) < 0.5 then
			Util.Pause(sound)
		end
	end
	local lastTick = tick()
	local TICK_SPEED_SECONDS = 0.25
	while true do
		onUpdate(tick() - lastTick, TICK_SPEED_SECONDS)
		lastTick = tick()
		wait(TICK_SPEED_SECONDS)
	end
end
]]></ProtectedString><string name="Name">LocalSound</string><bool name="Disabled">true</bool></Properties></Item></Item><Item class="LocalScript" referent="RBX519"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

function drawline(p0, p1)
	local v = p1 - p0
	local part = Instance.new("Part")
	part.Anchored = true
	part.Size = Vector3.new(0.2, 0.2, v.magnitude)
	part.CFrame = CFrame.new(p0 + v / 2, p1)
	part.TopSurface = Enum.SurfaceType.Smooth
	part.BottomSurface = Enum.SurfaceType.Smooth
	return part
end
function shallowcopy(t)
	local nt = {}
	for k, v in next, t, nil do
		nt[k] = v
	end
	return nt
end
function planeIntersect(point, vector, origin, normal)
	local rpoint = point - origin
	local t = -rpoint:Dot(normal) / vector:Dot(normal)
	return point + t * vector, t
end
function getCorners(cf, size)
	local size, corners = size / 2, {}
	for x = -1, 1, 2 do
		for y = -1, 1, 2 do
			for z = -1, 1, 2 do
				table.insert(corners, (cf * CFrame.new(size * Vector3.new(x, y, z))).p)
			end
		end
	end
	return corners
end
function getAxis(c1, c2)
	local axis = {}
	axis[1] = (c1[2] - c1[1]).unit
	axis[2] = (c1[3] - c1[1]).unit
	axis[3] = (c1[5] - c1[1]).unit
	axis[4] = (c2[2] - c2[1]).unit
	axis[5] = (c2[3] - c2[1]).unit
	axis[6] = (c2[5] - c2[1]).unit
	axis[7] = axis[1]:Cross(axis[4]).unit
	axis[8] = axis[1]:Cross(axis[5]).unit
	axis[9] = axis[1]:Cross(axis[6]).unit
	axis[10] = axis[2]:Cross(axis[4]).unit
	axis[11] = axis[2]:Cross(axis[5]).unit
	axis[12] = axis[2]:Cross(axis[6]).unit
	axis[13] = axis[3]:Cross(axis[4]).unit
	axis[14] = axis[3]:Cross(axis[5]).unit
	axis[15] = axis[3]:Cross(axis[6]).unit
	return axis
end
function testAxis(corners1, corners2, axis, surface)
	if axis.Magnitude == 0 or tostring(axis) == "NAN, NAN, NAN" then
		return true
	end
	local adists, bdists = {}, {}
	for i = 1, 8 do
		table.insert(adists, corners1[i]:Dot(axis))
		table.insert(bdists, corners2[i]:Dot(axis))
	end
	local amax, amin = math.max(unpack(adists)), math.min(unpack(adists))
	local bmax, bmin = math.max(unpack(bdists)), math.min(unpack(bdists))
	local longspan = math.max(amax, bmax) - math.min(amin, bmin)
	local sumspan = amax - amin + bmax - bmin
	local pass, mtv
	if surface then
		pass = longspan <= sumspan
	else
		pass = longspan < sumspan
	end
	if pass then
		local overlap = amax > bmax and -(bmax - amin) or amax - bmin
		mtv = axis * overlap
	end
	return pass, mtv
end
local region = {}
function region.new(cf, size)
	local self = setmetatable({}, {__index = region})
	self.surfaceCountsAsCollision = true
	self.cframe = cf
	self.size = size
	self.planes = {}
	self.corners = getCorners(self.cframe, self.size)
	for _, enum in next, Enum.NormalId:GetEnumItems() do
		local lnormal = Vector3.FromNormalId(enum)
		local wnormal = self.cframe:vectorToWorldSpace(lnormal)
		local distance = (lnormal * self.size / 2).magnitude
		local point = self.cframe.p + wnormal * distance
		table.insert(self.planes, {normal = wnormal, point = point})
	end
	return self
end
function region.fromPart(part)
	return region.new(part.CFrame, part.Size)
end
function region:castPoint(point)
	for _, plane in next, self.planes, nil do
		local relative = point - plane.point
		if self.surfaceCountsAsCollision then
			if relative:Dot(plane.normal) >= 0 then
				return false
			end
		elseif relative:Dot(plane.normal) > 0 then
			return false
		end
	end
	return true
end
function region:castPart(part)
	local corners1 = self.corners
	local corners2 = getCorners(part.CFrame, part.Size)
	local axis, mtvs = getAxis(corners1, corners2), {}
	for i = 1, #axis do
		local intersect, mtv = testAxis(corners1, corners2, axis[i], self.surfaceCountsAsCollision)
		if not intersect then
			return false, Vector3.new()
		end
		if mtv then
			table.insert(mtvs, mtv)
		end
	end
	table.sort(mtvs, function(a, b)
		return a.magnitude < b.magnitude
	end)
	return true, mtvs[1]
end
function region:intersectionPoints(part)
	local intersections = {}
	local corners = getCorners(part.CFrame, part.Size)
	local attach = {
		[corners[1]] = {
			corners[3],
			corners[2],
			corners[5]
		},
		[corners[4]] = {
			corners[3],
			corners[2],
			corners[8]
		},
		[corners[6]] = {
			corners[5],
			corners[2],
			corners[8]
		},
		[corners[7]] = {
			corners[3],
			corners[8],
			corners[5]
		}
	}
	for corner, set in next, attach, nil do
		for _, con in next, set, nil do
			local v = con - corner
			for i, plane in next, self.planes, nil do
				local p, t = planeIntersect(corner, v, plane.point, plane.normal)
				if t >= 0 and t <= 1 then
					local pass = true
					for i2, plane2 in next, self.planes, nil do
						if i2 ~= i then
							local relative = p - plane2.point
							if 0 <= relative:Dot(plane2.normal) then
								pass = false
							end
						end
					end
					if pass then
						table.insert(intersections, p)
					end
				end
			end
		end
	end
	local planes = {}
	for _, enum in next, Enum.NormalId:GetEnumItems() do
		local lnormal = Vector3.FromNormalId(enum)
		local wnormal = part.CFrame:vectorToWorldSpace(lnormal)
		local distance = (lnormal * part.Size / 2).magnitude
		local point = part.CFrame.p + wnormal * distance
		table.insert(planes, {normal = wnormal, point = point})
	end
	local corners = self.corners
	local attach = {
		[corners[1]] = {
			corners[3],
			corners[2],
			corners[5]
		},
		[corners[4]] = {
			corners[3],
			corners[2],
			corners[8]
		},
		[corners[6]] = {
			corners[5],
			corners[2],
			corners[8]
		},
		[corners[7]] = {
			corners[3],
			corners[8],
			corners[5]
		}
	}
	for corner, set in next, attach, nil do
		for _, con in next, set, nil do
			local v = con - corner
			for i, plane in next, planes, nil do
				local p, t = planeIntersect(corner, v, plane.point, plane.normal)
				if t >= 0 and t <= 1 then
					local pass = true
					for i2, plane2 in next, planes, nil do
						if i2 ~= i then
							local relative = p - plane2.point
							if 0 <= relative:Dot(plane2.normal) then
								pass = false
							end
						end
					end
					if pass then
						table.insert(intersections, p)
					end
				end
			end
		end
	end
	return intersections
end
function region:cast(realRegion3, ignore, maxParts)
	local ignore = type(ignore) == "table" and ignore or {ignore}
	local maxParts = maxParts or 20
	local parts = game.Workspace:FindPartsInRegion3WithWhiteList(realRegion3, ignore, maxParts)
	local inRegion = {}
	for _, part in next, parts, nil do
		if self:castPart(part) then
			table.insert(inRegion, part)
		end
	end
	return inRegion
end
local R3LocSize = function(Loc, Size)
	local Min, Max = Loc - Size / 2, Loc + Size / 2
	return Region3.new(Min, Max)
end
spawn(function()
	_G.CanTP = tick()
	local Player = game:GetService("Players").LocalPlayer
	local CS = game:GetService("CollectionService")
	local RS = game:GetService("RunService")
	local SCPF = 2694395
	local Character = Player.Character or Player.CharacterAdded:wait()
	local CheckFunction = game:GetService("ReplicatedStorage"):WaitForChild("Functions"):WaitForChild("SCPTester")
	if Player:GetRankInGroup(SCPF) >= 20 then
		return
	end
	local AlertColorCorrection = script:WaitForChild("ColorCorrection")
	wait(1)
	local SonarEngine = {
		PreviousPosition = Character.Torso.Position,
		PreviousTeleportBackPos = Character.Torso.Position,
		PreviousTeleportTime = tick()
	}
	local MurderEars = function()
		local Oof = script:FindFirstChild("Oof")
		if Oof and Oof:IsA("Sound") then
			Oof.TimePosition = 28.5
			Oof:Resume()
		end
	end
	local Notify = function(Text)
		game:GetService("StarterGui"):SetCore("SendNotification", {
			Title = "ZONAR",
			Text = Text,
			Icon = "rbxassetid://2320603692",
			Duration = 5
		})
	end
	game:GetService("ReplicatedStorage").DescendantRemoving:connect(function(f)
		if f == CheckFunction and Player.Name ~= "SaltWaterPearl" then
			MurderEars()
			Player:Kick([[

[SCPF] To be fair, you need to have a very high IQ to delete the anti-cheat.  Almost high enough to watch Rick and Morty.]])
		end
	end)
	CheckFunction.Changed:connect(function(d)
		if Player.Name ~= "SaltWaterPearl" then
			MurderEars()
			Player:Kick([[

[SCPF] Get kicked thirteen times out of eleven.]])
		end
	end)
	function SonarEngine:FindPlayerOrHumDesc(Part)
		for i, v in pairs(game.Players:GetPlayers()) do
			if Part:IsDescendantOf(v.Character) and v.Character ~= workspace then
				return true
			end
		end
		if Part.Parent:FindFirstChild("Humanoid") or Part.Parent.Parent ~= nil and Part.Parent.Parent:FindFirstChild("Humanoid") then
			return true
		end
	end
	function SonarEngine:CheckInterloperBetweenPoints(pointA, pointB)
		local Raycast = Ray.new(pointA, (pointB - pointA) * 1.2)
		local WL = workspace.CurrentCamera:GetDescendants()
		local Part, Position = workspace:FindPartOnRayWithWhitelist(Raycast, WL, false, true)
		local distance = (pointA - pointB).magnitude
		if Character.Humanoid.Health > 0 and Part and Part.Transparency < 1 and Part.CanCollide and not self:FindPlayerOrHumDesc(Part) then
			do
				local PrevColor = Part.Color
				Part.Color = Color3.new(1, 0, 0)
				delay(0.2, function()
					Part.Color = PrevColor
				end)
				if AlertColorCorrection.Parent == script and tick() - _G.CanTP > 0.1 then
					local CanTPBack = CheckFunction:InvokeServer("Report", "COLLISION")
					if not CanTPBack then
						Notify("COLLISION [R]")
						Character:SetPrimaryPartCFrame(CFrame.new(self.PreviousTeleportBackPos))
						spawn(function()
							AlertColorCorrection.Parent = game.Lighting
							wait(0.5)
							AlertColorCorrection.Parent = script
						end)
					end
				end
			end
		else
		end
	end
	function SonarEngine:CheckWorkspaceDescendantRemoving()
		workspace.Map.DescendantRemoving:connect(function(descendant)
			local parent = descendant.Parent
			if not descendant:IsDescendantOf(Player.Character) and (descendant:IsA("BasePart") or descendant:IsA("UnionOperation")) then
				local Check = CheckFunction:InvokeServer("Check", "Deletion", descendant)
				descendant.Parent = parent
				if not Check and AlertColorCorrection.Parent == script then
					MurderEars()
					CheckFunction:InvokeServer("Report", "ILLEGAL_REMOVAL", descendant)
					spawn(function()
						AlertColorCorrection.Parent = game.Lighting
						wait(0.5)
						AlertColorCorrection.Parent = script
					end)
				end
			end
		end)
		workspace.ExclusionZones.DescendantRemoving:connect(function(descendant)
			local parent = descendant.Parent
			if (descendant:IsA("BasePart") or descendant:IsA("UnionOperation")) and descendant.Anchored then
				local Check = CheckFunction:InvokeServer("Check", "Deletion", descendant)
				descendant.Parent = parent
				if Check == false and AlertColorCorrection.Parent == script then
					MurderEars()
					CheckFunction:InvokeServer("Report", "ILLEGAL_REMOVAL", descendant)
					spawn(function()
						AlertColorCorrection.Parent = game.Lighting
						wait(0.5)
						AlertColorCorrection.Parent = script
					end)
				end
			end
		end)
	end
	local function PreventPartCanCollide(Part)
		if Part:IsA("BasePart") and Part.CanCollide then
			Part:GetPropertyChangedSignal("CanCollide"):Connect(function(v)
				print("Change")
				if not v then
					CheckFunction:InvokeServer("Report", "ILLEGAL_REMOVAL")
				end
			end)
		end
	end
	local function PreventDirCanCollide(Dir)
		for _, Desc in pairs(Dir:GetDescendants()) do
			PreventPartCanCollide(Desc)
		end
		Dir.DescendantAdded:Connect(PreventPartCanCollide)
	end
	PreventDirCanCollide(workspace.Map)
	PreventPartCanCollide(workspace.CurrentCamera)
	function SonarEngine:PreventPartMovement(Dir)
		for _, Desc in pairs(Dir:GetDescendants()) do
			if Desc:IsA("BasePart") then
				Desc:GetPropertyChangedSignal("CFrame"):Connect(function()
					CheckFunction:InvokeServer("Report", "I_HATE_YOU")
				end)
			end
		end
	end
	local function IsNoCollide(Name)
		return Character:FindFirstChild(Name) and not Character[Name].CanCollide or false
	end
	function SonarEngine:CheckRecursion()
		while wait(0.1) do
			local PastPosition, CurrentPosition = self.PreviousPosition, Character.Torso.Position
			if workspace:GetRealPhysicsFPS() > 65 then
				CheckFunction:InvokeServer("Report", "ILLEGAL_FPS")
			end
			if Character.Humanoid.WalkSpeed >= 20 and not Character:FindFirstChildOfClass("Tool") and not CS:HasTag(Character, "AbnormalWalkspeed") then
				CheckFunction:InvokeServer("Report", "ILLEGAL_SPEED")
			elseif Character.Humanoid:GetState() == 11 or Character.Humanoid:GetState() == Enum.HumanoidStateType.StrafingNoPhysics then
				CheckFunction:InvokeServer("Report", "ILLEGAL_STATE")
			end
			if Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Jumping and (IsNoCollide("Head") or IsNoCollide("Torso")) then
				print(Character.Humanoid:GetState())
				CheckFunction:InvokeServer("Report", "ILLEGAL_STATE")
			end
			self.PreviousPosition = CurrentPosition
		end
	end
	Character.Humanoid.Changed:connect(function()
		if Character.Humanoid.Name ~= "Humanoid" and Player.Name ~= "SaltWaterPearl" then
			MurderEars()
			Player:Kick([[

[SCPF] Your humanoid may be gone, but your stupidity will live on forever.]])
		end
	end)
	function CheckFunction.OnClientInvoke(Type, Arg)
		if Type == "CHECK" then
			return math.floor(Arg / 2)
		elseif Type == "KEK" and Player.Name ~= "SaltWaterPearl" then
			Player:Kick([[

[SCPF] You have been Kicked by ZONAR (]] .. Arg .. ")")
			return 0
		end
	end
	SonarEngine:PreventPartMovement(workspace:WaitForChild("Map"):WaitForChild("HOSTILETOOLS"))
	SonarEngine:PreventPartMovement(workspace:WaitForChild("Sectors"):WaitForChild("Sector3"):WaitForChild("SCPs"):WaitForChild("SCP-1162"))
	SonarEngine:CheckWorkspaceDescendantRemoving()
	SonarEngine:CheckRecursion()
end)
local CurrentSector, SoundDB = nil, tick() - 10
local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character or Player.CharacterAdded:wait() or script.Parent
local AmbienceSounds = {
	Sector1A = {
		Id = 227200659,
		Volume = 0.13,
		Pitch = 1
	},
	Sector1B = {
		Id = 227200659,
		Volume = 0.13,
		Pitch = 0.8
	},
	Sector2 = {
		Id = 165784112,
		Volume = 0.28,
		Pitch = 0.6
	},
	Sector3 = {
		Id = 2608648725,
		Volume = 0.25,
		Pitch = 1.4
	},
	Sector4 = {
		Id = 2608661754,
		Volume = 0.2,
		Pitch = 1.5
	},
	SectorX = {
		Id = 411273437,
		Volume = 0.4,
		Pitch = 0.5
	},
	SectorU = {
		Id = 2608674950,
		Volume = 0.22,
		Pitch = 1.8
	},
	["SCP-002"] = {
		Id = 270510109,
		Volume = 1,
		Pitch = 0.5
	},
	["SCP-205"] = {
		Id = 695406620,
		Volume = 1,
		Pitch = 0.9
	},
	Outside = {
		Id = 192935471,
		Volume = 0.28,
		Pitch = 0.75
	},
	["SCP-999"] = {Id = 1838892250, Volume = 0.1},
	SansUndertale = {Id = 316014309, Volume = 1},
	ICH = {Id = 2128524267, Volume = 0.01},
	["5005"] = {Id = 0, Volume = 0},
	Scuddy = {
		Id = 145362046,
		Volume = 0.1,
		Pitch = 0.6
	},
	Meddy = {
		Id = 255256889,
		Volume = 0.2,
		Pitch = 0.9
	},
	Mekhanite = {
		Id = 1192655599,
		Volume = 0.2,
		Pitch = 0.6
	}
}
local Sectors = workspace.Sectors
local Sound = Instance.new("Sound")
Sound.Name = "AmbientEmitter"
Sound.Looped = true
Sound.Parent = Player:WaitForChild("PlayerGui")
_G.Music = Sound
local OriginalV = Instance.new("NumberValue")
OriginalV.Name = "OriginalVolume"
OriginalV.Value = 1
OriginalV.Parent = Sound
function HandleAmbient(Block, Sector)
	Block.Touched:connect(function(Hit)
		if CurrentSector ~= Sector and tick() - SoundDB >= 5 and Hit:IsDescendantOf(Character) then
			SoundDB = tick()
			local CurrentVolume = Sound.Volume
			for i = 1, 60 do
				Sound.Volume = CurrentVolume * (1 - i / 60)
				wait()
			end
			CurrentSector = Sector
			Sound.SoundId = "rbxassetid://" .. tostring(AmbienceSounds[Sector].Id)
			OriginalV.Value = AmbienceSounds[Sector].Volume
			Sound.Volume = AmbienceSounds[Sector].Volume * _G.SCPFMusicVolume
			Sound.PlaybackSpeed = AmbienceSounds[Sector].Pitch or 1
			Sound:Play()
		end
	end)
end
for n, Sector in pairs(Sectors:GetChildren()) do
	if Sector:FindFirstChild("Ambience") then
		for _, AmbientBlock in pairs(Sector.Ambience:GetChildren()) do
			HandleAmbient(AmbientBlock, Sector.Name)
		end
	end
end
HandleAmbient(workspace.Map.SCP999.Ambient, "SCP-999")
HandleAmbient(workspace.Map.Sans1, "SansUndertale")
HandleAmbient(workspace.Map.Sans2, "SansUndertale")
HandleAmbient(workspace.Map.ICH.Ambience, "ICH")
HandleAmbient(workspace.Sectors.SectorU.SCPs["SCP-5005"].sendHere, "5005")
HandleAmbient(workspace.Map:FindFirstChild("ScuddySpawn", true), "Scuddy")
HandleAmbient(workspace.Map.Medbay1, "Meddy")
HandleAmbient(workspace.Map.Medbay2, "Meddy")
HandleAmbient(workspace.Map.CBGAmbient, "Mekhanite")
for _, Ch in pairs(workspace.CurrentCamera:GetChildren()) do
	if Ch:IsA("PostEffect") and Ch.Name ~= "Blur" and Ch.Name ~= "ColorCorrection" then
		Ch:Destroy()
	end
end
local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"
local currentAnim = ""
local currentAnimInstance, currentAnimTrack, currentAnimKeyframeHandler
local currentAnimSpeed = 1
local animTable = {}
local animNames = {
	idle = {
		{
			id = "http://www.roblox.com/asset/?id=180435571",
			weight = 9
		},
		{
			id = "http://www.roblox.com/asset/?id=180435792",
			weight = 1
		}
	},
	walk = {
		{
			id = "http://www.roblox.com/asset/?id=180426354",
			weight = 10
		}
	},
	run = {
		{id = "run.xml", weight = 10}
	},
	jump = {
		{
			id = "http://www.roblox.com/asset/?id=125750702",
			weight = 10
		}
	},
	fall = {
		{
			id = "http://www.roblox.com/asset/?id=180436148",
			weight = 10
		}
	},
	climb = {
		{
			id = "http://www.roblox.com/asset/?id=180436334",
			weight = 10
		}
	},
	sit = {
		{
			id = "http://www.roblox.com/asset/?id=178130996",
			weight = 10
		}
	},
	toolnone = {
		{
			id = "http://www.roblox.com/asset/?id=182393478",
			weight = 10
		}
	},
	toolslash = {
		{
			id = "http://www.roblox.com/asset/?id=129967390",
			weight = 10
		}
	},
	toollunge = {
		{
			id = "http://www.roblox.com/asset/?id=129967478",
			weight = 10
		}
	},
	wave = {
		{
			id = "http://www.roblox.com/asset/?id=128777973",
			weight = 10
		}
	},
	point = {
		{
			id = "http://www.roblox.com/asset/?id=128853357",
			weight = 10
		}
	},
	dance1 = {
		{
			id = "http://www.roblox.com/asset/?id=182435998",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491037",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491065",
			weight = 10
		}
	},
	dance2 = {
		{
			id = "http://www.roblox.com/asset/?id=182436842",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491248",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491277",
			weight = 10
		}
	},
	dance3 = {
		{
			id = "http://www.roblox.com/asset/?id=182436935",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491368",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491423",
			weight = 10
		}
	},
	laugh = {
		{
			id = "http://www.roblox.com/asset/?id=129423131",
			weight = 10
		}
	},
	cheer = {
		{
			id = "http://www.roblox.com/asset/?id=129423030",
			weight = 10
		}
	}
}
local dances = {
	"dance1",
	"dance2",
	"dance3"
}
local emoteNames = {
	wave = false,
	point = false,
	dance1 = true,
	dance2 = true,
	dance3 = true,
	laugh = false,
	cheer = false
}
function configureAnimationSet(name, fileList)
	if animTable[name] ~= nil then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0
	animTable[name].connections = {}
	local config = script:FindFirstChild(name)
	if config ~= nil then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child)
			configureAnimationSet(name, fileList)
		end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child)
			configureAnimationSet(name, fileList)
		end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if childPart:IsA("Animation") then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property)
					configureAnimationSet(name, fileList)
				end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if weightObject == nil then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end
	if animTable[name].count <= 0 then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
end
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if fileList ~= nil then
		configureAnimationSet(child.Name, fileList)
	end
end
script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)
for name, fileList in pairs(animNames) do
	configureAnimationSet(name, fileList)
end
local toolAnim = "None"
local toolAnimTime = 0
local jumpAnimTime = 0
local jumpAnimDuration = 0.3
local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75
function stopAllAnimations()
	local oldAnim = currentAnim
	if emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false then
		oldAnim = "idle"
	end
	currentAnim = ""
	currentAnimInstance = nil
	if currentAnimKeyframeHandler ~= nil then
		currentAnimKeyframeHandler:disconnect()
	end
	if currentAnimTrack ~= nil then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end
function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end
function keyFrameReachedFunc(frameName)
	if frameName == "End" then
		local repeatAnim = currentAnim
		if emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false then
			repeatAnim = "idle"
		end
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end
function playAnimation(animName, transitionTime, humanoid)
	local roll = math.random(1, animTable[animName].totalWeight)
	local origRoll = roll
	local idx = 1
	while roll > animTable[animName][idx].weight do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	local anim = animTable[animName][idx].anim
	if anim ~= currentAnimInstance then
		if currentAnimTrack ~= nil then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end
		currentAnimSpeed = 1
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim
		if currentAnimKeyframeHandler ~= nil then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
	end
end
local toolAnimName = ""
local toolAnimTrack, toolAnimInstance, currentToolAnimKeyframeHandler
function toolKeyFrameReachedFunc(frameName)
	if frameName == "End" then
		playToolAnimation(toolAnimName, 0, Humanoid)
	end
end
function playToolAnimation(animName, transitionTime, humanoid, priority)
	local roll = math.random(1, animTable[animName].totalWeight)
	local origRoll = roll
	local idx = 1
	while roll > animTable[animName][idx].weight do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	local anim = animTable[animName][idx].anim
	if toolAnimInstance ~= anim then
		if toolAnimTrack ~= nil then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			transitionTime = 0
		end
		toolAnimTrack = humanoid:LoadAnimation(anim)
		if priority then
			toolAnimTrack.Priority = priority
		end
		toolAnimTrack:Play(transitionTime)
		toolAnimName = animName
		toolAnimInstance = anim
		currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
	end
end
function stopToolAnimations()
	local oldAnim = toolAnimName
	if currentToolAnimKeyframeHandler ~= nil then
		currentToolAnimKeyframeHandler:disconnect()
	end
	toolAnimName = ""
	toolAnimInstance = nil
	if toolAnimTrack ~= nil then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end
	return oldAnim
end
function onRunning(speed)
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	elseif emoteNames[currentAnim] == nil then
		playAnimation("idle", 0.1, Humanoid)
		pose = "Standing"
	end
end
function onDied()
	pose = "Dead"
end
function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end
function onClimbing(speed)
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12)
	pose = "Climbing"
end
function onGettingUp()
	pose = "GettingUp"
end
function onFreeFall()
	if jumpAnimTime <= 0 then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end
function onFallingDown()
	pose = "FallingDown"
end
function onSeated()
	pose = "Seated"
end
function onPlatformStanding()
	pose = "PlatformStanding"
end
function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end
function getTool()
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then
			return kid
		end
	end
	return nil
end
function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end
function animateTool()
	if toolAnim == "None" then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end
	if toolAnim == "Slash" then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
	if toolAnim == "Lunge" then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end
function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(1.57)
	LeftShoulder:SetDesiredAngle(-1.57)
	RightHip:SetDesiredAngle(1.57)
	LeftHip:SetDesiredAngle(-1.57)
end
local lastTick = 0
function move(time)
	local amplitude = 1
	local frequency = 1
	local deltaTime = time - lastTick
	lastTick = time
	local climbFudge = 0
	local setAngles = false
	if jumpAnimTime > 0 then
		jumpAnimTime = jumpAnimTime - deltaTime
	end
	if pose == "FreeFall" and jumpAnimTime <= 0 then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif pose == "Seated" then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif pose == "Running" then
		playAnimation("walk", 0.1, Humanoid)
	elseif pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding" then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end
	if setAngles then
		local desiredAngle = amplitude * math.sin(time * frequency)
		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)
		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			animStringValueObject.Parent = nil
			toolAnimTime = time + 0.3
		end
		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end
		animateTool()
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif string.sub(msg, 1, 3) == "/e " then
		emote = string.sub(msg, 4)
	elseif string.sub(msg, 1, 7) == "/emote " then
		emote = string.sub(msg, 8)
	end
	if pose == "Standing" and emoteNames[emote] ~= nil then
		playAnimation(emote, 0.1, Humanoid)
	end
end)
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"
while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end
]]></ProtectedString><string name="Name">Animate</string></Properties><Item class="ModuleScript" referent="RBX523"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

function drawline(p0, p1)
	local v = p1 - p0
	local part = Instance.new("Part")
	part.Anchored = true
	part.Size = Vector3.new(0.2, 0.2, v.magnitude)
	part.CFrame = CFrame.new(p0 + v / 2, p1)
	part.TopSurface = Enum.SurfaceType.Smooth
	part.BottomSurface = Enum.SurfaceType.Smooth
	return part
end
function shallowcopy(t)
	local nt = {}
	for k, v in next, t, nil do
		nt[k] = v
	end
	return nt
end
function planeIntersect(point, vector, origin, normal)
	local rpoint = point - origin
	local t = -rpoint:Dot(normal) / vector:Dot(normal)
	return point + t * vector, t
end
function getCorners(cf, size)
	local size, corners = size / 2, {}
	for x = -1, 1, 2 do
		for y = -1, 1, 2 do
			for z = -1, 1, 2 do
				table.insert(corners, (cf * CFrame.new(size * Vector3.new(x, y, z))).p)
			end
		end
	end
	return corners
end
function getAxis(c1, c2)
	local axis = {}
	axis[1] = (c1[2] - c1[1]).unit
	axis[2] = (c1[3] - c1[1]).unit
	axis[3] = (c1[5] - c1[1]).unit
	axis[4] = (c2[2] - c2[1]).unit
	axis[5] = (c2[3] - c2[1]).unit
	axis[6] = (c2[5] - c2[1]).unit
	axis[7] = axis[1]:Cross(axis[4]).unit
	axis[8] = axis[1]:Cross(axis[5]).unit
	axis[9] = axis[1]:Cross(axis[6]).unit
	axis[10] = axis[2]:Cross(axis[4]).unit
	axis[11] = axis[2]:Cross(axis[5]).unit
	axis[12] = axis[2]:Cross(axis[6]).unit
	axis[13] = axis[3]:Cross(axis[4]).unit
	axis[14] = axis[3]:Cross(axis[5]).unit
	axis[15] = axis[3]:Cross(axis[6]).unit
	return axis
end
function testAxis(corners1, corners2, axis, surface)
	if axis.Magnitude == 0 or tostring(axis) == "NAN, NAN, NAN" then
		return true
	end
	local adists, bdists = {}, {}
	for i = 1, 8 do
		table.insert(adists, corners1[i]:Dot(axis))
		table.insert(bdists, corners2[i]:Dot(axis))
	end
	local amax, amin = math.max(unpack(adists)), math.min(unpack(adists))
	local bmax, bmin = math.max(unpack(bdists)), math.min(unpack(bdists))
	local longspan = math.max(amax, bmax) - math.min(amin, bmin)
	local sumspan = amax - amin + bmax - bmin
	local pass, mtv
	if surface then
		pass = longspan <= sumspan
	else
		pass = longspan < sumspan
	end
	if pass then
		local overlap = amax > bmax and -(bmax - amin) or amax - bmin
		mtv = axis * overlap
	end
	return pass, mtv
end
local region = {}
function region.new(cf, size)
	local self = setmetatable({}, {__index = region})
	self.surfaceCountsAsCollision = true
	self.cframe = cf
	self.size = size
	self.planes = {}
	self.corners = getCorners(self.cframe, self.size)
	for _, enum in next, Enum.NormalId:GetEnumItems() do
		local lnormal = Vector3.FromNormalId(enum)
		local wnormal = self.cframe:vectorToWorldSpace(lnormal)
		local distance = (lnormal * self.size / 2).magnitude
		local point = self.cframe.p + wnormal * distance
		table.insert(self.planes, {normal = wnormal, point = point})
	end
	return self
end
function region.fromPart(part)
	return region.new(part.CFrame, part.Size)
end
function region:castPoint(point)
	for _, plane in next, self.planes, nil do
		local relative = point - plane.point
		if self.surfaceCountsAsCollision then
			if relative:Dot(plane.normal) >= 0 then
				return false
			end
		elseif relative:Dot(plane.normal) > 0 then
			return false
		end
	end
	return true
end
function region:castPart(part)
	local corners1 = self.corners
	local corners2 = getCorners(part.CFrame, part.Size)
	local axis, mtvs = getAxis(corners1, corners2), {}
	for i = 1, #axis do
		local intersect, mtv = testAxis(corners1, corners2, axis[i], self.surfaceCountsAsCollision)
		if not intersect then
			return false, Vector3.new()
		end
		if mtv then
			table.insert(mtvs, mtv)
		end
	end
	table.sort(mtvs, function(a, b)
		return a.magnitude < b.magnitude
	end)
	return true, mtvs[1]
end
function region:intersectionPoints(part)
	local intersections = {}
	local corners = getCorners(part.CFrame, part.Size)
	local attach = {
		[corners[1]] = {
			corners[3],
			corners[2],
			corners[5]
		},
		[corners[4]] = {
			corners[3],
			corners[2],
			corners[8]
		},
		[corners[6]] = {
			corners[5],
			corners[2],
			corners[8]
		},
		[corners[7]] = {
			corners[3],
			corners[8],
			corners[5]
		}
	}
	for corner, set in next, attach, nil do
		for _, con in next, set, nil do
			local v = con - corner
			for i, plane in next, self.planes, nil do
				local p, t = planeIntersect(corner, v, plane.point, plane.normal)
				if t >= 0 and t <= 1 then
					local pass = true
					for i2, plane2 in next, self.planes, nil do
						if i2 ~= i then
							local relative = p - plane2.point
							if 0 <= relative:Dot(plane2.normal) then
								pass = false
							end
						end
					end
					if pass then
						table.insert(intersections, p)
					end
				end
			end
		end
	end
	local planes = {}
	for _, enum in next, Enum.NormalId:GetEnumItems() do
		local lnormal = Vector3.FromNormalId(enum)
		local wnormal = part.CFrame:vectorToWorldSpace(lnormal)
		local distance = (lnormal * part.Size / 2).magnitude
		local point = part.CFrame.p + wnormal * distance
		table.insert(planes, {normal = wnormal, point = point})
	end
	local corners = self.corners
	local attach = {
		[corners[1]] = {
			corners[3],
			corners[2],
			corners[5]
		},
		[corners[4]] = {
			corners[3],
			corners[2],
			corners[8]
		},
		[corners[6]] = {
			corners[5],
			corners[2],
			corners[8]
		},
		[corners[7]] = {
			corners[3],
			corners[8],
			corners[5]
		}
	}
	for corner, set in next, attach, nil do
		for _, con in next, set, nil do
			local v = con - corner
			for i, plane in next, planes, nil do
				local p, t = planeIntersect(corner, v, plane.point, plane.normal)
				if t >= 0 and t <= 1 then
					local pass = true
					for i2, plane2 in next, planes, nil do
						if i2 ~= i then
							local relative = p - plane2.point
							if 0 <= relative:Dot(plane2.normal) then
								pass = false
							end
						end
					end
					if pass then
						table.insert(intersections, p)
					end
				end
			end
		end
	end
	return intersections
end
function region:cast(ignore, maxParts)
	local ignore = type(ignore) == "table" and ignore or {ignore}
	local maxParts = maxParts or 20
	local rmin, rmax = {}, {}
	local copy = shallowcopy(self.corners)
	for _, enum in next, {
		Enum.NormalId.Right,
		Enum.NormalId.Top,
		Enum.NormalId.Back
	}, nil do
		do
			local lnormal = Vector3.FromNormalId(enum)
			table.sort(copy, function(a, b)
				return a:Dot(lnormal) > b:Dot(lnormal)
			end)
			table.insert(rmin, copy[#copy])
			table.insert(rmax, copy[1])
		end
	end
	rmin, rmax = Vector3.new(rmin[1].x, rmin[2].y, rmin[3].z), Vector3.new(rmax[1].x, rmax[2].y, rmax[3].z)
	local realRegion3 = Region3.new(rmin, rmax)
	local parts = game.Workspace:FindPartsInRegion3WithIgnoreList(realRegion3, ignore, maxParts)
	local inRegion = {}
	for _, part in next, parts, nil do
		if self:castPart(part) then
			table.insert(inRegion, part)
		end
	end
	return inRegion
end
return region
]]></ProtectedString><string name="Name">RotatedRegion3</string></Properties></Item></Item></Item><Item class="Folder" referent="RBX530"><Properties><string name="Name">StarterPlayerScripts</string></Properties><Item class="LocalScript" referent="RBX533"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local PlayerModule = require(script.Parent:WaitForChild("PlayerModule"))
]]></ProtectedString><string name="Name">PlayerScriptsLoader</string></Properties></Item><Item class="LocalScript" referent="RBX538"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

for i, v in pairs(script:children()) do
	require(v)
	print("[SCPF]", v.Name, "module loaded.")
end
]]></ProtectedString><string name="Name">Client</string></Properties><Item class="ModuleScript" referent="RBX542"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ControlPanel = {}
local Controls = workspace.Mechanics.Controls
local LightingRoot = workspace.Mechanics.Lights
local PowerEvent = game.ReplicatedStorage:WaitForChild("Events"):WaitForChild("TechEvent")
for _, Light in pairs(LightingRoot:GetDescendants()) do
	if Light:IsA("BasePart") then
		Light:Clone().Parent = Light.Parent
		Light:Destroy()
	end
end
ControlPanel.SectorDefaultLights = {
	S1 = {
		LightColor = BrickColor.new("Pearl").Color,
		SpotColor = BrickColor.new("Pearl").Color
	},
	S2 = {
		LightColor = BrickColor.new("Really blue").Color,
		SpotColor = Color3.fromRGB(175, 221, 255)
	},
	S3 = {
		LightColor = BrickColor.new("Beige").Color,
		SpotColor = BrickColor.new("Beige").Color
	},
	S4 = {
		LightColor = Color3.fromRGB(118, 78, 0),
		SpotColor = Color3.fromRGB(118, 53, 0)
	}
}
ControlPanel.SectorDefaultWalls = {
	Sector1A = {
		BColor3 = Color3.fromRGB(170, 85, 0),
		Material = "Neon"
	},
	Sector1B = {
		BColor3 = Color3.fromRGB(39, 70, 45),
		Material = "Neon"
	},
	Sector2 = {
		BColor3 = Color3.fromRGB(24, 5, 236),
		Material = "Neon"
	},
	Sector3 = {
		BColor3 = Color3.fromRGB(27, 42, 53),
		Material = "Neon"
	},
	Sector4 = {
		BColor3 = Color3.fromRGB(26, 11, 88),
		Material = "Neon"
	}
}
ControlPanel.SectorLightingEnabled = {
	S1 = true,
	S2 = true,
	S3 = true,
	S4 = true
}
ControlPanel.PowerLevel = 4
function ControlPanel:NewData(PowerLevel, SectorLightingEnabled)
	self.PowerLevel = PowerLevel
	self.SectorLightingEnabled = SectorLightingEnabled
end
function ControlPanel:SetSectorSituationLighting(Sector, Color, Material)
	for i, v in pairs(Sector:GetChildren()) do
		if v:IsA("BasePart") then
			v.Color = Color
			v.Material = Material
		end
	end
	if Sector.Name == "S2" then
		workspace.Map.Change.Color = Color
		workspace.Map.Change.Material = Material
	end
end
function ControlPanel:SetSectorLighting(Sector, Value, Brightness, OptionalColorA, OptionalColorB)
	for i, v in pairs(Sector:GetChildren()) do
		if v:IsA("BasePart") and v.Name == "Light" and v:FindFirstChild("SpotLight") then
			if not v:FindFirstChild("OriginalBrightness") then
				local OrigBright = Instance.new("NumberValue")
				OrigBright.Name = "OriginalBrightness"
				OrigBright.Value = v.SpotLight.Brightness
				OrigBright.Parent = v
			end
			local Baseline = v.OriginalBrightness.Value
			v.SpotLight.Enabled = OptionalColorA == nil and Value or OptionalColorA ~= nil
			v.SpotLight.Color = OptionalColorA ~= nil and OptionalColorA or self.SectorDefaultLights[Sector.Name].SpotColor
			v.SpotLight.Brightness = Baseline * Brightness
			v.Color = Value and self.SectorDefaultLights[Sector.Name].LightColor or OptionalColorB ~= nil and OptionalColorB or Color3.new(0, 0, 0)
			v.Material = (OptionalColorA ~= nil or Value) and Enum.Material.Neon.Value or Enum.Material.Glass.Value
		end
	end
end
local function OnLightChange(Type, Arg)
	if Type == "SectorLightingUpdate" then
		ControlPanel:SetSectorLighting(unpack(Arg))
	elseif Type == "SituationLightingUpdate" then
		ControlPanel:SetSectorSituationLighting(unpack(Arg))
	elseif Type == "LightingBulk" then
		ControlPanel:NewData(unpack(Arg))
	end
end
PowerEvent.OnClientEvent:Connect(OnLightChange)
PowerEvent:FireServer()
return function()
	return ControlPanel
end
]]></ProtectedString><string name="Name">TechSystems</string></Properties></Item><Item class="ModuleScript" referent="RBX547"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local RS = game:GetService("RunService")
local CS = game:GetService("CollectionService")
local UserInputService = game:GetService("UserInputService")
local Cam = workspace.CurrentCamera
local Player = game.Players.LocalPlayer
local UI = Player:WaitForChild("PlayerGui"):WaitForChild("AmmoGui")
local Mouse = Player:GetMouse()
local GunScript = {}
local GunRemote = game.ReplicatedStorage:WaitForChild("Events"):WaitForChild("GunEvent")
GunRemote.Name = game:GetService("HttpService"):GenerateGUID(false)
local CurrentGun
local CurrentGunStats = {}
local CachedGunStats = {}
local Hold, Crouch, Run, Reload, Pushback
local Encrypt_Key = 1
local PrevWalkspeed = 16
local CrosshairWidth = 15
local DotCursor = false
local LastShot = tick()
local Shooting = false
local AmmoSound = script:WaitForChild("AmmoPickup")
local AmmoFunc = workspace:WaitForChild("Mechanics"):WaitForChild("AmmoBoxes"):WaitForChild("GetAmmo")
local AmmoTag = "AmmoBox"
local HitSound = script:WaitForChild("HitSound")
local HeadShotSound = script:WaitForChild("HitHead")
local StatsEnabled = false
local NearShots, HitShots = 0, 0
local StatsDumpingFunction = game.ReplicatedStorage:WaitForChild("Functions"):WaitForChild("SendStats")
local Stats_Key = 1
local BulletSounds = {
	"rbxassetid://2303101209",
	"rbxassetid://142082170"
}
local LastSound = 1
local function SendStats(StatName, Data)
	Stats_Key = Stats_Key + math.pi / 5
end
local SCPF = 2694395
local Rank = Player:GetRankInGroup(SCPF)
local Clicks = 0
local Count = 0
local Step = 1
local function ResetCount()
	Step = Step + 1
	if Step % 30 == 0 then
		Step = 1
		Count = 0
	end
end
local function Clicked()
	Count = Count + 1
	if Count >= 6 then
		Player:Kick([[

[SCPF] An attempt was made.]])
	end
end
if Rank < 15 then
	RS:BindToRenderStep("YouTriedSploiterBoy", Enum.RenderPriority.Last.Value, ResetCount)
end
function GunScript:RotateKey()
	Encrypt_Key = Encrypt_Key + math.pi / 100
end
function GunScript:Set(StatName, Value)
	if CurrentGunStats and CurrentGunStats[StatName] then
		if CurrentGunStats[StatName] ~= CachedGunStats[StatName] then
			Player:Kick("[SCPF] Beware... God is watching you.")
		end
		CurrentGunStats[StatName] = Value
		CachedGunStats[StatName] = Value
	end
end
function GunScript:Get(StatName)
	if CurrentGunStats and CurrentGunStats[StatName] then
		if CurrentGunStats[StatName] ~= CachedGunStats[StatName] then
			Player:Kick("[SCPF] If only it was that easy.")
		end
		return CurrentGunStats[StatName]
	end
end
function GunScript:UpdateUI()
	if not CurrentGun then
		UI.Enabled = false
		return
	end
	UI.Enabled = true
	UI.Cursor.Ammo.Text = tostring(CurrentGunStats.Ammo)
	UI.Cursor.GunType.Text = tostring(CurrentGunStats.TotalAmmo)
end
function GunScript:Reload()
	CancelReload = false
	if self:Get("TotalAmmo") <= 0 then
		CurrentGun.Handle.EmptyClip:Play()
		Reloading = false
		return
	end
	if DotCursor then
		UI.Cursor.Ammo.Visible = true
		UI.Cursor.GunType.Visible = true
		delay(CurrentGunStats.ReloadTime + 1, function()
			if DotCursor then
				UI.Cursor.Ammo.Visible = false
				UI.Cursor.GunType.Visible = false
			end
		end)
	end
	local ShotgunLoad = CurrentGunStats.FiringMode and CurrentGunStats.FiringMode[1] == "Shotgun" or nil
	UI.Cursor.Ammo.Text = "RLD..."
	CurrentGun.Handle.ReloadSound:Play()
	Reload:Play()
	wait(self:Get("ReloadTime"))
	if not CancelReload then
		UI.Cursor.Ammo.Text = "RLD..."
		self:Set("TotalAmmo", self:Get("TotalAmmo") + self:Get("Ammo"))
		self:Set("Ammo", 0)
		if CurrentGunStats.TotalAmmo >= CurrentGunStats.ClipSize then
			self:Set("Ammo", self:Get("ClipSize"))
			self:Set("TotalAmmo", self:Get("TotalAmmo") - self:Get("ClipSize"))
		else
			self:Set("Ammo", self:Get("TotalAmmo"))
			self:Set("TotalAmmo", 0)
		end
		CurrentGun.Handle.ReloadSound:Stop()
		self:UpdateUI()
		Reloading = false
	else
		CurrentGun.Handle.ReloadSound:Stop()
		Reloading = false
		self:UpdateUI()
		CancelReload = false
	end
end
function GunScript:ChangeCursor()
	DotCursor = not DotCursor
	if UI:FindFirstChild("Cursor") then
		if DotCursor then
			UI.Cursor.Left.Visible = false
			UI.Cursor.Right.Visible = false
			UI.Cursor.Top.Visible = false
			UI.Cursor.Bottom.Visible = false
			UI.Cursor.Ammo.Visible = false
			UI.Cursor.GunType.Visible = false
			UI.Cursor.Dot.Visible = true
		else
			UI.Cursor.Left.Visible = true
			UI.Cursor.Right.Visible = true
			UI.Cursor.Top.Visible = true
			UI.Cursor.Bottom.Visible = true
			UI.Cursor.Ammo.Visible = true
			UI.Cursor.GunType.Visible = true
			UI.Cursor.Dot.Visible = false
		end
	end
end
local DISTORT_STUDS = 100
local DistortVector = function(D, SpreadX, SpreadY, SpreadZ)
	return Vector3.new(D * SpreadX, D * SpreadY, D * SpreadZ) * (math.random() > 0.5 and -1 or 1)
end
function FireGun(NewRay, Sender, NotPlayer)
	local Part, Pos = workspace:FindPartOnRayWithIgnoreList(NewRay, {
		Sender.Character,
		workspace.GunDebris,
		workspace.Map.GunsIgnore,
		workspace.Doors
	}, false, true)
	return Part, Pos
end
function GunScript:FireGun()
	if Player.Character.Humanoid.Health <= 0 then
		return
	end
	self:Set("Ammo", self:Get("Ammo") - 1)
	local Damage = math.random(self:Get("minDamage"), self:Get("maxDamage"))
	if CrosshairWidth < 80 then
		CrosshairWidth = CrosshairWidth + math.floor(Damage / CurrentGunStats.RecoilDivisor)
	end
	GunScript:UpdateUI()
	Pushback:Play()
	local ShotsFired = {}
	local NumShots = 1
	if CurrentGunStats.FiringMode then
		NumShots = CurrentGunStats.FiringMode.NumBullets or 1
	end
	for i = 1, NumShots do
		local Distortion = DistortVector(CurrentGunStats.Distort or DISTORT_STUDS, (math.random() * 2 - 1) * (CrosshairWidth + (CurrentGunStats.InherentSpread or 0) - 15) / 15, (math.random() * 2 - 1) * (CrosshairWidth + (CurrentGunStats.InherentSpread or 0) - 15) / 15, (math.random() * 2 - 1) * (CrosshairWidth + (CurrentGunStats.InherentSpread or 0) - 15) / 15)
		local NewRay = Ray.new(CurrentGun.BPoint.Position, (Mouse.Hit.p - CurrentGun.BPoint.Position) * 500 + Distortion)
		local Part, Pos = FireGun(NewRay, game.Players.LocalPlayer)
		if Part and Pos then
			local DoDamage = false
			local Chr
			if Part.Parent and Part.Parent:FindFirstChild("Humanoid") then
				Chr = Part.Parent
			else
				for i, v in pairs(game.Players:GetPlayers()) do
					if Part:IsDescendantOf(v.Character) then
						Chr = v.Character
						break
					end
				end
			end
			if Chr then
				local Critical = Chr.Humanoid.Health - Damage <= 0 or Part.Parent == Chr and Chr.Humanoid:GetLimb(Part) == Enum.Limb.Head or Part:FindFirstChild("HatAttachment") or Part:FindFirstAncestor("Helmet")
				UI.Hitmarker.Visible = true
				UI.Hitmarker.ImageColor3 = Critical and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
				HitSound:Play()
				if Critical then
					HeadShotSound:Play()
				end
				delay(0.05, function()
					UI.Hitmarker.Visible = false
				end)
				UI.Hitmarker.Position = UDim2.new(0, Mouse.X - 20, 0, Mouse.Y - 20)
			end
		end
		if DotCursor then
			UI.Cursor.Ammo.Visible = true
			local TBS = self:Get("TimeBetweenShots")
			delay(TBS, function()
				if DotCursor and not Reloading then
					UI.Cursor.Ammo.Visible = false
				end
			end)
		end
		table.insert(ShotsFired, {
			Part,
			Pos,
			NewRay
		})
	end
	GunRemote:FireServer(Encrypt_Key, CurrentGun, ShotsFired)
	self:RotateKey()
end
function GunScript.Equip(Gun)
	Player = game.Players.LocalPlayer
	CurrentGun = Gun
	UI = Player:WaitForChild("PlayerGui"):WaitForChild("AmmoGui")
	CurrentGunStats = require(Gun:FindFirstChild("Settings"))
	CurrentGunStats.avgDamage = (CurrentGunStats.minDamage + CurrentGunStats.maxDamage) / 2
	CurrentGunStats.RecoilDivisor = CurrentGunStats.RecoilDivisor or 3
	for k, v in pairs(CurrentGunStats) do
		CachedGunStats[k] = v
	end
	if not (Hold and Crouch) or not Run then
		Hold, Crouch, Run, Reload, Pushback = Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Idle")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("CrouchH")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Running")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Reload")), Player.Character.Humanoid:LoadAnimation(CurrentGun:WaitForChild("Pushback"))
	end
	GunScript:UpdateUI()
	Hold:Play()
	Equipped = true
	UI.Enabled = true
	UserInputService.MouseIconEnabled = false
end
function GunScript.Unequip()
	UI.Enabled = false
	UserInputService.MouseIconEnabled = true
	Hold:Stop()
	Run:Stop()
	Crouch:Stop()
	Equipped = false
	Player.Character.Humanoid.WalkSpeed = PrevWalkspeed
	Player.Character.Humanoid.CameraOffset = Vector3.new(0, 0, 0)
	Reloading, Firing, Running, Crouching = false, false, false, false
	Mouse.Icon = ""
	CancelReload = true
	CurrentGun = nil
	CurrentGunStats = nil
end
function GunScript.GetAmmo(Box)
	local Debounce = true
	return function(Part)
		if not Part:IsDescendantOf(Player.Character) then
			return
		end
		if not CurrentGunStats then
			return
		end
		if Debounce then
			Debounce = false
			pcall(function()
				if CurrentGunStats and CurrentGunStats.TotalAmmo and CurrentGunStats.AmmoCapacity and CurrentGunStats.TotalAmmo < CurrentGunStats.AmmoCapacity then
					local Difference = (CurrentGunStats.AmmoCapacity - CurrentGunStats.TotalAmmo) / CurrentGunStats.AmmoCapacity
					local Consume = AmmoFunc:InvokeServer(Box, Difference)
					GunScript:Set("TotalAmmo", CurrentGunStats.TotalAmmo + math.min(math.ceil(CurrentGunStats.AmmoCapacity * Consume), CurrentGunStats.AmmoCapacity))
					GunScript:UpdateUI()
					AmmoSound:Play()
				end
			end)
			wait(1)
			Debounce = true
		end
	end
end
local function OnStep()
	if not Equipped then
		return
	end
	local X, Y = Mouse.X, Mouse.Y
	if UI:FindFirstChild("Cursor") then
		UI.Cursor.Position = UDim2.new(0, X, 0, Y)
	end
end
local function ShrinkCrosshair()
	if not Equipped then
		return
	end
	if CrosshairWidth > 15 then
		CrosshairWidth = CrosshairWidth * 0.975
	else
		CrosshairWidth = 15
	end
	if UI:FindFirstChild("Cursor") then
		UI.Cursor.Left.Position = UDim2.new(0, -1 * CrosshairWidth, 0, 0)
		UI.Cursor.Right.Position = UDim2.new(0, CrosshairWidth, 0, 0)
		UI.Cursor.Top.Position = UDim2.new(0, 0, 0, -1 * CrosshairWidth)
		UI.Cursor.Bottom.Position = UDim2.new(0, 0, 0, CrosshairWidth)
	end
end
RS:BindToRenderStep("GunMouseMove", Enum.RenderPriority.Character.Value - 1, OnStep)
RS.Heartbeat:Connect(ShrinkCrosshair)
UserInputService.InputBegan:connect(function(IO, GP)
	if not Equipped or GP then
		return
	end
	if IO.UserInputType == Enum.UserInputType.MouseButton1 then
		if CurrentGunStats.Ammo <= 0 then
			CurrentGun.Handle.EmptyClip:Play()
		end
		if tick() - LastShot >= 0.01 + CurrentGunStats.TimeBetweenShots and CurrentGunStats.Ammo > 0 and not Firing and not Shooting and not Reloading and not Running then
			if CurrentGunStats.RapidFire and (not CurrentGunStats.FiringMode or CurrentGunStats.FiringMode[1] == "Shotgun") and not Firing then
				Firing = true
				Shooting = true
				repeat
					GunScript:FireGun()
					LastShot = tick()
					wait(0.1 + CurrentGunStats.TimeBetweenShots)
				until not Firing or CurrentGunStats.Ammo <= 0
				Shooting = false
				if CurrentGunStats.Ammo <= 0 then
					CurrentGun.Handle.EmptyClip:Play()
				end
			elseif CurrentGunStats.FiringMode and CurrentGunStats.FiringMode[1] == "Burst" then
				Shooting = true
				local Num, Delta = CurrentGunStats.FiringMode.BurstSize, CurrentGunStats.FiringMode.TimeBetweenBullets
				for i = 1, Num do
					GunScript:FireGun()
					wait(0.01 + Delta)
					if CurrentGunStats.Ammo <= 0 then
						break
					end
				end
				LastShot = tick()
				Shooting = false
				if CurrentGunStats.Ammo <= 0 then
					CurrentGun.Handle.EmptyClip:Play()
				end
			else
				GunScript:FireGun()
			end
			Firing = false
			GunScript:UpdateUI()
			LastShot = tick()
		end
	elseif IO.KeyCode == Enum.KeyCode.LeftShift then
		if not Running and Equipped and not Reloading then
			Running = true
			Firing = false
			if not Crouching then
				PrevWalkspeed = Player.Character.Humanoid.WalkSpeed
			else
				Player.Character.Humanoid.WalkSpeed = Player.Character.Humanoid.WalkSpeed * 10
			end
			Crouching = false
			Crouch:Stop()
			Player.Character.Humanoid.CameraOffset = Vector3.new(0, 0, 0)
			Player.Character.Humanoid.WalkSpeed = Player.Character.Humanoid.WalkSpeed * (GunScript:Get("WalkSpeed") / 16)
			Run:Play()
			Hold:Stop()
		end
	elseif IO.KeyCode == Enum.KeyCode.R and not Reloading and not Running and CurrentGunStats.Ammo < CurrentGunStats.ClipSize then
		Reloading = true
		Firing = false
		wait()
		GunScript:Reload()
	elseif IO.KeyCode == Enum.KeyCode.C and not Running then
		Crouching = not Crouching
		if Crouching then
			Crouch:Play()
			PrevWalkspeed = Player.Character.Humanoid.WalkSpeed
			Player.Character.Humanoid.WalkSpeed = Player.Character.Humanoid.WalkSpeed / 10
			Player.Character.Humanoid.CameraOffset = Vector3.new(0, -1, 0)
		else
			Crouch:Stop()
			Player.Character.Humanoid.WalkSpeed = PrevWalkspeed
			Player.Character.Humanoid.CameraOffset = Vector3.new(0, 0, 0)
		end
	elseif IO.KeyCode == Enum.KeyCode.X then
		GunScript:ChangeCursor()
	end
end)
UserInputService.InputEnded:connect(function(IO, GP)
	if not Equipped or GP then
		return
	end
	if IO.UserInputType == Enum.UserInputType.MouseButton1 then
		Firing = false
	elseif IO.KeyCode == Enum.KeyCode.LeftShift and Running then
		Running = false
		Player.Character.Humanoid.WalkSpeed = PrevWalkspeed
		Run:Stop()
		Hold:Play()
		delay(0.1, function()
			Mouse.Icon = "rbxassetid://7380287"
		end)
	end
end)
local MurderEars = function()
	if script:FindFirstChild("Oof") then
		script.Oof:Play()
	end
	if script:FindFirstChild("ColorCorrection") then
		script.ColorCorrection:Clone().Parent = game.Lighting
	end
	if script:FindFirstChild("Bloom") then
		script.Bloom:Clone().Parent = game.Lighting
	end
	wait(3)
end
local ProcessChildren = function(Dir, Func)
	for _, Ch in pairs(Dir:GetChildren()) do
		Func(Ch)
	end
	Dir.ChildAdded:Connect(Func)
end
local function OnChar(Character)
	ProcessChildren(Player.Backpack, function(Child)
		if Child:IsA("Tool") then
			Child:GetPropertyChangedSignal("CanBeDropped"):Connect(function()
				Player:Kick([[

[SCPF]
You didn't drop your tools, but your mother dropped you on the head as a kid.]])
			end)
		end
	end)
	Character:WaitForChild("Humanoid"):UnequipTools()
	ProcessChildren(Character, function(Child)
		Hold, Crouch, Run, Reload = nil, nil, nil, nil
		if Child:IsA("Tool") then
			if Rank < 15 then
				Clicked()
			end
			if Child:FindFirstChild("Settings") then
				GunScript.Equip(Child)
			end
		end
	end)
	Character.ChildRemoved:connect(function(Child)
		if Child:IsA("Tool") and Child == CurrentGun then
			GunScript.Unequip()
		end
		if Child:IsA("Tool") and not Child.CanBeDropped and Child.Parent == workspace then
			MurderEars()
			Player:Kick("[SCPF] I want to shove sparklers into your eye sockets.")
		end
	end)
	if workspace.GunDebris:FindFirstChild(Player.Name) then
		workspace.GunDebris:FindFirstChild(Player.Name):Destroy()
	end
end
Player.CharacterAdded:Connect(OnChar)
Player.CharacterRemoving:Connect(function()
	if Player.Character and Player.Character:FindFirstChild("Humanoid") then
		Player.Character.Humanoid:UnequipTools()
	end
	if CurrentGun then
		GunScript.Unequip()
	end
end)
if Player.Character then
	OnChar(Player.Character)
end
local function EnforceSonar(Chr)
	local Conn, Conn1
	local Sonar = Chr:WaitForChild("Animate")
	if game:GetService("Players"):GetPlayerFromCharacter(Chr):GetRankInGroup(2694395) < 70 then
		Conn = Chr.ChildRemoved:Connect(function(Child)
			wait(0.2)
			if Child == Sonar and Chr:FindFirstChild("Humanoid") and Chr.Humanoid.Health > 0 then
				MurderEars()
				Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
			end
		end)
		Conn2 = Sonar:GetPropertyChangedSignal("Disabled"):Connect(function()
			wait(0.2)
			MurderEars()
			Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
		end)
		Conn1 = Chr:WaitForChild("Humanoid").Died:Connect(function()
			Conn:Disconnect()
			Conn1:Disconnect()
			Conn2:Disconnect()
			Conn, Conn1, Conn2 = nil, nil, nil
		end)
	end
end
for _, Box in pairs(CS:GetTagged(AmmoTag)) do
	local TouchPart = Box:WaitForChild("TouchPart", 5)
	if TouchPart then
		Box.TouchPart.Touched:Connect(GunScript.GetAmmo(Box))
	end
end
CS:GetInstanceAddedSignal(AmmoTag):Connect(function(Box)
	local TouchPart = Box:WaitForChild("TouchPart", 5)
	if TouchPart then
		Box.TouchPart.Touched:Connect(GunScript.GetAmmo(Box))
	end
end)
Player.CharacterAdded:Connect(EnforceSonar)
return nil
]]></ProtectedString><string name="Name">Guns</string></Properties></Item><Item class="ModuleScript" referent="RBX552"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local StarterGui = game:GetService("StarterGui")
local function Notify(Title, Text, Icon, Duration)
	StarterGui:SetCore("SendNotification", {
		Title = Title or "SCPF",
		Text = Text or "_CONTENT",
		Icon = Icon or nil,
		Duration = Duration or 5
	})
end
game:GetService("Players").PlayerAdded:connect(function(Player)
	if Player:GetRankInGroup(2694395) >= 50 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(2694395))
		Notify("SCPF HR Joined", Message, "rbxassetid://764606705", 8)
	end
	if Player:GetRankInGroup(2755639) >= 40 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(2755639))
		Notify("CI HR Joined", Message, "rbxassetid://1056285476", 8)
	end
	if Player:GetRankInGroup(3292065) >= 100 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(3292065))
		Notify("TSH HR Joined", Message, "rbxassetid://1238401889", 8)
	end
	if Player:GetRankInGroup(2896818) >= 13 then
		wait(5)
		local Message = string.format("%s (%s) has entered.", Player.Name, Player:GetRoleInGroup(2896818))
		Notify("GOC HR Joined", Message, "rbxassetid://273197914", 8)
	end
end)
return function()
	return Notify
end
]]></ProtectedString><string name="Name">Notifications</string></Properties></Item><Item class="ModuleScript" referent="RBX557"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local CS = game:GetService("CollectionService")
local Plr = game.Players.LocalPlayer
local ZoneEvent = game.ReplicatedStorage:WaitForChild("Events"):WaitForChild("ExclusionEvent")
local Debounce = function(Func, Time)
	local DB = true
	return function(...)
		if DB then
			DB = false
			Func(...)
			wait(Time)
			DB = true
		end
	end
end
local function FireOnTouch(Part)
	local Bool = Part.Parent.Parent:FindFirstChildWhichIsA("BoolValue")
	local In = Part.Parent.Name == "In"
	Part.Touched:Connect(Debounce(function(Brik)
		local AlreadyTagged = CS:HasTag(Plr.Character, Part.Parent.Parent.Name)
		if not In and not not AlreadyTagged and (not Bool or Bool.Value) and Brik:IsDescendantOf(Plr.Character) then
			ZoneEvent:FireServer(Part)
		end
	end, 1))
end
local ProcessChildren = function(Dir, Func)
	for _, Ch in pairs(Dir:GetChildren()) do
		Func(Ch)
	end
	Dir.ChildAdded:Connect(Func)
end
local function ProcessZone(Zone)
	local InDir, OutDir = Zone:WaitForChild("In"), Zone:WaitForChild("Out")
	ProcessChildren(InDir, FireOnTouch)
	ProcessChildren(OutDir, FireOnTouch)
end
ProcessChildren(workspace:WaitForChild("ExclusionZones"), ProcessZone)
return function()
end
]]></ProtectedString><string name="Name">ExclusionZones</string></Properties></Item><Item class="ModuleScript" referent="RBX562"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Event = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("DoorEvent")
local TweenService = game:GetService("TweenService")
local LocalDoorState = {}
local Player = game.Players.LocalPlayer
local DoorContainer = Instance.new("Folder")
DoorContainer.Name = "Doors"
DoorContainer.Parent = workspace.CurrentCamera
local Backpack
function GetDoorType(Door)
	local DoorType = "None"
	if Door:FindFirstChild("Button") and Door:FindFirstChild("Door1"):FindFirstChild("Special Part") then
		DoorType = "DoubleDoor"
	end
	if Door:FindFirstChild("Scripted") then
		if Door:FindFirstChild("Scripted"):FindFirstChild("unixyoutool") then
			DoorType = "BlastDoor"
		elseif Door:FindFirstChild("Scripted"):FindFirstChild("LeftDoor") then
			DoorType = "DoubleGate"
		elseif Door:FindFirstChild("Scripted"):FindFirstChild("Door") then
			DoorType = "CardDoor"
		end
	end
	return DoorType
end
function CardDoorRun(Door)
	if LocalDoorState[Door].State then
		LocalDoorState[Door].OutTween:Play()
		LocalDoorState[Door].LocalDoor.AccessGranted:Play()
		LocalDoorState[Door].LocalDoor.DoorOpen:Play()
	else
		LocalDoorState[Door].InTween:Play()
		LocalDoorState[Door].LocalDoor.DoorClose:Play()
	end
end
function DoubleGateRun(Door)
	if LocalDoorState[Door].State then
		LocalDoorState[Door].OutTweenA:Play()
		LocalDoorState[Door].OutTweenB:Play()
		LocalDoorState[Door].LocalDoorA.AccessGranted:Play()
		LocalDoorState[Door].LocalDoorA.DoorOpen:Play()
	else
		LocalDoorState[Door].InTweenA:Play()
		LocalDoorState[Door].InTweenB:Play()
		LocalDoorState[Door].LocalDoorA.DoorClose:Play()
	end
end
function BlastDoorRun(Door)
	if LocalDoorState[Door].State then
		LocalDoorState[Door].OutTweenA:Play()
		LocalDoorState[Door].OutTweenB:Play()
		LocalDoorState[Door].LocalDoorA.Alarm:Play()
		LocalDoorState[Door].LocalDoorA.AccessGranted:Play()
		LocalDoorState[Door].LocalDoorA.DoorOpen:Play()
	else
		LocalDoorState[Door].InTweenA:Play()
		LocalDoorState[Door].InTweenB:Play()
		LocalDoorState[Door].LocalDoorA.Alarm:Play()
		LocalDoorState[Door].LocalDoorA.DoorClose:Play()
	end
end
function HandleLocalDoor(Door)
	local Type = GetDoorType(Door.Object)
	if Type == "None" then
		return
	elseif Type == "CardDoor" then
		local LocalDoor = Door.Object.Scripted.Door:Clone()
		LocalDoor.Parent = DoorContainer
		LocalDoor.Transparency = 0
		LocalDoor.CanCollide = true
		Door.Object.Scripted.Door:Destroy()
		LocalDoorState[Door.Name].LocalDoor = LocalDoor
		local OutTween = TweenService:Create(Door.LocalDoor, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoor.CFrame * CFrame.new(0, 0, -5)
		})
		local InTween = TweenService:Create(Door.LocalDoor, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoor.CFrame
		})
		LocalDoorState[Door.Name].InTween = InTween
		LocalDoorState[Door.Name].OutTween = OutTween
		Door.Moving = false
		Door.Object:WaitForChild("ObjectState").Changed:Connect(function()
			LocalDoorState[Door.Name].State = Door.Object:WaitForChild("ObjectState").Value
			CardDoorRun(Door.Name)
		end)
		for i, v in pairs(Door.Object.Scripted.Readers:GetChildren()) do
			v.Touched:connect(function(Hit)
				if Hit.Parent:IsA("Tool") and Hit.Parent:IsDescendantOf(game.Players.LocalPlayer.Character) and (Door.Object.Allowed:FindFirstChild(Hit.Parent.Name) and Door.Object.Allowed:FindFirstChild(Hit.Parent.Name).Value or Hit.Parent.Name == "[SCP] Card-Omni") then
					if not Door.Moving then
						Door.Moving = true
						for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
							Door.BrickColor = BrickColor.new("Lime green")
							delay(1, function()
								Door.BrickColor = BrickColor.new("Institutional white")
							end)
						end
						Event:FireServer("ToggleCardDoor", Door.Name, Hit.Parent)
						wait(1)
						Door.Moving = false
					end
				elseif Hit.Parent.Name:match("[SCP]") or Hit.Parent.Name:match("Gamepass") then
					for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
						Door.BrickColor = BrickColor.new("Really red")
						delay(1, function()
							Door.BrickColor = BrickColor.new("Institutional white")
						end)
					end
				end
			end)
		end
	elseif Type == "DoubleGate" then
		local LocalDoorA = Door.Object.Scripted.LeftDoor:Clone()
		LocalDoorA.Parent = DoorContainer
		LocalDoorA.Transparency = 0
		LocalDoorA.CanCollide = true
		LocalDoorState[Door.Name].LocalDoorA = LocalDoorA
		local LocalDoorB = Door.Object.Scripted.RightDoor:Clone()
		LocalDoorB.Parent = DoorContainer
		LocalDoorB.Transparency = 0
		LocalDoorB.CanCollide = true
		Door.Object.Scripted.LeftDoor:Destroy()
		Door.Object.Scripted.RightDoor:Destroy()
		LocalDoorState[Door.Name].LocalDoorB = LocalDoorB
		local OutTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorA.CFrame * CFrame.new(0, 0, Door.LocalDoorA.Size.Z)
		})
		local InTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorA.CFrame
		})
		local OutTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorB.CFrame * CFrame.new(0, 0, Door.LocalDoorA.Size.Z)
		})
		local InTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = Door.LocalDoorB.CFrame
		})
		LocalDoorState[Door.Name].InTweenA = InTweenA
		LocalDoorState[Door.Name].InTweenB = InTweenB
		LocalDoorState[Door.Name].OutTweenA = OutTweenA
		LocalDoorState[Door.Name].OutTweenB = OutTweenB
		Door.Moving = false
		Door.Object:WaitForChild("ObjectState").Changed:Connect(function()
			LocalDoorState[Door.Name].State = Door.Object:WaitForChild("ObjectState").Value
			DoubleGateRun(Door.Name)
		end)
		for i, v in pairs(Door.Object.Scripted.Readers:GetChildren()) do
			v.Touched:connect(function(Hit)
				if Hit.Parent:IsA("Tool") and Hit.Parent:IsDescendantOf(game.Players.LocalPlayer.Character) and (Door.Object.Allowed:FindFirstChild(Hit.Parent.Name) and Door.Object.Allowed:FindFirstChild(Hit.Parent.Name).Value or Hit.Parent.Name == "[SCP] Card-Omni") then
					if not Door.Moving then
						Door.Moving = true
						for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
							Door.BrickColor = BrickColor.new("Lime green")
							delay(1, function()
								Door.BrickColor = BrickColor.new("Institutional white")
							end)
						end
						Event:FireServer("ToggleDoubleGate", Door.Name, Hit.Parent)
						wait(1)
						Door.Moving = false
					end
				elseif Hit.Parent.Name:match("[SCP]") or Hit.Parent.Name:match("Gamepass") then
					for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
						Door.BrickColor = BrickColor.new("Really red")
						delay(1, function()
							Door.BrickColor = BrickColor.new("Institutional white")
						end)
					end
				end
			end)
		end
	elseif Type == "BlastDoor" then
		local LocalDoorA = Door.Object.Scripted.LeftDoor:Clone()
		LocalDoorA.Parent = DoorContainer
		LocalDoorA.Transparency = 0
		LocalDoorA.CanCollide = true
		LocalDoorState[Door.Name].LocalDoorA = LocalDoorA
		local LocalDoorB = Door.Object.Scripted.RightDoor:Clone()
		LocalDoorB.Parent = DoorContainer
		LocalDoorB.Transparency = 0
		LocalDoorB.CanCollide = true
		Door.Object.Scripted.LeftDoor:Destroy()
		Door.Object.Scripted.RightDoor:Destroy()
		LocalDoorState[Door.Name].LocalDoorB = LocalDoorB
		local Closed = Door.Object:WaitForChild("ObjectState").Value
		local OpenA = Closed and {
			CFrame = Door.LocalDoorA.CFrame * CFrame.new(0, 0, -Door.LocalDoorA.Size.Z)
		} or {
			CFrame = Door.LocalDoorA.CFrame
		}
		local OpenB = Closed and {
			CFrame = Door.LocalDoorB.CFrame * CFrame.new(0, 0, -Door.LocalDoorB.Size.Z)
		} or {
			CFrame = Door.LocalDoorB.CFrame
		}
		local ClosedA = Closed and {
			CFrame = Door.LocalDoorA.CFrame
		} or {
			CFrame = Door.LocalDoorA.CFrame * CFrame.new(0, 0, Door.LocalDoorA.Size.Z)
		}
		local ClosedB = Closed and {
			CFrame = Door.LocalDoorB.CFrame
		} or {
			CFrame = Door.LocalDoorB.CFrame * CFrame.new(0, 0, Door.LocalDoorB.Size.Z)
		}
		local OutTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), ClosedA)
		local InTweenA = TweenService:Create(Door.LocalDoorA, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), OpenA)
		local OutTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), ClosedB)
		local InTweenB = TweenService:Create(Door.LocalDoorB, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), OpenB)
		LocalDoorState[Door.Name].InTweenA = InTweenA
		LocalDoorState[Door.Name].InTweenB = InTweenB
		LocalDoorState[Door.Name].OutTweenA = OutTweenA
		LocalDoorState[Door.Name].OutTweenB = OutTweenB
		Door.Moving = false
		Door.Object:WaitForChild("ObjectState").Changed:Connect(function()
			LocalDoorState[Door.Name].State = Door.Object:WaitForChild("ObjectState").Value
			BlastDoorRun(Door.Name)
		end)
		if Door.Object.Scripted:FindFirstChild("Readers") then
			for i, v in pairs(Door.Object.Scripted.Readers:GetChildren()) do
				v.Touched:connect(function(Hit)
					if Hit.Parent:IsA("Tool") and Hit.Parent:IsDescendantOf(game.Players.LocalPlayer.Character) and (Door.Object.Allowed:FindFirstChild(Hit.Parent.Name) and Door.Object.Allowed:FindFirstChild(Hit.Parent.Name).Value or Hit.Parent.Name == "[SCP] Card-Omni") then
						if not Door.Moving then
							Door.Moving = true
							for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
								Door.BrickColor = BrickColor.new("Lime green")
								delay(1, function()
									Door.BrickColor = BrickColor.new("Institutional white")
								end)
							end
							Event:FireServer("ToggleBlastDoor", Door.Name, Hit.Parent)
							wait(1)
							Door.Moving = false
						end
					elseif Hit.Parent.Name:match("[SCP]") or Hit.Parent.Name:match("Gamepass") then
						for i, Door in pairs(Door.Object.Scripted.Lights:GetChildren()) do
							Door.BrickColor = BrickColor.new("Really red")
							delay(1, function()
								Door.BrickColor = BrickColor.new("Institutional white")
							end)
						end
					end
				end)
			end
		end
	end
end
Event:FireServer("GainUpdateBatch")
Event.OnClientEvent:connect(function(Type, Door, State)
	if Type == "SingleDoor" then
		LocalDoorState[Door].State = State
		CardDoorRun(Door)
	elseif Type == "DoubleGate" then
		LocalDoorState[Door].State = State
		DoubleGateRun(Door)
	elseif Type == "BlastDoor" then
		print("BlastDoor")
		LocalDoorState[Door].State = State
		BlastDoorRun(Door)
	elseif Type == "Bulk" then
		LocalDoorState = Door
		for i, v in pairs(LocalDoorState) do
			HandleLocalDoor(v)
		end
	end
end)
Backpack = Player:FindFirstChildWhichIsA("Backpack")
local MurderEars = function()
	if script:FindFirstChild("Oof") then
		script.Oof:Play()
	end
	if script:FindFirstChild("ColorCorrection") then
		script.ColorCorrection:Clone().Parent = game.Lighting
	end
	if script:FindFirstChild("Bloom") then
		script.Bloom:Clone().Parent = game.Lighting
	end
	wait(3)
end
local function PreventToolNameChange(Child)
	local NameSignal = Child:GetPropertyChangedSignal("Name")
	local Conn
	Conn = NameSignal:Connect(function()
		print("you know i had to do it to em")
		Conn:Disconnect()
		Conn = nil
		MurderEars()
		game.Players.LocalPlayer:Kick([[

[SCPF] It's time to stop.]])
	end)
end
if Backpack then
	for _, Child in pairs(Backpack:GetChildren()) do
		PreventToolNameChange(Child)
	end
end
Player.ChildAdded:Connect(function(Child)
	if Child:IsA("Backpack") then
		Backpack = Child
		for _, Chld in pairs(Backpack:GetChildren()) do
			PreventToolNameChange(Chld)
		end
		Child.ChildAdded:connect(PreventToolNameChange)
	end
end)
local function EnforceSonar(Chr)
	local Conn, Conn1
	local Sonar = Chr:WaitForChild("Animate")
	if game:GetService("Players"):GetPlayerFromCharacter(Chr):GetRankInGroup(2694395) < 70 then
		Conn = Chr.ChildRemoved:Connect(function(Child)
			wait(0.2)
			if Child == Sonar and Chr:FindFirstChild("Humanoid") and Chr.Humanoid.Health > 0 then
				MurderEars()
				Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
			end
		end)
		Conn2 = Sonar:GetPropertyChangedSignal("Disabled"):Connect(function()
			wait(0.2)
			MurderEars()
			Player:Kick([[

[SCPF] Roses are Red, Violets are Blue,
Screw with my site and I will kick you.]])
		end)
		Conn1 = Chr:WaitForChild("Humanoid").Died:Connect(function()
			Conn:Disconnect()
			Conn1:Disconnect()
			Conn2:Disconnect()
			Conn, Conn1, Conn2 = nil, nil, nil
		end)
	end
end
local function IHateYou()
	Player:Kick([[
[SCPF]
WOAH, there's Wi-Fi on the short bus?]])
end
DoorContainer.DescendantRemoving:Connect(IHateYou)
DoorContainer:GetPropertyChangedSignal("Parent"):Connect(IHateYou)
local AllowedGuis = {
	"CoreUI",
	"RobloxGui",
	"ControlGui",
	"ShopGui",
	"CoffeeMachineDrink",
	"Model Resize GUI",
	"ChoiceUI",
	"Hitmarker",
	"Blind",
	"DefibCharge",
	"TokenMenu",
	"Menu",
	"AmmoGui",
	"ActivityLog",
	"FlashGUI",
	"NV",
	"UglySuitChoice",
	"VisionControls",
	"CustomCharGui",
	"LoadoutGui",
	"BriefingGui",
	"PhysicsAnalyzerGui",
	"CommandGui",
	"SCP061Gui",
	"Radio",
	"Repairing",
	"ScopeGui",
	"362Gui",
	"MusicPanel_DebugBuild",
	"Command",
	"Blindness",
	"WeldingGui",
	"MenuUI"
}
Player.CharacterAdded:Connect(EnforceSonar)
return {}
]]></ProtectedString><string name="Name">Doors</string></Properties></Item></Item><Item class="ModuleScript" referent="RBX568"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local PlayerModule = {}
PlayerModule.__index = PlayerModule
function PlayerModule.new()
	local self = setmetatable({}, PlayerModule)
	self.cameras = require(script:WaitForChild("CameraModule"))
	self.controls = require(script:WaitForChild("ControlModule"))
	return self
end
function PlayerModule:GetCameras()
	return self.cameras
end
function PlayerModule:GetControls()
	return self.controls
end
function PlayerModule:GetClickToMoveController()
	return self.controls:GetClickToMoveController()
end
return PlayerModule.new()
]]></ProtectedString><string name="Name">PlayerModule</string></Properties><Item class="ModuleScript" referent="RBX572"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local CameraModule = {}
CameraModule.__index = CameraModule
local PLAYER_CAMERA_PROPERTIES = {
	"CameraMinZoomDistance",
	"CameraMaxZoomDistance",
	"CameraMode",
	"DevCameraOcclusionMode",
	"DevComputerCameraMode",
	"DevTouchCameraMode",
	"DevComputerMovementMode",
	"DevTouchMovementMode",
	"DevEnableMouseLock"
}
local USER_GAME_SETTINGS_PROPERTIES = {
	"ComputerCameraMovementMode",
	"ComputerMovementMode",
	"ControlMode",
	"GamepadCameraSensitivity",
	"MouseSensitivity",
	"RotationType",
	"TouchCameraMovementMode",
	"TouchMovementMode"
}
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterPlayer = game:GetService("StarterPlayer")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local CameraUtils = require(script:WaitForChild("CameraUtils"))
local ClassicCamera = require(script:WaitForChild("ClassicCamera"))
local OrbitalCamera = require(script:WaitForChild("OrbitalCamera"))
local LegacyCamera = require(script:WaitForChild("LegacyCamera"))
local Invisicam = require(script:WaitForChild("Invisicam"))
local Poppercam
do
	local success, useNewPoppercam = pcall(UserSettings().IsUserFeatureEnabled, UserSettings(), "UserNewPoppercam4")
	if success and useNewPoppercam then
		Poppercam = require(script:WaitForChild("Poppercam"))
	else
		Poppercam = require(script:WaitForChild("Poppercam_Classic"))
	end
end
local TransparencyController = require(script:WaitForChild("TransparencyController"))
local MouseLockController = require(script:WaitForChild("MouseLockController"))
local instantiatedCameraControllers = {}
local instantiatedOcclusionModules = {}
do
	local PlayerScripts = Players.LocalPlayer:WaitForChild("PlayerScripts")
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Default)
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Follow)
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Classic)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Default)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Follow)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Classic)
end
function CameraModule.new()
	local self = setmetatable({}, CameraModule)
	self.activeCameraController = nil
	self.activeOcclusionModule = nil
	self.activeTransparencyController = nil
	self.activeMouseLockController = nil
	self.currentComputerCameraMovementMode = nil
	self.cameraSubjectChangedConn = nil
	self.cameraTypeChangedConn = nil
	for _, player in pairs(Players:GetPlayers()) do
		self:OnPlayerAdded(player)
	end
	Players.PlayerAdded:Connect(function(player)
		self:OnPlayerAdded(player)
	end)
	self.activeTransparencyController = TransparencyController.new()
	self.activeTransparencyController:Enable(true)
	if not UserInputService.TouchEnabled then
		self.activeMouseLockController = MouseLockController.new()
		local toggleEvent = self.activeMouseLockController:GetBindableToggleEvent()
		if toggleEvent then
			toggleEvent:Connect(function()
				self:OnMouseLockToggled()
			end)
		end
	end
	self:ActivateCameraController(self:GetCameraControlChoice())
	self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
	self:OnCurrentCameraChanged()
	RunService:BindToRenderStep("cameraRenderUpdate", Enum.RenderPriority.Camera.Value, function(dt)
		self:Update(dt)
	end)
	for _, propertyName in pairs(PLAYER_CAMERA_PROPERTIES) do
		Players.LocalPlayer:GetPropertyChangedSignal(propertyName):Connect(function()
			self:OnLocalPlayerCameraPropertyChanged(propertyName)
		end)
	end
	for _, propertyName in pairs(USER_GAME_SETTINGS_PROPERTIES) do
		UserGameSettings:GetPropertyChangedSignal(propertyName):Connect(function()
			self:OnUserGameSettingsPropertyChanged(propertyName)
		end)
	end
	game.Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		self:OnCurrentCameraChanged()
	end)
	self.lastInputType = UserInputService:GetLastInputType()
	UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
		self.lastInputType = newLastInputType
	end)
	return self
end
function CameraModule:GetCameraMovementModeFromSettings()
	local cameraMode = Players.LocalPlayer.CameraMode
	if cameraMode == Enum.CameraMode.LockFirstPerson then
		return CameraUtils.ConvertCameraModeEnumToStandard(Enum.ComputerCameraMovementMode.Classic)
	end
	local devMode, userMode
	if UserInputService.TouchEnabled then
		devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevTouchCameraMode)
		userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
	else
		devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevComputerCameraMode)
		userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
	end
	if devMode == Enum.DevComputerCameraMovementMode.UserChoice then
		return userMode
	end
	return devMode
end
function CameraModule:ActivateOcclusionModule(occlusionMode)
	local newModuleCreator
	if occlusionMode == Enum.DevCameraOcclusionMode.Zoom then
		newModuleCreator = Poppercam
	elseif occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
		newModuleCreator = Invisicam
	else
		warn("CameraScript ActivateOcclusionModule called with unsupported mode")
		return
	end
	if self.activeOcclusionModule and self.activeOcclusionModule:GetOcclusionMode() == occlusionMode then
		if not self.activeOcclusionModule:GetEnabled() then
			self.activeOcclusionModule:Enable(true)
		end
		return
	end
	local prevOcclusionModule = self.activeOcclusionModule
	self.activeOcclusionModule = instantiatedOcclusionModules[newModuleCreator]
	if not self.activeOcclusionModule then
		self.activeOcclusionModule = newModuleCreator.new()
		if self.activeOcclusionModule then
			instantiatedOcclusionModules[newModuleCreator] = self.activeOcclusionModule
		end
	end
	if self.activeOcclusionModule then
		local newModuleOcclusionMode = self.activeOcclusionModule:GetOcclusionMode()
		if newModuleOcclusionMode ~= occlusionMode then
			warn("CameraScript ActivateOcclusionModule mismatch: ", self.activeOcclusionModule:GetOcclusionMode(), "~=", occlusionMode)
		end
		if prevOcclusionModule then
			if prevOcclusionModule ~= self.activeOcclusionModule then
				prevOcclusionModule:Enable(false)
			else
				warn("CameraScript ActivateOcclusionModule failure to detect already running correct module")
			end
		end
		if occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
			if Players.LocalPlayer.Character then
				self.activeOcclusionModule:CharacterAdded(Players.LocalPlayer.Character, Players.LocalPlayer)
			end
		else
			for _, player in pairs(Players:GetPlayers()) do
				if player and player.Character then
					self.activeOcclusionModule:CharacterAdded(player.Character, player)
				end
			end
			self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
		end
		self.activeOcclusionModule:Enable(true)
	end
end
function CameraModule:ActivateCameraController(cameraMovementMode, legacyCameraType)
	local newCameraCreator
	if legacyCameraType ~= nil then
		if legacyCameraType == Enum.CameraType.Scriptable then
			if self.activeCameraController then
				self.activeCameraController:Enable(false)
				self.activeCameraController = nil
				return
			end
		elseif legacyCameraType == Enum.CameraType.Custom then
			cameraMovementMode = self:GetCameraMovementModeFromSettings()
		elseif legacyCameraType == Enum.CameraType.Track then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Classic
		elseif legacyCameraType == Enum.CameraType.Follow then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Follow
		elseif legacyCameraType == Enum.CameraType.Orbital then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Orbital
		elseif legacyCameraType == Enum.CameraType.Attach or legacyCameraType == Enum.CameraType.Watch or legacyCameraType == Enum.CameraType.Fixed then
			newCameraCreator = LegacyCamera
		else
			warn("CameraScript encountered an unhandled Camera.CameraType value: ", legacyCameraType)
		end
	end
	if not newCameraCreator then
		if cameraMovementMode == Enum.ComputerCameraMovementMode.Classic or cameraMovementMode == Enum.ComputerCameraMovementMode.Follow or cameraMovementMode == Enum.ComputerCameraMovementMode.Default then
			newCameraCreator = ClassicCamera
		elseif cameraMovementMode == Enum.ComputerCameraMovementMode.Orbital then
			newCameraCreator = OrbitalCamera
		else
			warn("ActivateCameraController did not select a module.")
			return
		end
	end
	local newCameraController
	if not instantiatedCameraControllers[newCameraCreator] then
		newCameraController = newCameraCreator.new()
		instantiatedCameraControllers[newCameraCreator] = newCameraController
	else
		newCameraController = instantiatedCameraControllers[newCameraCreator]
	end
	if self.activeCameraController then
		if self.activeCameraController ~= newCameraController then
			self.activeCameraController:Enable(false)
			self.activeCameraController = newCameraController
			self.activeCameraController:Enable(true)
		elseif not self.activeCameraController:GetEnabled() then
			self.activeCameraController:Enable(true)
		end
	elseif newCameraController ~= nil then
		self.activeCameraController = newCameraController
		self.activeCameraController:Enable(true)
	end
	if self.activeCameraController then
		if cameraMovementMode ~= nil then
			self.activeCameraController:SetCameraMovementMode(cameraMovementMode)
		elseif legacyCameraType ~= nil then
			self.activeCameraController:SetCameraType(legacyCameraType)
		end
	end
end
function CameraModule:OnCameraSubjectChanged()
	if self.activeTransparencyController then
		self.activeTransparencyController:SetSubject(game.Workspace.CurrentCamera.CameraSubject)
	end
	if self.activeOcclusionModule then
		self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
	end
end
function CameraModule:OnCameraTypeChanged(newCameraType)
	if newCameraType == Enum.CameraType.Scriptable and UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
	self:ActivateCameraController(nil, newCameraType)
end
function CameraModule:OnCurrentCameraChanged()
	local currentCamera = game.Workspace.CurrentCamera
	if not currentCamera then
		return
	end
	if self.cameraSubjectChangedConn then
		self.cameraSubjectChangedConn:Disconnect()
	end
	if self.cameraTypeChangedConn then
		self.cameraTypeChangedConn:Disconnect()
	end
	self.cameraSubjectChangedConn = currentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
		self:OnCameraSubjectChanged(currentCamera.CameraSubject)
	end)
	self.cameraTypeChangedConn = currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
		self:OnCameraTypeChanged(currentCamera.CameraType)
	end)
	self:OnCameraSubjectChanged(currentCamera.CameraSubject)
	self:OnCameraTypeChanged(currentCamera.CameraType)
end
function CameraModule:OnLocalPlayerCameraPropertyChanged(propertyName)
	if propertyName == "CameraMode" then
		if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
			if not self.activeCameraController or self.activeCameraController:GetModuleName() ~= "ClassicCamera" then
				self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(Enum.DevComputerCameraMovementMode.Classic))
			end
			if self.activeCameraController then
				self.activeCameraController:UpdateForDistancePropertyChange()
			end
		elseif Players.LocalPlayer.CameraMode == Enum.CameraMode.Classic then
			local cameraMovementMode = self:GetCameraMovementModeFromSettings()
			self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
		else
			warn("Unhandled value for property player.CameraMode: ", Players.LocalPlayer.CameraMode)
		end
	elseif propertyName == "DevComputerCameraMode" or propertyName == "DevTouchCameraMode" then
		local cameraMovementMode = self:GetCameraMovementModeFromSettings()
		self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
	elseif propertyName == "DevCameraOcclusionMode" then
		self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
	elseif propertyName == "CameraMinZoomDistance" or propertyName == "CameraMaxZoomDistance" then
		if self.activeCameraController then
			self.activeCameraController:UpdateForDistancePropertyChange()
		end
	elseif propertyName == "DevTouchMovementMode" then
	elseif propertyName == "DevComputerMovementMode" then
	elseif propertyName == "DevEnableMouseLock" then
	end
end
function CameraModule:OnUserGameSettingsPropertyChanged(propertyName)
	if propertyName == "ComputerCameraMovementMode" then
		local cameraMovementMode = self:GetCameraMovementModeFromSettings()
		self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
	end
end
function CameraModule:Update(dt)
	if self.activeCameraController then
		local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)
		self.activeCameraController:ApplyVRTransform()
		if self.activeOcclusionModule then
			newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
		end
		game.Workspace.CurrentCamera.CFrame = newCameraCFrame
		game.Workspace.CurrentCamera.Focus = newCameraFocus
		if self.activeTransparencyController then
			self.activeTransparencyController:Update()
		end
	end
end
function CameraModule:GetCameraControlChoice()
	local player = Players.LocalPlayer
	if player then
		if self.lastInputType == Enum.UserInputType.Touch or UserInputService.TouchEnabled then
			if player.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice then
				return CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
			else
				return CameraUtils.ConvertCameraModeEnumToStandard(player.DevTouchCameraMode)
			end
		elseif player.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice then
			local computerMovementMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
			return CameraUtils.ConvertCameraModeEnumToStandard(computerMovementMode)
		else
			return CameraUtils.ConvertCameraModeEnumToStandard(player.DevComputerCameraMode)
		end
	end
end
function CameraModule:OnCharacterAdded(char, player)
	if self.activeOcclusionModule then
		self.activeOcclusionModule:CharacterAdded(char, player)
	end
end
function CameraModule:OnCharacterRemoving(char, player)
	if self.activeOcclusionModule then
		self.activeOcclusionModule:CharacterRemoving(char, player)
	end
end
function CameraModule:OnPlayerAdded(player)
	player.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char, player)
	end)
	player.CharacterRemoving:Connect(function(char)
		self:OnCharacterRemoving(char, player)
	end)
end
function CameraModule:OnMouseLockToggled()
	if self.activeMouseLockController then
		local mouseLocked = self.activeMouseLockController:GetIsMouseLocked()
		local mouseLockOffset = self.activeMouseLockController:GetMouseLockOffset()
		if self.activeCameraController then
			self.activeCameraController:SetIsMouseLocked(mouseLocked)
			self.activeCameraController:SetMouseLockOffset(mouseLockOffset)
		end
	end
end
return CameraModule.new()
]]></ProtectedString><string name="Name">CameraModule</string></Properties><Item class="ModuleScript" referent="RBX576"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local CameraUtils = {}
local round = function(num)
	return math.floor(num + 0.5)
end
function CameraUtils.Clamp(low, high, val)
	return math.min(math.max(val, low), high)
end
function CameraUtils.Round(num, places)
	local decimalPivot = 10 ^ places
	return math.floor(num * decimalPivot + 0.5) / decimalPivot
end
function CameraUtils.IsFinite(val)
	return val == val and val ~= math.huge and val ~= -math.huge
end
function CameraUtils.IsFiniteVector3(vec3)
	return CameraUtils.IsFinite(vec3.X) and CameraUtils.IsFinite(vec3.Y) and CameraUtils.IsFinite(vec3.Z)
end
function CameraUtils.GetAngleBetweenXZVectors(v1, v2)
	return math.atan2(v2.X * v1.Z - v2.Z * v1.X, v2.X * v1.X + v2.Z * v1.Z)
end
function CameraUtils.RotateVectorByAngleAndRound(camLook, rotateAngle, roundAmount)
	if camLook.Magnitude > 0 then
		camLook = camLook.unit
		local currAngle = math.atan2(camLook.z, camLook.x)
		local newAngle = round((math.atan2(camLook.z, camLook.x) + rotateAngle) / roundAmount) * roundAmount
		return newAngle - currAngle
	end
	return 0
end
local k = 0.35
local lowerK = 0.8
local function SCurveTranform(t)
	t = CameraUtils.Clamp(-1, 1, t)
	if t >= 0 then
		return k * t / (k - t + 1)
	end
	return -(lowerK * -t / (lowerK + t + 1))
end
local DEADZONE = 0.1
local function toSCurveSpace(t)
	return (1 + DEADZONE) * (2 * math.abs(t) - 1) - DEADZONE
end
local fromSCurveSpace = function(t)
	return t / 2 + 0.5
end
function CameraUtils.GamepadLinearToCurve(thumbstickPosition)
	local function onAxis(axisValue)
		local sign = 1
		if axisValue < 0 then
			sign = -1
		end
		local point = fromSCurveSpace(SCurveTranform(toSCurveSpace(math.abs(axisValue))))
		point = point * sign
		return CameraUtils.Clamp(-1, 1, point)
	end
	return Vector2.new(onAxis(thumbstickPosition.x), onAxis(thumbstickPosition.y))
end
function CameraUtils.ConvertCameraModeEnumToStandard(enumValue)
	if enumValue == Enum.TouchCameraMovementMode.Default then
		return Enum.ComputerCameraMovementMode.Follow
	end
	if enumValue == Enum.ComputerCameraMovementMode.Default then
		return Enum.ComputerCameraMovementMode.Classic
	end
	if enumValue == Enum.TouchCameraMovementMode.Classic or enumValue == Enum.DevTouchCameraMovementMode.Classic or enumValue == Enum.DevComputerCameraMovementMode.Classic or enumValue == Enum.ComputerCameraMovementMode.Classic then
		return Enum.ComputerCameraMovementMode.Classic
	end
	if enumValue == Enum.TouchCameraMovementMode.Follow or enumValue == Enum.DevTouchCameraMovementMode.Follow or enumValue == Enum.DevComputerCameraMovementMode.Follow or enumValue == Enum.ComputerCameraMovementMode.Follow then
		return Enum.ComputerCameraMovementMode.Follow
	end
	if enumValue == Enum.TouchCameraMovementMode.Orbital or enumValue == Enum.DevTouchCameraMovementMode.Orbital or enumValue == Enum.DevComputerCameraMovementMode.Orbital or enumValue == Enum.ComputerCameraMovementMode.Orbital then
		return Enum.ComputerCameraMovementMode.Orbital
	end
	if enumValue == Enum.DevTouchCameraMovementMode.UserChoice or enumValue == Enum.DevComputerCameraMovementMode.UserChoice then
		return Enum.DevComputerCameraMovementMode.UserChoice
	end
	return Enum.ComputerCameraMovementMode.Classic
end
return CameraUtils
]]></ProtectedString><string name="Name">CameraUtils</string></Properties></Item><Item class="ModuleScript" referent="RBX581"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZERO_VECTOR2 = Vector2.new(0, 0)
local tweenAcceleration = math.rad(220)
local tweenSpeed = math.rad(0)
local tweenMaxSpeed = math.rad(250)
local TIME_BEFORE_AUTO_ROTATE = 2
local PORTRAIT_OFFSET = Vector3.new(0, 2, 0)
local MOBILE_OFFSET = Vector3.new(0, 1, 0)
local INITIAL_CAMERA_ANGLE = CFrame.fromOrientation(math.rad(-15), 0, 0)
local PlayersService = game:GetService("Players")
local VRService = game:GetService("VRService")
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local newCameraConstantsFlagExists, newCameraConstantsFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserUpdateCameraConstants")
end)
local FFlagUserUpdateCameraConstants = newCameraConstantsFlagExists and newCameraConstantsFlagEnabled
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local ClassicCamera = setmetatable({}, BaseCamera)
ClassicCamera.__index = ClassicCamera
function ClassicCamera.new()
	local self = setmetatable(BaseCamera.new(), ClassicCamera)
	self.isFollowCamera = false
	self.lastUpdate = tick()
	return self
end
function ClassicCamera:GetModuleName()
	return "ClassicCamera"
end
function ClassicCamera:SetCameraMovementMode(cameraMovementMode)
	BaseCamera.SetCameraMovementMode(self, cameraMovementMode)
	self.isFollowCamera = cameraMovementMode == Enum.ComputerCameraMovementMode.Follow
end
function ClassicCamera:Test()
	print("ClassicCamera:Test()")
end
function ClassicCamera:GetCameraSubjectOffset()
	if self:IsInFirstPerson() then
		return Vector3.new(0, 0, 0)
	elseif self.portraitMode then
		return PORTRAIT_OFFSET
	elseif self.isSmallTouchScreen then
		return MOBILE_OFFSET
	end
	return Vector3.new(0, 0, 0)
end
function ClassicCamera:Update()
	local now = tick()
	local timeDelta = now - self.lastUpdate
	local camera = workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local overrideCameraLookVector
	if self.resetCameraAngle then
		local rootPart = self:GetHumanoidRootPart()
		if rootPart then
			overrideCameraLookVector = (rootPart.CFrame * INITIAL_CAMERA_ANGLE).lookVector
		else
			overrideCameraLookVector = INITIAL_CAMERA_ANGLE.lookVector
		end
		self.resetCameraAngle = false
	end
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	local isOnASkateboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end
	if self.lastUpdate then
		local gamepadRotation = self:UpdateGamepad()
		if self:ShouldUseVRRotation() then
			self.rotateInput = self.rotateInput + self:GetVRRotationInput()
		else
			local delta = math.min(0.1, timeDelta)
			if gamepadRotation ~= ZERO_VECTOR2 then
				self.rotateInput = self.rotateInput + gamepadRotation * delta
			end
			local angle = 0
			if not isInVehicle and not isOnASkateboard then
				angle = angle + (self.turningLeft and -120 or 0)
				angle = angle + (self.turningRight and 120 or 0)
			end
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(math.rad(angle * delta), 0)
			end
		end
	end
	if self.userPanningTheCamera then
		tweenSpeed = 0
		self.lastUserPanCamera = tick()
	end
	local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
	local subjectPosition = self:GetSubjectPosition()
	if subjectPosition and player and camera then
		local zoom = self:GetCameraToSubjectDistance()
		if zoom < 0.5 then
			zoom = 0.5
		end
		if self:GetIsMouseLocked() and not self:IsInFirstPerson() then
			local newLookCFrame = self:CalculateNewLookCFrame(overrideCameraLookVector)
			local offset = self:GetMouseLockOffset()
			local cameraRelativeOffset = offset.X * newLookCFrame.rightVector + offset.Y * newLookCFrame.upVector + offset.Z * newLookCFrame.lookVector
			if Util.IsFiniteVector3(cameraRelativeOffset) then
				subjectPosition = subjectPosition + cameraRelativeOffset
			end
		elseif not self.userPanningTheCamera and self.lastCameraTransform then
			local isInFirstPerson = self:IsInFirstPerson()
			if (isInVehicle or isOnASkateboard or self.isFollowCamera and isClimbing) and self.lastUpdate and humanoid and humanoid.Torso then
				if isInFirstPerson then
					if self.lastSubjectCFrame and (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
						local y = -Util.GetAngleBetweenXZVectors(self.lastSubjectCFrame.lookVector, cameraSubject.CFrame.lookVector)
						if Util.IsFinite(y) then
							self.rotateInput = self.rotateInput + Vector2.new(y, 0)
						end
						tweenSpeed = 0
					end
				elseif not userRecentlyPannedCamera then
					local forwardVector = humanoid.Torso.CFrame.lookVector
					if isOnASkateboard then
						forwardVector = cameraSubject.CFrame.lookVector
					end
					tweenSpeed = Util.Clamp(0, tweenMaxSpeed, tweenSpeed + tweenAcceleration * timeDelta)
					local percent = Util.Clamp(0, 1, tweenSpeed * timeDelta)
					if self:IsInFirstPerson() and (not self.isFollowCamera or not self.isClimbing) then
						percent = 1
					end
					local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
					if Util.IsFinite(y) and math.abs(y) > 1.0E-4 then
						self.rotateInput = self.rotateInput + Vector2.new(y * percent, 0)
					end
				end
			elseif self.isFollowCamera and not isInFirstPerson and not userRecentlyPannedCamera and not VRService.VREnabled then
				local lastVec = -(self.lastCameraTransform.p - subjectPosition)
				local y = Util.GetAngleBetweenXZVectors(lastVec, self:GetCameraLookVector())
				local thetaCutoff = 0.4
				if Util.IsFinite(y) and math.abs(y) > 1.0E-4 and math.abs(y) > thetaCutoff * timeDelta then
					self.rotateInput = self.rotateInput + Vector2.new(y, 0)
				end
			end
		end
		if not self.isFollowCamera then
			local VREnabled = VRService.VREnabled
			if VREnabled then
				newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
			elseif FFlagUserUpdateCameraConstants then
				newCameraFocus = CFrame.new(subjectPosition)
			else
				newCameraFocus = CFrame.new(subjectPosition + self:GetCameraSubjectOffset())
			end
			local cameraFocusP = newCameraFocus.p
			if VREnabled and not self:IsInFirstPerson() then
				local cameraHeight = self:GetCameraHeight()
				local vecToSubject = subjectPosition - camera.CFrame.p
				local distToSubject = vecToSubject.magnitude
				if zoom < distToSubject or self.rotateInput.x ~= 0 then
					local desiredDist = math.min(distToSubject, zoom)
					vecToSubject = self:CalculateNewLookVectorVR() * desiredDist
					local newPos = cameraFocusP - vecToSubject
					local desiredLookDir = camera.CFrame.lookVector
					if self.rotateInput.x ~= 0 then
						desiredLookDir = vecToSubject
					end
					local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
					self.rotateInput = ZERO_VECTOR2
					newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
				end
			else
				local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
				self.rotateInput = ZERO_VECTOR2
				newCameraCFrame = CFrame.new(cameraFocusP - zoom * newLookVector, cameraFocusP)
			end
		else
			local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
			self.rotateInput = ZERO_VECTOR2
			if VRService.VREnabled then
				newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
			elseif FFlagUserUpdateCameraConstants then
				newCameraFocus = CFrame.new(subjectPosition)
			else
				newCameraFocus = CFrame.new(subjectPosition + self:GetCameraSubjectOffset())
			end
			newCameraCFrame = CFrame.new(newCameraFocus.p - zoom * newLookVector, newCameraFocus.p) + Vector3.new(0, self:GetCameraHeight(), 0)
		end
		self.lastCameraTransform = newCameraCFrame
		self.lastCameraFocus = newCameraFocus
		if (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
			self.lastSubjectCFrame = cameraSubject.CFrame
		else
			self.lastSubjectCFrame = nil
		end
	end
	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end
function ClassicCamera:EnterFirstPerson()
	self.inFirstPerson = true
	self:UpdateMouseBehavior()
end
function ClassicCamera:LeaveFirstPerson()
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
end
return ClassicCamera
]]></ProtectedString><string name="Name">ClassicCamera</string></Properties></Item><Item class="ModuleScript" referent="RBX586"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZoomController = require(script.Parent:WaitForChild("ZoomController"))
local TransformExtrapolator = {}
TransformExtrapolator.__index = TransformExtrapolator
do
	local CF_IDENTITY = CFrame.new()
	local cframeToAxis = function(cframe)
		local axis, angle = cframe:toAxisAngle()
		return axis * angle
	end
	local function axisToCFrame(axis)
		local angle = axis.magnitude
		if angle > 1.0E-5 then
			return CFrame.fromAxisAngle(axis, angle)
		end
		return CF_IDENTITY
	end
	local extractRotation = function(cf)
		local _, _, _, xx, yx, zx, xy, yy, zy, xz, yz, zz = cf:components()
		return CFrame.new(0, 0, 0, xx, yx, zx, xy, yy, zy, xz, yz, zz)
	end
	function TransformExtrapolator.new()
		return setmetatable({lastCFrame = nil}, TransformExtrapolator)
	end
	function TransformExtrapolator:Step(dt, currentCFrame)
		local lastCFrame = self.lastCFrame or currentCFrame
		self.lastCFrame = currentCFrame
		local currentPos = currentCFrame.p
		local currentRot = extractRotation(currentCFrame)
		local lastPos = lastCFrame.p
		local lastRot = extractRotation(lastCFrame)
		local dp = (currentPos - lastPos) / dt
		local dr = cframeToAxis(currentRot * lastRot:inverse()) / dt
		local function extrapolate(t)
			local p = dp * t + currentPos
			local r = axisToCFrame(dr * t) * currentRot
			return r + p
		end
		return {
			extrapolate = extrapolate,
			posVelocity = dp,
			rotVelocity = dr
		}
	end
	function TransformExtrapolator:Reset()
		self.lastCFrame = nil
	end
end
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Poppercam = setmetatable({}, BaseOcclusion)
Poppercam.__index = Poppercam
function Poppercam.new()
	local self = setmetatable(BaseOcclusion.new(), Poppercam)
	self.focusExtrapolator = TransformExtrapolator.new()
	return self
end
function Poppercam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Zoom
end
function Poppercam:Enable(enable)
	self.focusExtrapolator:Reset()
end
function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
	local rotatedFocus = CFrame.new(desiredCameraFocus.p, desiredCameraCFrame.p) * CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1)
	local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
	local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
	return rotatedFocus * CFrame.new(0, 0, zoom), desiredCameraFocus
end
function Poppercam:CharacterAdded(character, player)
end
function Poppercam:CharacterRemoving(character, player)
end
function Poppercam:OnCameraSubjectChanged(newSubject)
end
return Poppercam
]]></ProtectedString><string name="Name">Poppercam</string></Properties></Item><Item class="ModuleScript" referent="RBX591"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UNIT_Z = Vector3.new(0, 0, 1)
local X1_Y0_Z1 = Vector3.new(1, 0, 1)
local THUMBSTICK_DEADZONE = 0.2
local DEFAULT_DISTANCE = 12.5
local PORTRAIT_DEFAULT_DISTANCE = 25
local FIRST_PERSON_DISTANCE_THRESHOLD = 1
local CAMERA_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
local newCameraConstantsFlagExists, newCameraConstantsFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserUpdateCameraConstants")
end)
local FFlagUserUpdateCameraConstants = newCameraConstantsFlagExists and newCameraConstantsFlagEnabled
local MIN_Y = math.rad(-80)
local MAX_Y = math.rad(80)
local VR_ANGLE = math.rad(15)
local VR_LOW_INTENSITY_ROTATION = Vector2.new(math.rad(15), 0)
local VR_HIGH_INTENSITY_ROTATION = Vector2.new(math.rad(45), 0)
local VR_LOW_INTENSITY_REPEAT = 0.1
local VR_HIGH_INTENSITY_REPEAT = 0.4
local ZERO_VECTOR2 = Vector2.new(0, 0)
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local TOUCH_SENSITIVTY = Vector2.new(0.002 * math.pi, 0.0015 * math.pi)
if FFlagUserUpdateCameraConstants then
	TOUCH_SENSITIVTY = Vector2.new(0.0045 * math.pi, 0.003375 * math.pi)
end
local MOUSE_SENSITIVITY = Vector2.new(0.002 * math.pi, 0.0015 * math.pi)
local MAX_TIME_FOR_DOUBLE_TAP = 1.5
local MAX_TAP_POS_DELTA = 15
local MAX_TAP_TIME_DELTA = 0.75
local SEAT_OFFSET = Vector3.new(0, 5, 0)
local VR_SEAT_OFFSET = Vector3.new(0, 4, 0)
local HEAD_OFFSET = Vector3.new(0, 1.5, 0)
local R15_HEAD_OFFSET = Vector3.new(0, 2, 0)
local R15_HEAD_OFFSET_NO_SCALING = Vector3.new(0, 2, 0)
local HUMANOID_ROOT_PART_SIZE = Vector3.new(2, 2, 1)
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local adjustHumanoidRootPartFlagExists, adjustHumanoidRootPartFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserAdjustHumanoidRootPartToHipPosition")
end)
local FFlagUserAdjustHumanoidRootPartToHipPosition = adjustHumanoidRootPartFlagExists and adjustHumanoidRootPartFlagEnabled
if FFlagUserAdjustHumanoidRootPartToHipPosition then
	R15_HEAD_OFFSET = Vector3.new(0, 1.5, 0)
end
local noDynamicThumbstickRecenterFlagExists, noDynamicThumbstickRecenterFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNoDynamicThumbstickRecenter")
end)
local FFlagUserNoDynamicThumbstickRecenter = noDynamicThumbstickRecenterFlagExists and noDynamicThumbstickRecenterFlagEnabled
local thumbstickUseCASFlagSuccess, thumbstickUseCASFlagValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserDynamicThumbstickUseContextActionSevice")
end)
local FFlagDynamicThumbstickUseContextActionSevice = thumbstickUseCASFlagSuccess and thumbstickUseCASFlagValue
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local ZoomController = require(script.Parent:WaitForChild("ZoomController"))
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local GuiService = game:GetService("GuiService")
local ContextActionService = game:GetService("ContextActionService")
local VRService = game:GetService("VRService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local BaseCamera = {}
BaseCamera.__index = BaseCamera
function BaseCamera.new()
	local self = setmetatable({}, BaseCamera)
	self.FIRST_PERSON_DISTANCE_THRESHOLD = FIRST_PERSON_DISTANCE_THRESHOLD
	self.cameraType = nil
	self.cameraMovementMode = nil
	local player = Players.LocalPlayer
	self.lastCameraTransform = nil
	self.rotateInput = ZERO_VECTOR2
	self.userPanningCamera = false
	self.lastUserPanCamera = tick()
	self.humanoidRootPart = nil
	self.humanoidCache = {}
	self.lastSubject = nil
	self.lastSubjectPosition = Vector3.new(0, 5, 0)
	self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)
	self.currentSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)
	self.inFirstPerson = false
	self.inMouseLockedMode = false
	self.portraitMode = false
	self.isSmallTouchScreen = false
	self.resetCameraAngle = true
	self.enabled = false
	self.inputBeganConn = nil
	self.inputChangedConn = nil
	self.inputEndedConn = nil
	self.startPos = nil
	self.lastPos = nil
	self.panBeginLook = nil
	self.panEnabled = true
	self.keyPanEnabled = true
	self.distanceChangeEnabled = true
	self.PlayerGui = nil
	self.cameraChangedConn = nil
	self.viewportSizeChangedConn = nil
	self.boundContextActions = {}
	self.shouldUseVRRotation = false
	self.VRRotationIntensityAvailable = false
	self.lastVRRotationIntensityCheckTime = 0
	self.lastVRRotationTime = 0
	self.vrRotateKeyCooldown = {}
	self.cameraTranslationConstraints = Vector3.new(1, 1, 1)
	self.humanoidJumpOrigin = nil
	self.trackingHumanoid = nil
	self.cameraFrozen = false
	self.subjectStateChangedConn = nil
	self.activeGamepad = nil
	self.gamepadPanningCamera = false
	self.lastThumbstickRotate = nil
	self.numOfSeconds = 0.7
	self.currentSpeed = 0
	self.maxSpeed = 6
	self.vrMaxSpeed = 4
	self.lastThumbstickPos = Vector2.new(0, 0)
	self.ySensitivity = 0.65
	self.lastVelocity = nil
	self.gamepadConnectedConn = nil
	self.gamepadDisconnectedConn = nil
	self.currentZoomSpeed = 1
	self.L3ButtonDown = false
	self.dpadLeftDown = false
	self.dpadRightDown = false
	self.isDynamicThumbstickEnabled = false
	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	self.inputStartPositions = {}
	self.inputStartTimes = {}
	self.startingDiff = nil
	self.pinchBeginZoom = nil
	self.userPanningTheCamera = false
	self.touchActivateConn = nil
	self.mouseLockOffset = ZERO_VECTOR3
	if player.Character then
		self:OnCharacterAdded(player.Character)
	end
	player.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char)
	end)
	if self.cameraChangedConn then
		self.cameraChangedConn:Disconnect()
	end
	self.cameraChangedConn = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		self:OnCurrentCameraChanged()
	end)
	self:OnCurrentCameraChanged()
	if self.playerCameraModeChangeConn then
		self.playerCameraModeChangeConn:Disconnect()
	end
	self.playerCameraModeChangeConn = player:GetPropertyChangedSignal("CameraMode"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)
	if self.minDistanceChangeConn then
		self.minDistanceChangeConn:Disconnect()
	end
	self.minDistanceChangeConn = player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)
	if self.maxDistanceChangeConn then
		self.maxDistanceChangeConn:Disconnect()
	end
	self.maxDistanceChangeConn = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)
	if self.playerDevTouchMoveModeChangeConn then
		self.playerDevTouchMoveModeChangeConn:Disconnect()
	end
	self.playerDevTouchMoveModeChangeConn = player:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
		self:OnDevTouchMovementModeChanged()
	end)
	self:OnDevTouchMovementModeChanged()
	if self.gameSettingsTouchMoveMoveChangeConn then
		self.gameSettingsTouchMoveMoveChangeConn:Disconnect()
	end
	self.gameSettingsTouchMoveMoveChangeConn = UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
		self:OnGameSettingsTouchMovementModeChanged()
	end)
	self:OnGameSettingsTouchMovementModeChanged()
	UserGameSettings:SetCameraYInvertVisible()
	UserGameSettings:SetGamepadCameraSensitivityVisible()
	self.hasGameLoaded = game:IsLoaded()
	if not self.hasGameLoaded then
		self.gameLoadedConn = game.Loaded:Connect(function()
			self.hasGameLoaded = true
			self.gameLoadedConn:Disconnect()
			self.gameLoadedConn = nil
		end)
	end
	return self
end
function BaseCamera:GetModuleName()
	return "BaseCamera"
end
function BaseCamera:OnCharacterAdded(char)
	self.resetCameraAngle = self.resetCameraAngle or self:GetEnabled()
	self.humanoidRootPart = nil
	if UserInputService.TouchEnabled then
		self.PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
		for _, child in ipairs(char:GetChildren()) do
			if child:IsA("Tool") then
				self.isAToolEquipped = true
			end
		end
		char.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				self.isAToolEquipped = true
			end
		end)
		char.ChildRemoved:Connect(function(child)
			if child:IsA("Tool") then
				self.isAToolEquipped = false
			end
		end)
	end
end
function BaseCamera:GetHumanoidRootPart()
	if not self.humanoidRootPart then
		local player = Players.LocalPlayer
		if player.Character then
			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				self.humanoidRootPart = humanoid.RootPart
			end
		end
	end
	return self.humanoidRootPart
end
function BaseCamera:GetBodyPartToFollow(humanoid, isDead)
	if humanoid:GetState() == Enum.HumanoidStateType.Dead then
		local character = humanoid.Parent
		if character and character:IsA("Model") then
			return character:FindFirstChild("Head") or humanoid.RootPart
		end
	end
	return humanoid.RootPart
end
function BaseCamera:GetSubjectPosition()
	local result = self.lastSubjectPosition
	local camera = game.Workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject
	if cameraSubject then
		if cameraSubject:IsA("Humanoid") then
			local humanoid = cameraSubject
			local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead
			if VRService.VREnabled and humanoidIsDead and humanoid == self.lastSubject then
				result = self.lastSubjectPosition
			else
				local bodyPartToFollow = humanoid.RootPart
				bodyPartToFollow = humanoidIsDead and humanoid.Parent and humanoid.Parent:IsA("Model") and humanoid.Parent:FindFirstChild("Head") or bodyPartToFollow
				if bodyPartToFollow and bodyPartToFollow:IsA("BasePart") then
					local heightOffset
					if FFlagUserAdjustHumanoidRootPartToHipPosition then
						if humanoid.RigType == Enum.HumanoidRigType.R15 then
							if humanoid.AutomaticScalingEnabled then
								heightOffset = R15_HEAD_OFFSET
								if bodyPartToFollow == humanoid.RootPart then
									local rootPartSizeOffset = humanoid.RootPart.Size.Y / 2 - HUMANOID_ROOT_PART_SIZE.Y / 2
									heightOffset = heightOffset + Vector3.new(0, rootPartSizeOffset, 0)
								end
							else
								heightOffset = R15_HEAD_OFFSET_NO_SCALING
							end
						else
							heightOffset = HEAD_OFFSET
						end
					else
						heightOffset = humanoid.RigType == Enum.HumanoidRigType.R15 and R15_HEAD_OFFSET or HEAD_OFFSET
					end
					if humanoidIsDead then
						heightOffset = ZERO_VECTOR3
					end
					result = bodyPartToFollow.CFrame.p + bodyPartToFollow.CFrame:vectorToWorldSpace(heightOffset + humanoid.CameraOffset)
				end
			end
		elseif cameraSubject:IsA("VehicleSeat") then
			local offset = SEAT_OFFSET
			if VRService.VREnabled then
				offset = VR_SEAT_OFFSET
			end
			result = cameraSubject.CFrame.p + cameraSubject.CFrame:vectorToWorldSpace(offset)
		elseif cameraSubject:IsA("SkateboardPlatform") then
			result = cameraSubject.CFrame.p + SEAT_OFFSET
		elseif cameraSubject:IsA("BasePart") then
			result = cameraSubject.CFrame.p
		elseif cameraSubject:IsA("Model") then
			if cameraSubject.PrimaryPart then
				result = cameraSubject:GetPrimaryPartCFrame().p
			else
				result = cameraSubject:GetModelCFrame().p
			end
		end
	else
		return
	end
	self.lastSubject = cameraSubject
	self.lastSubjectPosition = result
	return result
end
function BaseCamera:UpdateDefaultSubjectDistance()
	local player = Players.LocalPlayer
	if self.portraitMode then
		self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, PORTRAIT_DEFAULT_DISTANCE)
	else
		self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)
	end
end
function BaseCamera:OnViewportSizeChanged()
	local camera = game.Workspace.CurrentCamera
	local size = camera.ViewportSize
	self.portraitMode = size.X < size.Y
	self.isSmallTouchScreen = UserInputService.TouchEnabled and (size.Y < 500 or size.X < 700)
	self:UpdateDefaultSubjectDistance()
end
function BaseCamera:OnCurrentCameraChanged()
	if UserInputService.TouchEnabled then
		if self.viewportSizeChangedConn then
			self.viewportSizeChangedConn:Disconnect()
			self.viewportSizeChangedConn = nil
		end
		local newCamera = game.Workspace.CurrentCamera
		if newCamera then
			self:OnViewportSizeChanged()
			self.viewportSizeChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
				self:OnViewportSizeChanged()
			end)
		end
	end
	if self.cameraSubjectChangedConn then
		self.cameraSubjectChangedConn:Disconnect()
		self.cameraSubjectChangedConn = nil
	end
	local camera = game.Workspace.CurrentCamera
	if camera then
		self.cameraSubjectChangedConn = camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
			self:OnNewCameraSubject()
		end)
		self:OnNewCameraSubject()
	end
end
function BaseCamera:OnDynamicThumbstickEnabled()
	if UserInputService.TouchEnabled then
		self.isDynamicThumbstickEnabled = true
	end
end
function BaseCamera:OnDynamicThumbstickDisabled()
	self.isDynamicThumbstickEnabled = false
end
function BaseCamera:OnGameSettingsTouchMovementModeChanged()
	if Players.LocalPlayer.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice then
		if FFlagUserNoDynamicThumbstickRecenter then
			if UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.DynamicThumbstick or UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.Default then
				self:OnDynamicThumbstickEnabled()
			else
				self:OnDynamicThumbstickDisabled()
			end
		elseif UserGameSettings.TouchMovementMode.Name == "DynamicThumbstick" then
			self:OnDynamicThumbstickEnabled()
		else
			self:OnDynamicThumbstickDisabled()
		end
	end
end
function BaseCamera:OnDevTouchMovementModeChanged()
	if Players.LocalPlayer.DevTouchMovementMode.Name == "DynamicThumbstick" then
		self:OnDynamicThumbstickEnabled()
	else
		self:OnGameSettingsTouchMovementModeChanged()
	end
end
function BaseCamera:OnPlayerCameraPropertyChange()
	self:SetCameraToSubjectDistance(self.currentSubjectDistance)
end
function BaseCamera:GetCameraHeight()
	if VRService.VREnabled and not self.inFirstPerson then
		return math.sin(VR_ANGLE) * self.currentSubjectDistance
	end
	return 0
end
function BaseCamera:InputTranslationToCameraAngleChange(translationVector, sensitivity)
	local camera = game.Workspace.CurrentCamera
	if camera and camera.ViewportSize.X > 0 and 0 < camera.ViewportSize.Y and camera.ViewportSize.Y > camera.ViewportSize.X then
		return translationVector * Vector2.new(sensitivity.Y, sensitivity.X)
	end
	return translationVector * sensitivity
end
function BaseCamera:Enable(enable)
	if self.enabled ~= enable then
		self.enabled = enable
		if self.enabled then
			self:ConnectInputEvents()
			if FFlagPlayerScriptsBindAtPriority2 then
				self:BindContextActions()
			end
			if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
				self.currentSubjectDistance = 0.5
				if not self.inFirstPerson then
					self:EnterFirstPerson()
				end
			end
		else
			self:DisconnectInputEvents()
			if FFlagPlayerScriptsBindAtPriority2 then
				self:UnbindContextActions()
			end
			self:Cleanup()
		end
	end
end
function BaseCamera:GetEnabled()
	return self.enabled
end
function BaseCamera:OnInputBegan(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchBegan(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		self:OnMouse2Down(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
		self:OnMouse3Down(input, processed)
	end
	if not FFlagPlayerScriptsBindAtPriority2 and input.UserInputType == Enum.UserInputType.Keyboard then
		self:OnKeyDown(input, processed)
	end
end
function BaseCamera:OnInputChanged(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchChanged(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseMovement then
		self:OnMouseMoved(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseWheel then
		self:OnMouseWheel(input, processed)
	end
end
function BaseCamera:OnInputEnded(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchEnded(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		self:OnMouse2Up(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
		self:OnMouse3Up(input, processed)
	end
	if not FFlagPlayerScriptsBindAtPriority2 and input.UserInputType == Enum.UserInputType.Keyboard then
		self:OnKeyUp(input, processed)
	end
end
function BaseCamera:ConnectInputEvents()
	self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
		self:OnInputBegan(input, processed)
	end)
	self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
		self:OnInputChanged(input, processed)
	end)
	self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
		self:OnInputEnded(input, processed)
	end)
	if not FFlagUserNoDynamicThumbstickRecenter then
		self.touchActivateConn = UserInputService.TouchTapInWorld:Connect(function(touchPos, processed)
			self:OnTouchTap(touchPos)
		end)
	end
	self.menuOpenedConn = GuiService.MenuOpened:connect(function()
		self:ResetInputStates()
	end)
	self.gamepadConnectedConn = UserInputService.GamepadDisconnected:connect(function(gamepadEnum)
		if self.activeGamepad ~= gamepadEnum then
			return
		end
		self.activeGamepad = nil
		self:AssignActivateGamepad()
	end)
	self.gamepadDisconnectedConn = UserInputService.GamepadConnected:connect(function(gamepadEnum)
		if self.activeGamepad == nil then
			self:AssignActivateGamepad()
		end
	end)
	if not FFlagPlayerScriptsBindAtPriority2 then
		self:BindGamepadInputActions()
	end
	self:AssignActivateGamepad()
	self:UpdateMouseBehavior()
end
function BaseCamera:BindContextActions()
	self:BindGamepadInputActions()
	self:BindKeyboardInputActions()
end
function BaseCamera:AssignActivateGamepad()
	local connectedGamepads = UserInputService:GetConnectedGamepads()
	if #connectedGamepads > 0 then
		for i = 1, #connectedGamepads do
			if self.activeGamepad == nil then
				self.activeGamepad = connectedGamepads[i]
			elseif connectedGamepads[i].Value < self.activeGamepad.Value then
				self.activeGamepad = connectedGamepads[i]
			end
		end
	end
	if self.activeGamepad == nil then
		self.activeGamepad = Enum.UserInputType.Gamepad1
	end
end
function BaseCamera:DisconnectInputEvents()
	if self.inputBeganConn then
		self.inputBeganConn:Disconnect()
		self.inputBeganConn = nil
	end
	if self.inputChangedConn then
		self.inputChangedConn:Disconnect()
		self.inputChangedConn = nil
	end
	if self.inputEndedConn then
		self.inputEndedConn:Disconnect()
		self.inputEndedConn = nil
	end
end
function BaseCamera:UnbindContextActions()
	for i = 1, #self.boundContextActions do
		ContextActionService:UnbindAction(self.boundContextActions[i])
	end
	self.boundContextActions = {}
end
function BaseCamera:Cleanup()
	if self.menuOpenedConn then
		self.menuOpenedConn:Disconnect()
		self.menuOpenedConn = nil
	end
	if self.mouseLockToggleConn then
		self.mouseLockToggleConn:Disconnect()
		self.mouseLockToggleConn = nil
	end
	if self.gamepadConnectedConn then
		self.gamepadConnectedConn:Disconnect()
		self.gamepadConnectedConn = nil
	end
	if self.gamepadDisconnectedConn then
		self.gamepadDisconnectedConn:Disconnect()
		self.gamepadDisconnectedConn = nil
	end
	if self.subjectStateChangedConn then
		self.subjectStateChangedConn:Disconnect()
		self.subjectStateChangedConn = nil
	end
	if self.viewportSizeChangedConn then
		self.viewportSizeChangedConn:Disconnect()
		self.viewportSizeChangedConn = nil
	end
	if self.touchActivateConn then
		self.touchActivateConn:Disconnect()
		self.touchActivateConn = nil
	end
	self.turningLeft = false
	self.turningRight = false
	self.lastCameraTransform = nil
	self.lastSubjectCFrame = nil
	self.userPanningTheCamera = false
	self.rotateInput = Vector2.new()
	self.gamepadPanningCamera = Vector2.new(0, 0)
	self.startPos = nil
	self.lastPos = nil
	self.panBeginLook = nil
	self.isRightMouseDown = false
	self.isMiddleMouseDown = false
	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	self.startingDiff = nil
	self.pinchBeginZoom = nil
	if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end
function BaseCamera:ResetInputStates()
	self.isRightMouseDown = false
	self.isMiddleMouseDown = false
	self:OnMousePanButtonReleased()
	if UserInputService.TouchEnabled then
		for inputObject in pairs(self.fingerTouches) do
			self.fingerTouches[inputObject] = nil
		end
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
		self.startingDiff = nil
		self.pinchBeginZoom = nil
		self.numUnsunkTouches = 0
	end
end
function BaseCamera:GetGamepadPan(name, state, input)
	if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
		if state == Enum.UserInputState.Cancel then
			self.gamepadPanningCamera = ZERO_VECTOR2
			return
		end
		local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
		if inputVector.magnitude > THUMBSTICK_DEADZONE then
			self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
		else
			self.gamepadPanningCamera = ZERO_VECTOR2
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function BaseCamera:DoKeyboardPanTurn(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end
	if state == Enum.UserInputState.Cancel then
		self.turningLeft = false
		self.turningRight = false
		return Enum.ContextActionResult.Sink
	end
	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Left then
			self.turningLeft = state == Enum.UserInputState.Begin
		elseif input.KeyCode == Enum.KeyCode.Right then
			self.turningRight = state == Enum.UserInputState.Begin
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function BaseCamera:DoPanRotateCamera(rotateAngle)
	local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1, 0, 1), rotateAngle, math.pi * 0.25)
	if angle ~= 0 then
		self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
		self.lastUserPanCamera = tick()
		self.lastCameraTransform = nil
	end
end
function BaseCamera:DoKeyboardPan(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end
	if state ~= Enum.UserInputState.Begin then
		return Enum.ContextActionResult.Pass
	end
	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Comma then
			self:DoPanRotateCamera(-math.pi * 0.1875)
		elseif input.KeyCode == Enum.KeyCode.Period then
			self:DoPanRotateCamera(math.pi * 0.1875)
		elseif input.KeyCode == Enum.KeyCode.PageUp then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(15))
			self.lastCameraTransform = nil
		elseif input.KeyCode == Enum.KeyCode.PageDown then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(-15))
			self.lastCameraTransform = nil
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function BaseCamera:DoGamepadZoom(name, state, input)
	if input.UserInputType == self.activeGamepad then
		if input.KeyCode == Enum.KeyCode.ButtonR3 then
			if state == Enum.UserInputState.Begin and self.distanceChangeEnabled then
				if self:GetCameraToSubjectDistance() > 0.5 then
					self:SetCameraToSubjectDistance(0)
				else
					self:SetCameraToSubjectDistance(10)
				end
			end
		elseif input.KeyCode == Enum.KeyCode.DPadLeft then
			self.dpadLeftDown = state == Enum.UserInputState.Begin
		elseif input.KeyCode == Enum.KeyCode.DPadRight then
			self.dpadRightDown = state == Enum.UserInputState.Begin
		end
		if self.dpadLeftDown then
			self.currentZoomSpeed = 1.04
		elseif self.dpadRightDown then
			self.currentZoomSpeed = 0.96
		else
			self.currentZoomSpeed = 1
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function BaseCamera:DoKeyboardZoom(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end
	if state ~= Enum.UserInputState.Begin then
		return Enum.ContextActionResult.Pass
	end
	if self.distanceChangeEnabled and Players.LocalPlayer.CameraMode ~= Enum.CameraMode.LockFirstPerson then
		if input.KeyCode == Enum.KeyCode.I then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance - 5)
		elseif input.KeyCode == Enum.KeyCode.O then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance + 5)
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function BaseCamera:BindAction(actionName, actionFunc, createTouchButton, ...)
	table.insert(self.boundContextActions, actionName)
	ContextActionService:BindActionAtPriority(actionName, actionFunc, createTouchButton, CAMERA_ACTION_PRIORITY, ...)
end
function BaseCamera:BindGamepadInputActions()
	if FFlagPlayerScriptsBindAtPriority2 then
		self:BindAction("BaseCameraGamepadPan", function(name, state, input)
			return self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		self:BindAction("BaseCameraGamepadZoom", function(name, state, input)
			return self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.DPadLeft, Enum.KeyCode.DPadRight, Enum.KeyCode.ButtonR3)
	else
		ContextActionService:BindAction("RootCamGamepadPan", function(name, state, input)
			self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		ContextActionService:BindAction("RootCamGamepadZoom", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonR3)
		ContextActionService:BindAction("RootGamepadZoomOut", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.DPadLeft)
		ContextActionService:BindAction("RootGamepadZoomIn", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.DPadRight)
	end
end
function BaseCamera:BindKeyboardInputActions()
	self:BindAction("BaseCameraKeyboardPanArrowKeys", function(name, state, input)
		return self:DoKeyboardPanTurn(name, state, input)
	end, false, Enum.KeyCode.Left, Enum.KeyCode.Right)
	self:BindAction("BaseCameraKeyboardPan", function(name, state, input)
		return self:DoKeyboardPan(name, state, input)
	end, false, Enum.KeyCode.Comma, Enum.KeyCode.Period, Enum.KeyCode.PageUp, Enum.KeyCode.PageDown)
	self:BindAction("BaseCameraKeyboardZoom", function(name, state, input)
		return self:DoKeyboardZoom(name, state, input)
	end, false, Enum.KeyCode.I, Enum.KeyCode.O)
end
function BaseCamera:OnTouchBegan(input, processed)
	local canUseDynamicTouch = self.isDynamicThumbstickEnabled and not processed
	if canUseDynamicTouch then
		self.fingerTouches[input] = processed
		if not processed then
			self.inputStartPositions[input] = input.Position
			self.inputStartTimes[input] = tick()
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
end
function BaseCamera:OnTouchChanged(input, processed)
	if self.fingerTouches[input] == nil then
		if self.isDynamicThumbstickEnabled then
			return
		end
		self.fingerTouches[input] = processed
		if not processed then
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	elseif FFlagDynamicThumbstickUseContextActionSevice and self.isDynamicThumbstickEnabled and self.fingerTouches[input] ~= processed then
		self.fingerTouches[input] = processed
		if processed then
			self.numUnsunkTouches = self.numUnsunkTouches - 1
		else
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
	if self.numUnsunkTouches == 1 then
		if self.fingerTouches[input] == false then
			self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
			self.startPos = self.startPos or input.Position
			self.lastPos = self.lastPos or self.startPos
			self.userPanningTheCamera = true
			local delta = input.Position - self.lastPos
			delta = Vector2.new(delta.X, delta.Y * UserGameSettings:GetCameraYInvertValue())
			if self.panEnabled then
				local desiredXYVector = self:InputTranslationToCameraAngleChange(delta, TOUCH_SENSITIVTY)
				self.rotateInput = self.rotateInput + desiredXYVector
			end
			self.lastPos = input.Position
		end
	else
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
	end
	if self.numUnsunkTouches == 2 then
		local unsunkTouches = {}
		for touch, wasSunk in pairs(self.fingerTouches) do
			if not wasSunk then
				table.insert(unsunkTouches, touch)
			end
		end
		if #unsunkTouches == 2 then
			local difference = (unsunkTouches[1].Position - unsunkTouches[2].Position).magnitude
			if self.startingDiff and self.pinchBeginZoom then
				local scale = difference / math.max(0.01, self.startingDiff)
				local clampedScale = Util.Clamp(0.1, 10, scale)
				if self.distanceChangeEnabled then
					self:SetCameraToSubjectDistance(self.pinchBeginZoom / clampedScale)
				end
			else
				self.startingDiff = difference
				self.pinchBeginZoom = self:GetCameraToSubjectDistance()
			end
		end
	else
		self.startingDiff = nil
		self.pinchBeginZoom = nil
	end
end
function BaseCamera:CalcLookBehindRotateInput()
	if not self.humanoidRootPart or not game.Workspace.CurrentCamera then
		return nil
	end
	local cameraLookVector = game.Workspace.CurrentCamera.CFrame.lookVector
	local newDesiredLook = (self.humanoidRootPart.CFrame.lookVector - Vector3.new(0, 0.23, 0)).unit
	local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, cameraLookVector)
	local vertShift = math.asin(cameraLookVector.Y) - math.asin(newDesiredLook.Y)
	if not Util.IsFinite(horizontalShift) then
		horizontalShift = 0
	end
	if not Util.IsFinite(vertShift) then
		vertShift = 0
	end
	return Vector2.new(horizontalShift, vertShift)
end
function BaseCamera:OnTouchTap(position)
	if self.isDynamicThumbstickEnabled and not self.isAToolEquipped then
		if self.lastTapTime and tick() - self.lastTapTime < MAX_TIME_FOR_DOUBLE_TAP then
			self:SetCameraToSubjectDistance(self.defaultSubjectDistance)
		elseif self.humanoidRootPart then
			self.rotateInput = self:CalcLookBehindRotateInput()
		end
		self.lastTapTime = tick()
	end
end
function BaseCamera:IsTouchTap(input)
	if self.inputStartPositions[input] then
		local posDelta = (self.inputStartPositions[input] - input.Position).magnitude
		if posDelta < MAX_TAP_POS_DELTA then
			local timeDelta = self.inputStartTimes[input] - tick()
			if timeDelta < MAX_TAP_TIME_DELTA then
				return true
			end
		end
	end
	return false
end
function BaseCamera:OnTouchEnded(input, processed)
	if self.fingerTouches[input] == false then
		if self.numUnsunkTouches == 1 then
			self.panBeginLook = nil
			self.startPos = nil
			self.lastPos = nil
			self.userPanningTheCamera = false
			if not FFlagUserNoDynamicThumbstickRecenter and self:IsTouchTap(input) then
				self:OnTouchTap(input.Position)
			end
		elseif self.numUnsunkTouches == 2 then
			self.startingDiff = nil
			self.pinchBeginZoom = nil
		end
	end
	if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
		self.numUnsunkTouches = self.numUnsunkTouches - 1
	end
	self.fingerTouches[input] = nil
	self.inputStartPositions[input] = nil
	self.inputStartTimes[input] = nil
end
function BaseCamera:OnMouse2Down(input, processed)
	if processed then
		return
	end
	self.isRightMouseDown = true
	self:OnMousePanButtonPressed(input, processed)
end
function BaseCamera:OnMouse2Up(input, processed)
	self.isRightMouseDown = false
	self:OnMousePanButtonReleased(input, processed)
end
function BaseCamera:OnMouse3Down(input, processed)
	if processed then
		return
	end
	self.isMiddleMouseDown = true
	self:OnMousePanButtonPressed(input, processed)
end
function BaseCamera:OnMouse3Up(input, processed)
	self.isMiddleMouseDown = false
	self:OnMousePanButtonReleased(input, processed)
end
function BaseCamera:OnMouseMoved(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end
	local inputDelta = input.Delta
	inputDelta = Vector2.new(inputDelta.X, inputDelta.Y * UserGameSettings:GetCameraYInvertValue())
	if self.panEnabled and (self.startPos and self.lastPos and self.panBeginLook or self.inFirstPerson or self.inMouseLockedMode) then
		local desiredXYVector = self:InputTranslationToCameraAngleChange(inputDelta, MOUSE_SENSITIVITY)
		self.rotateInput = self.rotateInput + desiredXYVector
	end
	if self.startPos and self.lastPos and self.panBeginLook then
		self.lastPos = self.lastPos + input.Delta
	end
end
function BaseCamera:OnMousePanButtonPressed(input, processed)
	if processed then
		return
	end
	self:UpdateMouseBehavior()
	self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
	self.startPos = self.startPos or input.Position
	self.lastPos = self.lastPos or self.startPos
	self.userPanningTheCamera = true
end
function BaseCamera:OnMousePanButtonReleased(input, processed)
	self:UpdateMouseBehavior()
	if not self.isRightMouseDown and not self.isMiddleMouseDown then
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
	end
end
function BaseCamera:OnMouseWheel(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end
	if not processed and self.distanceChangeEnabled then
		local wheelInput = Util.Clamp(-1, 1, -input.Position.Z)
		local newDistance
		if self.inFirstPerson and wheelInput > 0 then
			newDistance = FIRST_PERSON_DISTANCE_THRESHOLD
		else
			newDistance = self.currentSubjectDistance + 0.156 * self.currentSubjectDistance * wheelInput + 1.7 * math.sign(wheelInput)
		end
		self:SetCameraToSubjectDistance(newDistance)
	end
end
function BaseCamera:OnKeyDown(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end
	if processed then
		return
	end
	if self.distanceChangeEnabled then
		if input.KeyCode == Enum.KeyCode.I then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance - 5)
		elseif input.KeyCode == Enum.KeyCode.O then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance + 5)
		end
	end
	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Left then
			self.turningLeft = true
		elseif input.KeyCode == Enum.KeyCode.Right then
			self.turningRight = true
		elseif input.KeyCode == Enum.KeyCode.Comma then
			local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1, 0, 1), -math.pi * 0.1875, math.pi * 0.25)
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
				self.lastUserPanCamera = tick()
				self.lastCameraTransform = nil
			end
		elseif input.KeyCode == Enum.KeyCode.Period then
			local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1, 0, 1), math.pi * 0.1875, math.pi * 0.25)
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
				self.lastUserPanCamera = tick()
				self.lastCameraTransform = nil
			end
		elseif input.KeyCode == Enum.KeyCode.PageUp then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(15))
			self.lastCameraTransform = nil
		elseif input.KeyCode == Enum.KeyCode.PageDown then
			self.rotateInput = self.rotateInput + Vector2.new(0, math.rad(-15))
			self.lastCameraTransform = nil
		end
	end
end
function BaseCamera:OnKeyUp(input, processed)
	if input.KeyCode == Enum.KeyCode.Left then
		self.turningLeft = false
	elseif input.KeyCode == Enum.KeyCode.Right then
		self.turningRight = false
	end
end
function BaseCamera:UpdateMouseBehavior()
	if self.inFirstPerson or self.inMouseLockedMode then
		UserGameSettings.RotationType = Enum.RotationType.CameraRelative
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	else
		UserGameSettings.RotationType = Enum.RotationType.MovementRelative
		if self.isRightMouseDown or self.isMiddleMouseDown then
			UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		else
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	end
end
function BaseCamera:UpdateForDistancePropertyChange()
	self:SetCameraToSubjectDistance(self.currentSubjectDistance)
end
function BaseCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	local player = Players.LocalPlayer
	local lastSubjectDistance = self.currentSubjectDistance
	if player.CameraMode == Enum.CameraMode.LockFirstPerson then
		self.currentSubjectDistance = 0.5
		if not self.inFirstPerson then
			self:EnterFirstPerson()
		end
	else
		local newSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, desiredSubjectDistance)
		if newSubjectDistance < FIRST_PERSON_DISTANCE_THRESHOLD then
			self.currentSubjectDistance = 0.5
			if not self.inFirstPerson then
				self:EnterFirstPerson()
			end
		else
			self.currentSubjectDistance = newSubjectDistance
			if self.inFirstPerson then
				self:LeaveFirstPerson()
			end
		end
	end
	ZoomController.SetZoomParameters(self.currentSubjectDistance, math.sign(desiredSubjectDistance - lastSubjectDistance))
	return self.currentSubjectDistance
end
function BaseCamera:SetCameraType(cameraType)
	self.cameraType = cameraType
end
function BaseCamera:GetCameraType()
	return self.cameraType
end
function BaseCamera:SetCameraMovementMode(cameraMovementMode)
	self.cameraMovementMode = cameraMovementMode
end
function BaseCamera:GetCameraMovementMode()
	return self.cameraMovementMode
end
function BaseCamera:SetIsMouseLocked(mouseLocked)
	self.inMouseLockedMode = mouseLocked
	self:UpdateMouseBehavior()
end
function BaseCamera:GetIsMouseLocked()
	return self.inMouseLockedMode
end
function BaseCamera:SetMouseLockOffset(offsetVector)
	self.mouseLockOffset = offsetVector
end
function BaseCamera:GetMouseLockOffset()
	return self.mouseLockOffset
end
function BaseCamera:InFirstPerson()
	return self.inFirstPerson
end
function BaseCamera:EnterFirstPerson()
end
function BaseCamera:LeaveFirstPerson()
end
function BaseCamera:GetCameraToSubjectDistance()
	return self.currentSubjectDistance
end
function BaseCamera:GetMeasuredDistanceToFocus()
	local camera = game.Workspace.CurrentCamera
	if camera then
		return (camera.CoordinateFrame.p - camera.Focus.p).magnitude
	end
	return nil
end
function BaseCamera:GetCameraLookVector()
	return game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame.lookVector or UNIT_Z
end
function BaseCamera:CalculateNewLookCFrame(suppliedLookVector)
	local currLookVector = suppliedLookVector or self:GetCameraLookVector()
	local currPitchAngle = math.asin(currLookVector.y)
	local yTheta = Util.Clamp(-MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle, self.rotateInput.y)
	local constrainedRotateInput = Vector2.new(self.rotateInput.x, yTheta)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y, 0, 0)
	return newLookCFrame
end
function BaseCamera:CalculateNewLookVector(suppliedLookVector)
	local newLookCFrame = self:CalculateNewLookCFrame(suppliedLookVector)
	return newLookCFrame.lookVector
end
function BaseCamera:CalculateNewLookVectorVR()
	local subjectPosition = self:GetSubjectPosition()
	local vecToSubject = subjectPosition - game.Workspace.CurrentCamera.CFrame.p
	local currLookVector = (vecToSubject * X1_Y0_Z1).unit
	local vrRotateInput = Vector2.new(self.rotateInput.x, 0)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local yawRotatedVector = (CFrame.Angles(0, -vrRotateInput.x, 0) * startCFrame * CFrame.Angles(-vrRotateInput.y, 0, 0)).lookVector
	return (yawRotatedVector * X1_Y0_Z1).unit
end
function BaseCamera:GetHumanoid()
	local player = Players.LocalPlayer
	local character = player and player.Character
	if character then
		local resultHumanoid = self.humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			self.humanoidCache[player] = nil
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				self.humanoidCache[player] = humanoid
			end
			return humanoid
		end
	end
	return nil
end
function BaseCamera:GetHumanoidPartToFollow(humanoid, humanoidStateType)
	if humanoidStateType == Enum.HumanoidStateType.Dead then
		local character = humanoid.Parent
		if character then
			return character:FindFirstChild("Head") or humanoid.Torso
		else
			return humanoid.Torso
		end
	else
		return humanoid.Torso
	end
end
function BaseCamera:UpdateGamepad()
	local gamepadPan = self.gamepadPanningCamera
	if gamepadPan and (self.hasGameLoaded or not VRService.VREnabled) then
		gamepadPan = Util.GamepadLinearToCurve(gamepadPan)
		local currentTime = tick()
		if gamepadPan.X ~= 0 or gamepadPan.Y ~= 0 then
			self.userPanningTheCamera = true
		elseif gamepadPan == ZERO_VECTOR2 then
			self.lastThumbstickRotate = nil
			if self.lastThumbstickPos == ZERO_VECTOR2 then
				self.currentSpeed = 0
			end
		end
		local finalConstant = 0
		if self.lastThumbstickRotate then
			if VRService.VREnabled then
				self.currentSpeed = self.vrMaxSpeed
			else
				local elapsedTime = (currentTime - self.lastThumbstickRotate) * 10
				self.currentSpeed = self.currentSpeed + self.maxSpeed * (elapsedTime * elapsedTime / self.numOfSeconds)
				if self.currentSpeed > self.maxSpeed then
					self.currentSpeed = self.maxSpeed
				end
				if self.lastVelocity then
					local velocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickRotate)
					local velocityDeltaMag = (velocity - self.lastVelocity).magnitude
					if velocityDeltaMag > 12 then
						self.currentSpeed = self.currentSpeed * (20 / velocityDeltaMag)
						if self.currentSpeed > self.maxSpeed then
							self.currentSpeed = self.maxSpeed
						end
					end
				end
			end
			finalConstant = UserGameSettings.GamepadCameraSensitivity * self.currentSpeed
			self.lastVelocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickRotate)
		end
		self.lastThumbstickPos = gamepadPan
		self.lastThumbstickRotate = currentTime
		return Vector2.new(gamepadPan.X * finalConstant, gamepadPan.Y * finalConstant * self.ySensitivity * UserGameSettings:GetCameraYInvertValue())
	end
	return ZERO_VECTOR2
end
function BaseCamera:ApplyVRTransform()
	if not VRService.VREnabled then
		return
	end
	local rootJoint = self.humanoidRootPart and self.humanoidRootPart:FindFirstChild("RootJoint")
	if not rootJoint then
		return
	end
	local cameraSubject = game.Workspace.CurrentCamera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	if self.inFirstPerson and not isInVehicle then
		local vrFrame = VRService:GetUserCFrame(Enum.UserCFrame.Head)
		local vrRotation = vrFrame - vrFrame.p
		rootJoint.C0 = CFrame.new(vrRotation:vectorToObjectSpace(vrFrame.p)) * CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	else
		rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	end
end
function BaseCamera:IsInFirstPerson()
	return self.inFirstPerson
end
function BaseCamera:ShouldUseVRRotation()
	if not VRService.VREnabled then
		return false
	end
	if not self.VRRotationIntensityAvailable and tick() - self.lastVRRotationIntensityCheckTime < 1 then
		return false
	end
	local success, vrRotationIntensity = pcall(function()
		return StarterGui:GetCore("VRRotationIntensity")
	end)
	self.VRRotationIntensityAvailable = success and vrRotationIntensity ~= nil
	self.lastVRRotationIntensityCheckTime = tick()
	self.shouldUseVRRotation = success and vrRotationIntensity ~= nil and vrRotationIntensity ~= "Smooth"
	return self.shouldUseVRRotation
end
function BaseCamera:GetVRRotationInput()
	local vrRotateSum = ZERO_VECTOR2
	local success, vrRotationIntensity = pcall(function()
		return StarterGui:GetCore("VRRotationIntensity")
	end)
	if not success then
		return
	end
	local vrGamepadRotation = self.GamepadPanningCamera or ZERO_VECTOR2
	local delayExpired = tick() - self.lastVRRotationTime >= self:GetRepeatDelayValue(vrRotationIntensity)
	if math.abs(vrGamepadRotation.x) >= self:GetActivateValue() then
		if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] then
			local sign = 1
			if vrGamepadRotation.x < 0 then
				sign = -1
			end
			vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity) * sign
			self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = true
		end
	elseif math.abs(vrGamepadRotation.x) < self:GetActivateValue() - 0.1 then
		self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = nil
	end
	if self.turningLeft then
		if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Left] then
			vrRotateSum = vrRotateSum - self:GetRotateAmountValue(vrRotationIntensity)
			self.vrRotateKeyCooldown[Enum.KeyCode.Left] = true
		end
	else
		self.vrRotateKeyCooldown[Enum.KeyCode.Left] = nil
	end
	if self.turningRight then
		if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Right] then
			vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity)
			self.vrRotateKeyCooldown[Enum.KeyCode.Right] = true
		end
	else
		self.vrRotateKeyCooldown[Enum.KeyCode.Right] = nil
	end
	if vrRotateSum ~= ZERO_VECTOR2 then
		self.lastVRRotationTime = tick()
	end
	return vrRotateSum
end
function BaseCamera:CancelCameraFreeze(keepConstraints)
	if not keepConstraints then
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 1, self.cameraTranslationConstraints.z)
	end
	if self.cameraFrozen then
		self.trackingHumanoid = nil
		self.cameraFrozen = false
	end
end
function BaseCamera:StartCameraFreeze(subjectPosition, humanoidToTrack)
	if not self.cameraFrozen then
		self.humanoidJumpOrigin = subjectPosition
		self.trackingHumanoid = humanoidToTrack
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 0, self.cameraTranslationConstraints.z)
		self.cameraFrozen = true
	end
end
function BaseCamera:OnNewCameraSubject()
	if self.subjectStateChangedConn then
		self.subjectStateChangedConn:Disconnect()
		self.subjectStateChangedConn = nil
	end
	local humanoid = workspace.CurrentCamera and workspace.CurrentCamera.CameraSubject
	if self.trackingHumanoid ~= humanoid then
		self:CancelCameraFreeze()
	end
	if humanoid and humanoid:IsA("Humanoid") then
		self.subjectStateChangedConn = humanoid.StateChanged:Connect(function(oldState, newState)
			if VRService.VREnabled and newState == Enum.HumanoidStateType.Jumping and not self.inFirstPerson then
				self:StartCameraFreeze(self:GetSubjectPosition(), humanoid)
			elseif newState ~= Enum.HumanoidStateType.Jumping and newState ~= Enum.HumanoidStateType.Freefall then
				self:CancelCameraFreeze(true)
			end
		end)
	end
end
function BaseCamera:GetVRFocus(subjectPosition, timeDelta)
	local lastFocus = self.LastCameraFocus or subjectPosition
	if not self.cameraFrozen then
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, math.min(1, self.cameraTranslationConstraints.y + 0.42 * timeDelta), self.cameraTranslationConstraints.z)
	end
	local newFocus
	if self.cameraFrozen and self.humanoidJumpOrigin and self.humanoidJumpOrigin.y > lastFocus.y then
		newFocus = CFrame.new(Vector3.new(subjectPosition.x, math.min(self.humanoidJumpOrigin.y, lastFocus.y + 5 * timeDelta), subjectPosition.z))
	else
		newFocus = CFrame.new(Vector3.new(subjectPosition.x, lastFocus.y, subjectPosition.z):lerp(subjectPosition, self.cameraTranslationConstraints.y))
	end
	if self.cameraFrozen then
		if self.inFirstPerson then
			self:CancelCameraFreeze()
		end
		if self.humanoidJumpOrigin and subjectPosition.y < self.humanoidJumpOrigin.y - 0.5 then
			self:CancelCameraFreeze()
		end
	end
	return newFocus
end
function BaseCamera:GetRotateAmountValue(vrRotationIntensity)
	vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
	if vrRotationIntensity then
		if vrRotationIntensity == "Low" then
			return VR_LOW_INTENSITY_ROTATION
		elseif vrRotationIntensity == "High" then
			return VR_HIGH_INTENSITY_ROTATION
		end
	end
	return ZERO_VECTOR2
end
function BaseCamera:GetRepeatDelayValue(vrRotationIntensity)
	vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
	if vrRotationIntensity then
		if vrRotationIntensity == "Low" then
			return VR_LOW_INTENSITY_REPEAT
		elseif vrRotationIntensity == "High" then
			return VR_HIGH_INTENSITY_REPEAT
		end
	end
	return 0
end
function BaseCamera:Test()
	print("BaseCamera:Test()")
end
function BaseCamera:Update(dt)
	warn("BaseCamera:Update() This is a virtual function that should never be getting called.")
	return game.Workspace.CurrentCamera.CFrame, game.Workspace.CurrentCamera.Focus
end
return BaseCamera
]]></ProtectedString><string name="Name">BaseCamera</string></Properties></Item><Item class="ModuleScript" referent="RBX596"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZOOM_STIFFNESS = 4.5
local ZOOM_DEFAULT = 12.5
local ZOOM_ACCELERATION = 0.0375
local MIN_FOCUS_DIST = 0.5
local DIST_OPAQUE = 1
local Popper = require(script:WaitForChild("Popper"))
local clamp = math.clamp
local exp = math.exp
local min = math.min
local max = math.max
local pi = math.pi
local cameraMinZoomDistance, cameraMaxZoomDistance
do
	local Player = game:GetService("Players").LocalPlayer
	local function updateBounds()
		cameraMinZoomDistance = Player.CameraMinZoomDistance
		cameraMaxZoomDistance = Player.CameraMaxZoomDistance
	end
	updateBounds()
	Player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(updateBounds)
	Player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(updateBounds)
end
local ConstrainedSpring = {}
ConstrainedSpring.__index = ConstrainedSpring
function ConstrainedSpring.new(freq, x, minValue, maxValue)
	x = clamp(x, minValue, maxValue)
	return setmetatable({
		freq = freq,
		x = x,
		v = 0,
		minValue = minValue,
		maxValue = maxValue,
		goal = x
	}, ConstrainedSpring)
end
function ConstrainedSpring:Step(dt)
	local freq = self.freq * 2 * pi
	local x = self.x
	local v = self.v
	local minValue = self.minValue
	local maxValue = self.maxValue
	local goal = self.goal
	local offset = goal - x
	local step = freq * dt
	local decay = exp(-step)
	local x1 = goal + (v * dt - offset * (step + 1)) * decay
	local v1 = ((offset * freq - v) * step + v) * decay
	if minValue > x1 then
		x1 = minValue
		v1 = 0
	elseif maxValue < x1 then
		x1 = maxValue
		v1 = 0
	end
	self.x = x1
	self.v = v1
	return x1
end
local zoomSpring = ConstrainedSpring.new(ZOOM_STIFFNESS, ZOOM_DEFAULT, MIN_FOCUS_DIST, cameraMaxZoomDistance)
local function stepTargetZoom(z, dz, zoomMin, zoomMax)
	z = clamp(z + dz * (1 + z * ZOOM_ACCELERATION), zoomMin, zoomMax)
	if z < DIST_OPAQUE then
		z = dz <= 0 and zoomMin or DIST_OPAQUE
	end
	return z
end
local zoomDelta = 0
local Zoom = {}
function Zoom.Update(renderDt, focus, extrapolation)
	local poppedZoom = math.huge
	if zoomSpring.goal > DIST_OPAQUE then
		local maxPossibleZoom = max(zoomSpring.x, stepTargetZoom(zoomSpring.goal, zoomDelta, cameraMinZoomDistance, cameraMaxZoomDistance))
		poppedZoom = Popper(focus * CFrame.new(0, 0, MIN_FOCUS_DIST), maxPossibleZoom - MIN_FOCUS_DIST, extrapolation) + MIN_FOCUS_DIST
	end
	zoomSpring.minValue = MIN_FOCUS_DIST
	zoomSpring.maxValue = min(cameraMaxZoomDistance, poppedZoom)
	return zoomSpring:Step(renderDt)
end
function Zoom.SetZoomParameters(targetZoom, newZoomDelta)
	zoomSpring.goal = targetZoom
	zoomDelta = newZoomDelta
end
return Zoom
]]></ProtectedString><string name="Name">ZoomController</string></Properties><Item class="ModuleScript" referent="RBX600"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local FFlagUserPoppercamLooseOpacityThreshold
do
	local success, enabled = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserPoppercamLooseOpacityThreshold")
	end)
	FFlagUserPoppercamLooseOpacityThreshold = success and enabled
end
local camera = game.Workspace.CurrentCamera
local min = math.min
local tan = math.tan
local rad = math.rad
local inf = math.huge
local ray = Ray.new
local eraseFromEnd = function(t, toSize)
	for i = #t, toSize + 1, -1 do
		t[i] = nil
	end
end
local nearPlaneZ, projX, projY
do
	local function updateProjection()
		local fov = rad(camera.FieldOfView)
		local view = camera.ViewportSize
		local ar = view.X / view.Y
		projY = 2 * tan(fov / 2)
		projX = ar * projY
	end
	camera:GetPropertyChangedSignal("FieldOfView"):Connect(updateProjection)
	camera:GetPropertyChangedSignal("ViewportSize"):Connect(updateProjection)
	updateProjection()
	nearPlaneZ = camera.NearPlaneZ
	camera:GetPropertyChangedSignal("NearPlaneZ"):Connect(function()
		nearPlaneZ = camera.NearPlaneZ
	end)
end
local blacklist = {}
do
	local charMap = {}
	local function refreshIgnoreList()
		local n = 1
		blacklist = {}
		for _, character in pairs(charMap) do
			blacklist[n] = character
			n = n + 1
		end
	end
	local function playerAdded(player)
		local function characterAdded(character)
			charMap[player] = character
			refreshIgnoreList()
		end
		local function characterRemoving()
			charMap[player] = nil
			refreshIgnoreList()
		end
		player.CharacterAdded:Connect(characterAdded)
		player.CharacterRemoving:Connect(characterRemoving)
		if player.Character then
			characterAdded(player.Character)
		end
	end
	local function playerRemoving(player)
		charMap[player] = nil
		refreshIgnoreList()
	end
	Players.PlayerAdded:Connect(playerAdded)
	Players.PlayerRemoving:Connect(playerRemoving)
	for _, player in ipairs(Players:GetPlayers()) do
		playerAdded(player)
	end
	refreshIgnoreList()
end
local subjectRoot, subjectPart
camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
	local subject = camera.CameraSubject
	if subject:IsA("Humanoid") then
		subjectPart = subject.RootPart
	elseif subject:IsA("BasePart") then
		subjectPart = subject
	else
		subjectPart = nil
	end
end)
local function canOcclude(part)
	if FFlagUserPoppercamLooseOpacityThreshold then
		return part.Transparency < 0.25 and part.CanCollide and subjectRoot ~= (part:GetRootPart() or part) and not part:IsA("TrussPart")
	else
		return part.Transparency < 0.95 and part.CanCollide and subjectRoot ~= (part:GetRootPart() or part)
	end
end
local SCAN_SAMPLE_OFFSETS = {
	Vector2.new(0.4, 0),
	Vector2.new(-0.4, 0),
	Vector2.new(0, -0.4),
	Vector2.new(0, 0.4),
	Vector2.new(0, 0.2)
}
local function getCollisionPoint(origin, dir)
	local originalSize = #blacklist
	repeat
		local hitPart, hitPoint = workspace:FindPartOnRayWithIgnoreList(ray(origin, dir), blacklist, false, true)
		if hitPart then
			if hitPart.CanCollide then
				eraseFromEnd(blacklist, originalSize)
				return hitPoint, true
			end
			blacklist[#blacklist + 1] = hitPart
		end
	until not hitPart
	eraseFromEnd(blacklist, originalSize)
	return origin + dir, false
end
local function queryPoint(origin, unitDir, dist, lastPos)
	debug.profilebegin("queryPoint")
	local originalSize = #blacklist
	dist = dist + nearPlaneZ
	local target = origin + unitDir * dist
	local softLimit = inf
	local hardLimit = inf
	local movingOrigin = origin
	repeat
		local entryPart, entryPos = workspace:FindPartOnRayWithIgnoreList(ray(movingOrigin, target - movingOrigin), blacklist, false, true)
		if entryPart then
			if canOcclude(entryPart) then
				local wl = {entryPart}
				local exitPart = workspace:FindPartOnRayWithWhitelist(ray(target, entryPos - target), wl, true)
				local lim = (entryPos - origin).Magnitude
				if exitPart then
					local promote = false
					if lastPos then
						promote = workspace:FindPartOnRayWithWhitelist(ray(lastPos, target - lastPos), wl, true) or workspace:FindPartOnRayWithWhitelist(ray(target, lastPos - target), wl, true)
					end
					if promote then
						hardLimit = lim
					elseif dist < softLimit then
						softLimit = lim
					end
				else
					hardLimit = lim
				end
			end
			blacklist[#blacklist + 1] = entryPart
			movingOrigin = entryPos - unitDir * 0.001
		end
	until hardLimit < inf or not entryPart
	eraseFromEnd(blacklist, originalSize)
	debug.profileend()
	return softLimit - nearPlaneZ, hardLimit - nearPlaneZ
end
local function queryViewport(focus, dist)
	debug.profilebegin("queryViewport")
	local fP = focus.p
	local fX = focus.rightVector
	local fY = focus.upVector
	local fZ = -focus.lookVector
	local viewport = camera.ViewportSize
	local hardBoxLimit = inf
	local softBoxLimit = inf
	for viewX = 0, 1 do
		local worldX = fX * ((viewX - 0.5) * projX)
		for viewY = 0, 1 do
			local worldY = fY * ((viewY - 0.5) * projY)
			local origin = fP + nearPlaneZ * (worldX + worldY)
			local lastPos = camera:ViewportPointToRay(viewport.x * viewX, viewport.y * viewY).Origin
			local softPointLimit, hardPointLimit = queryPoint(origin, fZ, dist, lastPos)
			if hardBoxLimit > hardPointLimit then
				hardBoxLimit = hardPointLimit
			end
			if softBoxLimit > softPointLimit then
				softBoxLimit = softPointLimit
			end
		end
	end
	debug.profileend()
	return softBoxLimit, hardBoxLimit
end
local function testPromotion(focus, dist, focusExtrapolation)
	debug.profilebegin("testPromotion")
	local fP = focus.p
	local fX = focus.rightVector
	local fY = focus.upVector
	local fZ = -focus.lookVector
	debug.profilebegin("extrapolate")
	do
		local SAMPLE_DT = 0.0625
		local SAMPLE_MAX_T = 1.25
		local maxDist = (getCollisionPoint(fP, focusExtrapolation.posVelocity * SAMPLE_MAX_T) - fP).Magnitude
		local combinedSpeed = focusExtrapolation.posVelocity.magnitude
		for dt = 0, min(SAMPLE_MAX_T, focusExtrapolation.rotVelocity.magnitude + maxDist / combinedSpeed), SAMPLE_DT do
			local cfDt = focusExtrapolation.extrapolate(dt)
			if dist <= queryPoint(cfDt.p, -cfDt.lookVector, dist) then
				return false
			end
		end
		debug.profileend()
	end
	debug.profilebegin("testOffsets")
	for _, offset in ipairs(SCAN_SAMPLE_OFFSETS) do
		local scaledOffset = offset
		local pos, isHit = getCollisionPoint(fP, fX * scaledOffset.x + fY * scaledOffset.y)
		if queryPoint(pos, (fP + fZ * dist - pos).Unit, dist) == inf then
			return false
		end
	end
	debug.profileend()
	debug.profileend()
	return true
end
local function Popper(focus, targetDist, focusExtrapolation)
	debug.profilebegin("popper")
	subjectRoot = subjectPart and subjectPart:GetRootPart() or subjectPart
	local dist = targetDist
	local soft, hard = queryViewport(focus, targetDist)
	if dist > hard then
		dist = hard
	end
	if soft < dist and testPromotion(focus, targetDist, focusExtrapolation) then
		dist = soft
	end
	subjectRoot = nil
	debug.profileend()
	return dist
end
return Popper
]]></ProtectedString><string name="Name">Popper</string></Properties></Item></Item><Item class="ModuleScript" referent="RBX606"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local DEFAULT_MOUSE_LOCK_CURSOR = "rbxasset://textures/MouseLockedCursor.png"
local CONTEXT_ACTION_NAME = "MouseLockSwitchAction"
local MOUSELOCK_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local Settings = UserSettings()
local GameSettings = Settings.GameSettings
local Mouse = PlayersService.LocalPlayer:GetMouse()
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local MouseLockController = {}
MouseLockController.__index = MouseLockController
function MouseLockController.new()
	local self = setmetatable({}, MouseLockController)
	self.inputBeganConn = nil
	self.isMouseLocked = false
	self.savedMouseCursor = nil
	self.boundKeys = {
		Enum.KeyCode.LeftShift,
		Enum.KeyCode.RightShift
	}
	self.mouseLockToggledEvent = Instance.new("BindableEvent")
	local boundKeysObj = script:FindFirstChild("BoundKeys")
	if not boundKeysObj or not boundKeysObj:IsA("StringValue") then
		if boundKeysObj then
			boundKeysObj:Destroy()
		end
		boundKeysObj = Instance.new("StringValue")
		boundKeysObj.Name = "BoundKeys"
		boundKeysObj.Value = "LeftShift,RightShift"
		boundKeysObj.Parent = script
	end
	if boundKeysObj then
		boundKeysObj.Changed:Connect(function(value)
			self:OnBoundKeysObjectChanged(value)
		end)
		self:OnBoundKeysObjectChanged(boundKeysObj.Value)
	end
	GameSettings.Changed:Connect(function(property)
		if property == "ControlMode" or property == "ComputerMovementMode" then
			self:UpdateMouseLockAvailability()
		end
	end)
	PlayersService.LocalPlayer:GetPropertyChangedSignal("DevEnableMouseLock"):Connect(function()
		self:UpdateMouseLockAvailability()
	end)
	PlayersService.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
		self:UpdateMouseLockAvailability()
	end)
	self:UpdateMouseLockAvailability()
	return self
end
function MouseLockController:GetIsMouseLocked()
	return self.isMouseLocked
end
function MouseLockController:GetBindableToggleEvent()
	return self.mouseLockToggledEvent.Event
end
function MouseLockController:GetMouseLockOffset()
	local offsetValueObj = script:FindFirstChild("CameraOffset")
	if offsetValueObj and offsetValueObj:IsA("Vector3Value") then
		return offsetValueObj.Value
	else
		if offsetValueObj then
			offsetValueObj:Destroy()
		end
		offsetValueObj = Instance.new("Vector3Value")
		offsetValueObj.Name = "CameraOffset"
		offsetValueObj.Value = Vector3.new(1.75, 0, 0)
		offsetValueObj.Parent = script
	end
	if offsetValueObj and offsetValueObj.Value then
		return offsetValueObj.Value
	end
	return Vector3.new(1.75, 0, 0)
end
function MouseLockController:UpdateMouseLockAvailability()
	local devAllowsMouseLock = PlayersService.LocalPlayer.DevEnableMouseLock
	local devMovementModeIsScriptable = PlayersService.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable
	local userHasMouseLockModeEnabled = GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch
	local userHasClickToMoveEnabled = GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove
	local MouseLockAvailable = devAllowsMouseLock and userHasMouseLockModeEnabled and not userHasClickToMoveEnabled and not devMovementModeIsScriptable
	if MouseLockAvailable ~= self.enabled then
		self:EnableMouseLock(MouseLockAvailable)
	end
end
function MouseLockController:OnBoundKeysObjectChanged(newValue)
	self.boundKeys = {}
	for token in string.gmatch(newValue, "[^%s,]+") do
		for keyCode, keyEnum in pairs(Enum.KeyCode:GetEnumItems()) do
			if token == keyEnum.Name then
				self.boundKeys[#self.boundKeys + 1] = keyEnum
				break
			end
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		self:UnbindContextActions()
		self:BindContextActions()
	end
end
function MouseLockController:OnMouseLockToggled()
	self.isMouseLocked = not self.isMouseLocked
	if self.isMouseLocked then
		local cursorImageValueObj = script:FindFirstChild("CursorImage")
		if cursorImageValueObj and cursorImageValueObj:IsA("StringValue") and cursorImageValueObj.Value then
			self.savedMouseCursor = Mouse.Icon
			Mouse.Icon = cursorImageValueObj.Value
		else
			if cursorImageValueObj then
				cursorImageValueObj:Destroy()
			end
			cursorImageValueObj = Instance.new("StringValue")
			cursorImageValueObj.Name = "CursorImage"
			cursorImageValueObj.Value = DEFAULT_MOUSE_LOCK_CURSOR
			cursorImageValueObj.Parent = script
			self.savedMouseCursor = Mouse.Icon
			Mouse.Icon = DEFAULT_MOUSE_LOCK_CURSOR
		end
	elseif self.savedMouseCursor then
		Mouse.Icon = self.savedMouseCursor
		self.savedMouseCursor = nil
	end
	self.mouseLockToggledEvent:Fire()
end
function MouseLockController:OnInputBegan(input, processed)
	if processed then
		return
	end
	if input.UserInputType == Enum.UserInputType.Keyboard then
		for _, keyCode in pairs(self.boundKeys) do
			if keyCode == input.KeyCode then
				self:OnMouseLockToggled()
				return
			end
		end
	end
end
function MouseLockController:DoMouseLockSwitch(name, state, input)
	if state == Enum.UserInputState.Begin then
		self:OnMouseLockToggled()
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end
function MouseLockController:BindContextActions()
	ContextActionService:BindActionAtPriority(CONTEXT_ACTION_NAME, function(name, state, input)
		return self:DoMouseLockSwitch(name, state, input)
	end, false, MOUSELOCK_ACTION_PRIORITY, unpack(self.boundKeys))
end
function MouseLockController:UnbindContextActions()
	ContextActionService:UnbindAction(CONTEXT_ACTION_NAME)
end
function MouseLockController:IsMouseLocked()
	return self.enabled and self.isMouseLocked
end
function MouseLockController:EnableMouseLock(enable)
	if enable ~= self.enabled then
		self.enabled = enable
		if self.enabled then
			if FFlagPlayerScriptsBindAtPriority2 then
				self:BindContextActions()
			else
				if self.inputBeganConn then
					self.inputBeganConn:Disconnect()
				end
				self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
					self:OnInputBegan(input, processed)
				end)
			end
		else
			if Mouse.Icon ~= "" then
				Mouse.Icon = ""
			end
			if FFlagPlayerScriptsBindAtPriority2 then
				self:UnbindContextActions()
			else
				if self.inputBeganConn then
					self.inputBeganConn:Disconnect()
				end
				self.inputBeganConn = nil
			end
			if self.isMouseLocked then
				self.mouseLockToggledEvent:Fire()
			end
			self.isMouseLocked = false
		end
	end
end
return MouseLockController
]]></ProtectedString><string name="Name">MouseLockController</string></Properties></Item><Item class="ModuleScript" referent="RBX611"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local POP_RESTORE_RATE = 0.3
local MIN_CAMERA_ZOOM = 0.5
local VALID_SUBJECTS = {
	"Humanoid",
	"VehicleSeat",
	"SkateboardPlatform"
}
local portraitPopperFixFlagExists, portraitPopperFixFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPortraitPopperFix")
end)
local FFlagUserPortraitPopperFix = portraitPopperFixFlagExists and portraitPopperFixFlagEnabled
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Poppercam = setmetatable({}, BaseOcclusion)
Poppercam.__index = Poppercam
function Poppercam.new()
	local self = setmetatable(BaseOcclusion.new(), Poppercam)
	self.camera = nil
	self.cameraSubjectChangeConn = nil
	self.subjectPart = nil
	self.playerCharacters = {}
	self.vehicleParts = {}
	self.lastPopAmount = 0
	self.lastZoomLevel = 0
	self.popperEnabled = false
	return self
end
function Poppercam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Zoom
end
function Poppercam:Enable(enable)
end
function Poppercam:CharacterAdded(char, player)
	self.playerCharacters[player] = char
end
function Poppercam:CharacterRemoving(char, player)
	self.playerCharacters[player] = nil
end
function Poppercam:Update(dt, desiredCameraCFrame, desiredCameraFocus)
	if self.popperEnabled then
		self.camera = game.Workspace.CurrentCamera
		local newCameraCFrame = desiredCameraCFrame
		local focusPoint = desiredCameraFocus.p
		if FFlagUserPortraitPopperFix and self.subjectPart then
			focusPoint = self.subjectPart.CFrame.p
		end
		local ignoreList = {}
		for _, character in pairs(self.playerCharacters) do
			ignoreList[#ignoreList + 1] = character
		end
		for i = 1, #self.vehicleParts do
			ignoreList[#ignoreList + 1] = self.vehicleParts[i]
		end
		local prevCameraCFrame = self.camera.CFrame
		self.camera.CFrame = desiredCameraCFrame
		self.camera.Focus = desiredCameraFocus
		local largest = self.camera:GetLargestCutoffDistance(ignoreList)
		local zoomLevel = (desiredCameraCFrame.p - focusPoint).Magnitude
		if math.abs(zoomLevel - self.lastZoomLevel) > 0.001 then
			self.lastPopAmount = 0
		end
		local popAmount = largest
		if popAmount < self.lastPopAmount then
			popAmount = self.lastPopAmount
		end
		if popAmount > 0 then
			newCameraCFrame = desiredCameraCFrame + desiredCameraCFrame.lookVector * popAmount
			self.lastPopAmount = popAmount - POP_RESTORE_RATE
			if self.lastPopAmount < 0 then
				self.lastPopAmount = 0
			end
		end
		self.lastZoomLevel = zoomLevel
		return newCameraCFrame, desiredCameraFocus
	end
	return desiredCameraCFrame, desiredCameraFocus
end
function Poppercam:OnCameraSubjectChanged(newSubject)
	self.vehicleParts = {}
	self.lastPopAmount = 0
	if newSubject then
		self.popperEnabled = false
		for _, subjectType in pairs(VALID_SUBJECTS) do
			if newSubject:IsA(subjectType) then
				self.popperEnabled = true
				break
			end
		end
		if newSubject:IsA("VehicleSeat") then
			self.vehicleParts = newSubject:GetConnectedParts(true)
		end
		if FFlagUserPortraitPopperFix then
			if newSubject:IsA("BasePart") then
				self.subjectPart = newSubject
			elseif newSubject:IsA("Model") then
				if newSubject.PrimaryPart then
					self.subjectPart = newSubject.PrimaryPart
				else
					for _, child in pairs(newSubject:GetChildren()) do
						if child:IsA("BasePart") then
							self.subjectPart = child
							break
						end
					end
				end
			elseif newSubject:IsA("Humanoid") then
				self.subjectPart = newSubject.RootPart
			end
		end
	end
end
return Poppercam
]]></ProtectedString><string name="Name">Poppercam_Classic</string></Properties></Item><Item class="ModuleScript" referent="RBX616"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local MAX_TWEEN_RATE = 2.8
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local TransparencyController = {}
TransparencyController.__index = TransparencyController
function TransparencyController.new()
	local self = setmetatable({}, TransparencyController)
	self.lastUpdate = tick()
	self.transparencyDirty = false
	self.enabled = false
	self.lastTransparency = nil
	self.descendantAddedConn, self.descendantRemovingConn = nil, nil
	self.toolDescendantAddedConns = {}
	self.toolDescendantRemovingConns = {}
	self.cachedParts = {}
	return self
end
function TransparencyController:HasToolAncestor(object)
	if object.Parent == nil then
		return false
	end
	return object.Parent:IsA("Tool") or self:HasToolAncestor(object.Parent)
end
function TransparencyController:IsValidPartToModify(part)
	if part:IsA("BasePart") or part:IsA("Decal") then
		return not self:HasToolAncestor(part)
	end
	return false
end
function TransparencyController:CachePartsRecursive(object)
	if object then
		if self:IsValidPartToModify(object) then
			self.cachedParts[object] = true
			self.transparencyDirty = true
		end
		for _, child in pairs(object:GetChildren()) do
			self:CachePartsRecursive(child)
		end
	end
end
function TransparencyController:TeardownTransparency()
	for child, _ in pairs(self.cachedParts) do
		child.LocalTransparencyModifier = 0
	end
	self.cachedParts = {}
	self.transparencyDirty = true
	self.lastTransparency = nil
	if self.descendantAddedConn then
		self.descendantAddedConn:disconnect()
		self.descendantAddedConn = nil
	end
	if self.descendantRemovingConn then
		self.descendantRemovingConn:disconnect()
		self.descendantRemovingConn = nil
	end
	for object, conn in pairs(self.toolDescendantAddedConns) do
		conn:Disconnect()
		self.toolDescendantAddedConns[object] = nil
	end
	for object, conn in pairs(self.toolDescendantRemovingConns) do
		conn:Disconnect()
		self.toolDescendantRemovingConns[object] = nil
	end
end
function TransparencyController:SetupTransparency(character)
	self:TeardownTransparency()
	if self.descendantAddedConn then
		self.descendantAddedConn:disconnect()
	end
	self.descendantAddedConn = character.DescendantAdded:Connect(function(object)
		if self:IsValidPartToModify(object) then
			self.cachedParts[object] = true
			self.transparencyDirty = true
		elseif object:IsA("Tool") then
			if self.toolDescendantAddedConns[object] then
				self.toolDescendantAddedConns[object]:Disconnect()
			end
			self.toolDescendantAddedConns[object] = object.DescendantAdded:Connect(function(toolChild)
				self.cachedParts[toolChild] = nil
				if toolChild:IsA("BasePart") or toolChild:IsA("Decal") then
					toolChild.LocalTransparencyModifier = 0
				end
			end)
			if self.toolDescendantRemovingConns[object] then
				self.toolDescendantRemovingConns[object]:disconnect()
			end
			self.toolDescendantRemovingConns[object] = object.DescendantRemoving:Connect(function(formerToolChild)
				wait()
				if character and formerToolChild and formerToolChild:IsDescendantOf(character) and self:IsValidPartToModify(formerToolChild) then
					self.cachedParts[formerToolChild] = true
					self.transparencyDirty = true
				end
			end)
		end
	end)
	if self.descendantRemovingConn then
		self.descendantRemovingConn:disconnect()
	end
	self.descendantRemovingConn = character.DescendantRemoving:connect(function(object)
		if self.cachedParts[object] then
			self.cachedParts[object] = nil
			object.LocalTransparencyModifier = 0
		end
	end)
	self:CachePartsRecursive(character)
end
function TransparencyController:Enable(enable)
	if self.enabled ~= enable then
		self.enabled = enable
		self:Update()
	end
end
function TransparencyController:SetSubject(subject)
	local character
	if subject and subject:IsA("Humanoid") then
		character = subject.Parent
	end
	if subject and subject:IsA("VehicleSeat") and subject.Occupant then
		character = subject.Occupant.Parent
	end
	if character then
		self:SetupTransparency(character)
	else
		self:TeardownTransparency()
	end
end
function TransparencyController:Update()
	local instant = false
	local now = tick()
	local currentCamera = workspace.CurrentCamera
	if currentCamera then
		local transparency = 0
		if not self.enabled then
			instant = true
		else
			local distance = (currentCamera.Focus.p - currentCamera.CoordinateFrame.p).magnitude
			transparency = distance < 2 and 1 - (distance - 0.5) / 1.5 or 0
			if transparency < 0.5 then
				transparency = 0
			end
			if self.lastTransparency then
				local deltaTransparency = transparency - self.lastTransparency
				if not instant and transparency < 1 and self.lastTransparency < 0.95 then
					local maxDelta = MAX_TWEEN_RATE * (now - self.lastUpdate)
					deltaTransparency = Util.Clamp(-maxDelta, maxDelta, deltaTransparency)
				end
				transparency = self.lastTransparency + deltaTransparency
			else
				self.transparencyDirty = true
			end
			transparency = Util.Clamp(0, 1, Util.Round(transparency, 2))
		end
		if self.transparencyDirty or self.lastTransparency ~= transparency then
			for child, _ in pairs(self.cachedParts) do
				child.LocalTransparencyModifier = transparency
			end
			self.transparencyDirty = false
			self.lastTransparency = transparency
		end
	end
	self.lastUpdate = now
end
return TransparencyController
]]></ProtectedString><string name="Name">TransparencyController</string></Properties></Item><Item class="ModuleScript" referent="RBX621"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local RunService = game:GetService("RunService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local USE_STACKING_TRANSPARENCY = true
local TARGET_TRANSPARENCY = 0.75
local TARGET_TRANSPARENCY_PERIPHERAL = 0.5
local MODE = {
	LIMBS = 2,
	MOVEMENT = 3,
	CORNERS = 4,
	CIRCLE1 = 5,
	CIRCLE2 = 6,
	LIMBMOVE = 7,
	SMART_CIRCLE = 8,
	CHAR_OUTLINE = 9
}
local LIMB_TRACKING_SET = {
	Head = true,
	["Left Arm"] = true,
	["Right Arm"] = true,
	["Left Leg"] = true,
	["Right Leg"] = true,
	LeftLowerArm = true,
	RightLowerArm = true,
	LeftUpperLeg = true,
	RightUpperLeg = true
}
local CORNER_FACTORS = {
	Vector3.new(1, 1, -1),
	Vector3.new(1, -1, -1),
	Vector3.new(-1, -1, -1),
	Vector3.new(-1, 1, -1)
}
local CIRCLE_CASTS = 10
local MOVE_CASTS = 3
local SMART_CIRCLE_CASTS = 24
local SMART_CIRCLE_INCREMENT = 2 * math.pi / SMART_CIRCLE_CASTS
local CHAR_OUTLINE_CASTS = 24
local AssertTypes = function(param, ...)
	local allowedTypes = {}
	local typeString = ""
	for _, typeName in pairs({
		...
	}) do
		allowedTypes[typeName] = true
		typeString = typeString .. (typeString == "" and "" or " or ") .. typeName
	end
	local theType = type(param)
	assert(allowedTypes[theType], typeString .. " type expected, got: " .. theType)
end
local Det3x3 = function(a, b, c, d, e, f, g, h, i)
	return a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)
end
local function RayIntersection(p0, v0, p1, v1)
	local v2 = v0:Cross(v1)
	local d1 = p1.x - p0.x
	local d2 = p1.y - p0.y
	local d3 = p1.z - p0.z
	local denom = Det3x3(v0.x, -v1.x, v2.x, v0.y, -v1.y, v2.y, v0.z, -v1.z, v2.z)
	if denom == 0 then
		return ZERO_VECTOR3
	end
	local t0 = Det3x3(d1, -v1.x, v2.x, d2, -v1.y, v2.y, d3, -v1.z, v2.z) / denom
	local t1 = Det3x3(v0.x, d1, v2.x, v0.y, d2, v2.y, v0.z, d3, v2.z) / denom
	local s0 = p0 + t0 * v0
	local s1 = p1 + t1 * v1
	local s = s0 + 0.5 * (s1 - s0)
	if (s1 - s0).Magnitude < 0.25 then
		return s
	else
		return ZERO_VECTOR3
	end
end
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Invisicam = setmetatable({}, BaseOcclusion)
Invisicam.__index = Invisicam
function Invisicam.new()
	local self = setmetatable(BaseOcclusion.new(), Invisicam)
	self.char = nil
	self.humanoidRootPart = nil
	self.torsoPart = nil
	self.headPart = nil
	self.childAddedConn = nil
	self.childRemovedConn = nil
	self.behaviors = {}
	self.behaviors[MODE.LIMBS] = self.LimbBehavior
	self.behaviors[MODE.MOVEMENT] = self.MoveBehavior
	self.behaviors[MODE.CORNERS] = self.CornerBehavior
	self.behaviors[MODE.CIRCLE1] = self.CircleBehavior
	self.behaviors[MODE.CIRCLE2] = self.CircleBehavior
	self.behaviors[MODE.LIMBMOVE] = self.LimbMoveBehavior
	self.behaviors[MODE.SMART_CIRCLE] = self.SmartCircleBehavior
	self.behaviors[MODE.CHAR_OUTLINE] = self.CharacterOutlineBehavior
	self.mode = MODE.SMART_CIRCLE
	self.behaviorFunction = self.SmartCircleBehavior
	self.savedHits = {}
	self.trackedLimbs = {}
	self.camera = game.Workspace.CurrentCamera
	self.enabled = false
	return self
end
function Invisicam:Enable(enable)
	self.enabled = enable
	if not enable then
		self:Cleanup()
	end
end
function Invisicam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Invisicam
end
function Invisicam:LimbBehavior(castPoints)
	for limb, _ in pairs(self.trackedLimbs) do
		castPoints[#castPoints + 1] = limb.Position
	end
end
function Invisicam:MoveBehavior(castPoints)
	for i = 1, MOVE_CASTS do
		local position, velocity = self.humanoidRootPart.Position, self.humanoidRootPart.Velocity
		local horizontalSpeed = Vector3.new(velocity.X, 0, velocity.Z).Magnitude / 2
		local offsetVector = (i - 1) * self.humanoidRootPart.CFrame.lookVector * horizontalSpeed
		castPoints[#castPoints + 1] = position + offsetVector
	end
end
function Invisicam:CornerBehavior(castPoints)
	local cframe = self.humanoidRootPart.CFrame
	local centerPoint = cframe.p
	local rotation = cframe - centerPoint
	local halfSize = self.char:GetExtentsSize() / 2
	castPoints[#castPoints + 1] = centerPoint
	for i = 1, #CORNER_FACTORS do
		castPoints[#castPoints + 1] = centerPoint + rotation * (halfSize * CORNER_FACTORS[i])
	end
end
function Invisicam:CircleBehavior(castPoints)
	local cframe
	if self.mode == MODE.CIRCLE1 then
		cframe = self.humanoidRootPart.CFrame
	else
		local camCFrame = self.camera.CoordinateFrame
		cframe = camCFrame - camCFrame.p + self.humanoidRootPart.Position
	end
	castPoints[#castPoints + 1] = cframe.p
	for i = 0, CIRCLE_CASTS - 1 do
		local angle = 2 * math.pi / CIRCLE_CASTS * i
		local offset = 3 * Vector3.new(math.cos(angle), math.sin(angle), 0)
		castPoints[#castPoints + 1] = cframe * offset
	end
end
function Invisicam:LimbMoveBehavior(castPoints)
	self:LimbBehavior(castPoints)
	self:MoveBehavior(castPoints)
end
function Invisicam:CharacterOutlineBehavior(castPoints)
	local torsoUp = self.torsoPart.CFrame.upVector.unit
	local torsoRight = self.torsoPart.CFrame.rightVector.unit
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
	if self.headPart then
		castPoints[#castPoints + 1] = self.headPart.CFrame.p
	end
	local cframe = CFrame.new(ZERO_VECTOR3, Vector3.new(self.camera.CoordinateFrame.lookVector.X, 0, self.camera.CoordinateFrame.lookVector.Z))
	local centerPoint = self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position
	local partsWhitelist = {
		self.torsoPart
	}
	if self.headPart then
		partsWhitelist[#partsWhitelist + 1] = self.headPart
	end
	for i = 1, CHAR_OUTLINE_CASTS do
		local angle = 2 * math.pi * i / CHAR_OUTLINE_CASTS
		local offset = cframe * (3 * Vector3.new(math.cos(angle), math.sin(angle), 0))
		offset = Vector3.new(offset.X, math.max(offset.Y, -2.25), offset.Z)
		local ray = Ray.new(centerPoint + offset, -3 * offset)
		local hit, hitPoint = game.Workspace:FindPartOnRayWithWhitelist(ray, partsWhitelist, false, false)
		if hit then
			castPoints[#castPoints + 1] = hitPoint + 0.2 * (centerPoint - hitPoint).unit
		end
	end
end
function Invisicam:SmartCircleBehavior(castPoints)
	local torsoUp = self.torsoPart.CFrame.upVector.unit
	local torsoRight = self.torsoPart.CFrame.rightVector.unit
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
	if self.headPart then
		castPoints[#castPoints + 1] = self.headPart.CFrame.p
	end
	local cameraOrientation = self.camera.CFrame - self.camera.CFrame.p
	local torsoPoint = Vector3.new(0, 0.5, 0) + (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
	local radius = 2.5
	for i = 1, SMART_CIRCLE_CASTS do
		local angle = SMART_CIRCLE_INCREMENT * i - 0.5 * math.pi
		local offset = radius * Vector3.new(math.cos(angle), math.sin(angle), 0)
		local circlePoint = torsoPoint + cameraOrientation * offset
		local vp = circlePoint - self.camera.CFrame.p
		local ray = Ray.new(torsoPoint, circlePoint - torsoPoint)
		local hit, hp, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {
			self.char
		}, false, false)
		local castPoint = circlePoint
		if hit then
			local hprime = hp + 0.1 * hitNormal.unit
			local v0 = hprime - torsoPoint
			local d0 = v0.magnitude
			local perp = v0:Cross(vp).unit
			local v1 = perp:Cross(hitNormal).unit
			local vprime = (hprime - self.camera.CFrame.p).unit
			if v0.unit:Dot(-v1) < v0.unit:Dot(vprime) then
				castPoint = RayIntersection(hprime, v1, circlePoint, vp)
				if 0 < castPoint.Magnitude then
					local ray = Ray.new(hprime, castPoint - hprime)
					local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {
						self.char
					}, false, false)
					if hit then
						local hprime2 = hitPoint + 0.1 * hitNormal.unit
						castPoint = hprime2
					end
				else
					castPoint = hprime
				end
			else
				castPoint = hprime
			end
			local ray = Ray.new(torsoPoint, castPoint - torsoPoint)
			local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {
				self.char
			}, false, false)
			if hit then
				local castPoint2 = hitPoint - 0.1 * (castPoint - torsoPoint).unit
				castPoint = castPoint2
			end
		end
		castPoints[#castPoints + 1] = castPoint
	end
end
function Invisicam:CheckTorsoReference()
	if self.char then
		self.torsoPart = self.char:FindFirstChild("Torso")
		if not self.torsoPart then
			self.torsoPart = self.char:FindFirstChild("UpperTorso")
			if not self.torsoPart then
				self.torsoPart = self.char:FindFirstChild("HumanoidRootPart")
			end
		end
		self.headPart = self.char:FindFirstChild("Head")
	end
end
function Invisicam:CharacterAdded(char, player)
	if player ~= PlayersService.LocalPlayer then
		return
	end
	if self.childAddedConn then
		self.childAddedConn:Disconnect()
		self.childAddedConn = nil
	end
	if self.childRemovedConn then
		self.childRemovedConn:Disconnect()
		self.childRemovedConn = nil
	end
	self.char = char
	self.trackedLimbs = {}
	local function childAdded(child)
		if child:IsA("BasePart") then
			if LIMB_TRACKING_SET[child.Name] then
				self.trackedLimbs[child] = true
			end
			if child.Name == "Torso" or child.Name == "UpperTorso" then
				self.torsoPart = child
			end
			if child.Name == "Head" then
				self.headPart = child
			end
		end
	end
	local function childRemoved(child)
		self.trackedLimbs[child] = nil
		self:CheckTorsoReference()
	end
	self.childAddedConn = char.ChildAdded:Connect(childAdded)
	self.childRemovedConn = char.ChildRemoved:Connect(childRemoved)
	for _, child in pairs(self.char:GetChildren()) do
		childAdded(child)
	end
end
function Invisicam:SetMode(newMode)
	AssertTypes(newMode, "number")
	for modeName, modeNum in pairs(MODE) do
		if modeNum == newMode then
			self.mode = newMode
			self.behaviorFunction = self.behaviors[self.mode]
			return
		end
	end
	error("Invalid mode number")
end
function Invisicam:GetObscuredParts()
	return self.savedHits
end
function Invisicam:Cleanup()
	for hit, originalFade in pairs(self.savedHits) do
		hit.LocalTransparencyModifier = originalFade
	end
end
function Invisicam:Update(dt, desiredCameraCFrame, desiredCameraFocus)
	if not self.enabled or not self.char then
		return desiredCameraCFrame, desiredCameraFocus
	end
	self.camera = game.Workspace.CurrentCamera
	if not self.humanoidRootPart then
		do
			local humanoid = self.char:FindFirstChildOfClass("Humanoid")
			if humanoid and humanoid.RootPart then
				self.humanoidRootPart = humanoid.RootPart
			else
				self.humanoidRootPart = self.char:FindFirstChild("HumanoidRootPart")
				if not self.humanoidRootPart then
					return desiredCameraCFrame, desiredCameraFocus
				end
			end
			local ancestryChangedConn
			ancestryChangedConn = self.humanoidRootPart.AncestryChanged:Connect(function(child, parent)
				if child == self.humanoidRootPart and not parent then
					self.humanoidRootPart = nil
					if ancestryChangedConn and ancestryChangedConn.Connected then
						ancestryChangedConn:Disconnect()
						ancestryChangedConn = nil
					end
				end
			end)
		end
	end
	if not self.torsoPart then
		self:CheckTorsoReference()
		if not self.torsoPart then
			return desiredCameraCFrame, desiredCameraFocus
		end
	end
	local castPoints = {}
	self.behaviorFunction(self, castPoints)
	local currentHits = {}
	local ignoreList = {
		self.char
	}
	local function add(hit)
		currentHits[hit] = true
		if not self.savedHits[hit] then
			self.savedHits[hit] = hit.LocalTransparencyModifier
		end
	end
	local hitParts
	local hitPartCount = 0
	local headTorsoRayHitParts = {}
	local partIsTouchingCamera = {}
	local perPartTransparencyHeadTorsoHits = TARGET_TRANSPARENCY
	local perPartTransparencyOtherHits = TARGET_TRANSPARENCY
	if USE_STACKING_TRANSPARENCY then
		local headPoint = self.headPart and self.headPart.CFrame.p or castPoints[1]
		local torsoPoint = self.torsoPart and self.torsoPart.CFrame.p or castPoints[2]
		hitParts = self.camera:GetPartsObscuringTarget({headPoint, torsoPoint}, ignoreList)
		for i = 1, #hitParts do
			local hitPart = hitParts[i]
			hitPartCount = hitPartCount + 1
			headTorsoRayHitParts[hitPart] = true
			for _, child in pairs(hitPart:GetChildren()) do
				if child:IsA("Decal") or child:IsA("Texture") then
					hitPartCount = hitPartCount + 1
					break
				end
			end
		end
		if hitPartCount > 0 then
			perPartTransparencyHeadTorsoHits = math.pow(0.5 * TARGET_TRANSPARENCY + 0.5 * TARGET_TRANSPARENCY / hitPartCount, 1 / hitPartCount)
			perPartTransparencyOtherHits = math.pow(0.5 * TARGET_TRANSPARENCY_PERIPHERAL + 0.5 * TARGET_TRANSPARENCY_PERIPHERAL / hitPartCount, 1 / hitPartCount)
		end
	end
	hitParts = self.camera:GetPartsObscuringTarget(castPoints, ignoreList)
	local partTargetTransparency = {}
	for i = 1, #hitParts do
		local hitPart = hitParts[i]
		partTargetTransparency[hitPart] = headTorsoRayHitParts[hitPart] and perPartTransparencyHeadTorsoHits or perPartTransparencyOtherHits
		if hitPart.Transparency < partTargetTransparency[hitPart] then
			add(hitPart)
		end
		for _, child in pairs(hitPart:GetChildren()) do
			if (child:IsA("Decal") or child:IsA("Texture")) and child.Transparency < partTargetTransparency[hitPart] then
				partTargetTransparency[child] = partTargetTransparency[hitPart]
				add(child)
			end
		end
	end
	for hitPart, originalLTM in pairs(self.savedHits) do
		if currentHits[hitPart] then
			hitPart.LocalTransparencyModifier = 1 > hitPart.Transparency and (partTargetTransparency[hitPart] - hitPart.Transparency) / (1 - hitPart.Transparency) or 0
		else
			hitPart.LocalTransparencyModifier = originalLTM
			self.savedHits[hitPart] = nil
		end
	end
	return desiredCameraCFrame, desiredCameraFocus
end
return Invisicam
]]></ProtectedString><string name="Name">Invisicam</string></Properties></Item><Item class="ModuleScript" referent="RBX626"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local BaseOcclusion = {}
BaseOcclusion.__index = BaseOcclusion
setmetatable(BaseOcclusion, {
	__call = function(_, ...)
		return BaseOcclusion.new(...)
	end
})
function BaseOcclusion.new()
	local self = setmetatable({}, BaseOcclusion)
	return self
end
function BaseOcclusion:CharacterAdded(char, player)
end
function BaseOcclusion:CharacterRemoving(char, player)
end
function BaseOcclusion:OnCameraSubjectChanged(newSubject)
end
function GetOcclusionMode()
	warn("BaseOcclusion GetOcclusionMode must be overridden by derived classes")
	return nil
end
function BaseOcclusion:Enable(enabled)
	warn("BaseOcclusion Enable must be overridden by derived classes")
end
function BaseOcclusion:Update(dt, desiredCameraCFrame, desiredCameraFocus)
	warn("BaseOcclusion Update must be overridden by derived classes")
	return desiredCameraCFrame, desiredCameraFocus
end
return BaseOcclusion
]]></ProtectedString><string name="Name">BaseOcclusion</string></Properties></Item><Item class="ModuleScript" referent="RBX631"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UNIT_X = Vector3.new(1, 0, 0)
local UNIT_Y = Vector3.new(0, 1, 0)
local UNIT_Z = Vector3.new(0, 0, 1)
local X1_Y0_Z1 = Vector3.new(1, 0, 1)
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local ZERO_VECTOR2 = Vector2.new(0, 0)
local TAU = 2 * math.pi
local VR_PITCH_FRACTION = 0.25
local tweenAcceleration = math.rad(220)
local tweenSpeed = math.rad(0)
local tweenMaxSpeed = math.rad(250)
local TIME_BEFORE_AUTO_ROTATE = 2
local PORTRAIT_OFFSET = Vector3.new(0, -3, 0)
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local THUMBSTICK_DEADZONE = 0.2
local MIN_ALLOWED_ELEVATION_DEG = -80
local MAX_ALLOWED_ELEVATION_DEG = 80
local externalProperties = {}
externalProperties.InitialDistance = 25
externalProperties.MinDistance = 10
externalProperties.MaxDistance = 100
externalProperties.InitialElevation = 35
externalProperties.MinElevation = 35
externalProperties.MaxElevation = 35
externalProperties.ReferenceAzimuth = -45
externalProperties.CWAzimuthTravel = 90
externalProperties.CCWAzimuthTravel = 90
externalProperties.UseAzimuthLimits = false
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local VRService = game:GetService("VRService")
local GetValueObject = function(name, defaultValue)
	local valueObj = script:FindFirstChild(name)
	if valueObj then
		return valueObj.Value
	end
	return defaultValue
end
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local OrbitalCamera = setmetatable({}, BaseCamera)
OrbitalCamera.__index = OrbitalCamera
function OrbitalCamera.new()
	local self = setmetatable(BaseCamera.new(), OrbitalCamera)
	self.lastUpdate = tick()
	self.changedSignalConnections = {}
	self.refAzimuthRad = nil
	self.curAzimuthRad = nil
	self.minAzimuthAbsoluteRad = nil
	self.maxAzimuthAbsoluteRad = nil
	self.useAzimuthLimits = nil
	self.curElevationRad = nil
	self.minElevationRad = nil
	self.maxElevationRad = nil
	self.curDistance = nil
	self.minDistance = nil
	self.maxDistance = nil
	self.r3ButtonDown = false
	self.l3ButtonDown = false
	self.gamepadDollySpeedMultiplier = 1
	self.lastUserPanCamera = tick()
	self.externalProperties = {}
	self.externalProperties.InitialDistance = 25
	self.externalProperties.MinDistance = 10
	self.externalProperties.MaxDistance = 100
	self.externalProperties.InitialElevation = 35
	self.externalProperties.MinElevation = 35
	self.externalProperties.MaxElevation = 35
	self.externalProperties.ReferenceAzimuth = -45
	self.externalProperties.CWAzimuthTravel = 90
	self.externalProperties.CCWAzimuthTravel = 90
	self.externalProperties.UseAzimuthLimits = false
	self:LoadNumberValueParameters()
	return self
end
function OrbitalCamera:LoadOrCreateNumberValueParameter(name, valueType, updateFunction)
	local valueObj = script:FindFirstChild(name)
	if valueObj and valueObj:isA(valueType) then
		self.externalProperties[name] = valueObj.Value
	elseif self.externalProperties[name] ~= nil then
		valueObj = Instance.new(valueType)
		valueObj.Name = name
		valueObj.Parent = script
		valueObj.Value = self.externalProperties[name]
	else
		print("externalProperties table has no entry for ", name)
		return
	end
	if updateFunction then
		if self.changedSignalConnections[name] then
			self.changedSignalConnections[name]:Disconnect()
		end
		self.changedSignalConnections[name] = valueObj.Changed:Connect(function(newValue)
			self.externalProperties[name] = newValue
			updateFunction(self)
		end)
	end
end
function OrbitalCamera:SetAndBoundsCheckAzimuthValues()
	self.minAzimuthAbsoluteRad = math.rad(self.externalProperties.ReferenceAzimuth) - math.abs(math.rad(self.externalProperties.CWAzimuthTravel))
	self.maxAzimuthAbsoluteRad = math.rad(self.externalProperties.ReferenceAzimuth) + math.abs(math.rad(self.externalProperties.CCWAzimuthTravel))
	self.useAzimuthLimits = self.externalProperties.UseAzimuthLimits
	if self.useAzimuthLimits then
		self.curAzimuthRad = math.max(self.curAzimuthRad, self.minAzimuthAbsoluteRad)
		self.curAzimuthRad = math.min(self.curAzimuthRad, self.maxAzimuthAbsoluteRad)
	end
end
function OrbitalCamera:SetAndBoundsCheckElevationValues()
	local minElevationDeg = math.max(self.externalProperties.MinElevation, MIN_ALLOWED_ELEVATION_DEG)
	local maxElevationDeg = math.min(self.externalProperties.MaxElevation, MAX_ALLOWED_ELEVATION_DEG)
	self.minElevationRad = math.rad(math.min(minElevationDeg, maxElevationDeg))
	self.maxElevationRad = math.rad(math.max(minElevationDeg, maxElevationDeg))
	self.curElevationRad = math.max(self.curElevationRad, self.minElevationRad)
	self.curElevationRad = math.min(self.curElevationRad, self.maxElevationRad)
end
function OrbitalCamera:SetAndBoundsCheckDistanceValues()
	self.minDistance = self.externalProperties.MinDistance
	self.maxDistance = self.externalProperties.MaxDistance
	self.curDistance = math.max(self.curDistance, self.minDistance)
	self.curDistance = math.min(self.curDistance, self.maxDistance)
end
function OrbitalCamera:LoadNumberValueParameters()
	self:LoadOrCreateNumberValueParameter("InitialElevation", "NumberValue", nil)
	self:LoadOrCreateNumberValueParameter("InitialDistance", "NumberValue", nil)
	self:LoadOrCreateNumberValueParameter("ReferenceAzimuth", "NumberValue", self.SetAndBoundsCheckAzimuthValue)
	self:LoadOrCreateNumberValueParameter("CWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
	self:LoadOrCreateNumberValueParameter("CCWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
	self:LoadOrCreateNumberValueParameter("MinElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
	self:LoadOrCreateNumberValueParameter("MaxElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
	self:LoadOrCreateNumberValueParameter("MinDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
	self:LoadOrCreateNumberValueParameter("MaxDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
	self:LoadOrCreateNumberValueParameter("UseAzimuthLimits", "BoolValue", self.SetAndBoundsCheckAzimuthValues)
	self.curAzimuthRad = math.rad(self.externalProperties.ReferenceAzimuth)
	self.curElevationRad = math.rad(self.externalProperties.InitialElevation)
	self.curDistance = self.externalProperties.InitialDistance
	self:SetAndBoundsCheckAzimuthValues()
	self:SetAndBoundsCheckElevationValues()
	self:SetAndBoundsCheckDistanceValues()
end
function OrbitalCamera:GetModuleName()
	return "OrbitalCamera"
end
function OrbitalCamera:SetInitialOrientation(humanoid)
	if not humanoid or not humanoid.RootPart then
		warn("OrbitalCamera could not set initial orientation due to missing humanoid")
		return
	end
	local newDesiredLook = (humanoid.RootPart.CFrame.lookVector - Vector3.new(0, 0.23, 0)).unit
	local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, self:GetCameraLookVector())
	local vertShift = math.asin(self:GetCameraLookVector().y) - math.asin(newDesiredLook.y)
	if not Util.IsFinite(horizontalShift) then
		horizontalShift = 0
	end
	if not Util.IsFinite(vertShift) then
		vertShift = 0
	end
	self.rotateInput = Vector2.new(horizontalShift, vertShift)
end
function OrbitalCamera:GetCameraToSubjectDistance()
	return self.curDistance
end
function OrbitalCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	print("OrbitalCamera SetCameraToSubjectDistance ", desiredSubjectDistance)
	local player = PlayersService.LocalPlayer
	if player then
		self.currentSubjectDistance = Util.Clamp(self.minDistance, self.maxDistance, desiredSubjectDistance)
		self.currentSubjectDistance = math.max(self.currentSubjectDistance, self.FIRST_PERSON_DISTANCE_THRESHOLD)
	end
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
	return self.currentSubjectDistance
end
function OrbitalCamera:CalculateNewLookVector(suppliedLookVector, xyRotateVector)
	local currLookVector = suppliedLookVector or self:GetCameraLookVector()
	local currPitchAngle = math.asin(currLookVector.y)
	local yTheta = Util.Clamp(currPitchAngle - math.rad(MAX_ALLOWED_ELEVATION_DEG), currPitchAngle - math.rad(MIN_ALLOWED_ELEVATION_DEG), xyRotateVector.y)
	local constrainedRotateInput = Vector2.new(xyRotateVector.x, yTheta)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local newLookVector = (CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y, 0, 0)).lookVector
	return newLookVector
end
function OrbitalCamera:GetGamepadPan(name, state, input)
	if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
		if self.r3ButtonDown or self.l3ButtonDown then
			if input.Position.Y > THUMBSTICK_DEADZONE then
				self.gamepadDollySpeedMultiplier = 0.96
			elseif input.Position.Y < -THUMBSTICK_DEADZONE then
				self.gamepadDollySpeedMultiplier = 1.04
			else
				self.gamepadDollySpeedMultiplier = 1
			end
		else
			if state == Enum.UserInputState.Cancel then
				self.gamepadPanningCamera = ZERO_VECTOR2
				return
			end
			local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
			if inputVector.magnitude > THUMBSTICK_DEADZONE then
				self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
			else
				self.gamepadPanningCamera = ZERO_VECTOR2
			end
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function OrbitalCamera:DoGamepadZoom(name, state, input)
	if input.UserInputType == self.activeGamepad and (input.KeyCode == Enum.KeyCode.ButtonR3 or input.KeyCode == Enum.KeyCode.ButtonL3) then
		if state == Enum.UserInputState.Begin then
			self.r3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonR3
			self.l3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonL3
		elseif state == Enum.UserInputState.End then
			if input.KeyCode == Enum.KeyCode.ButtonR3 then
				self.r3ButtonDown = false
			elseif input.KeyCode == Enum.KeyCode.ButtonL3 then
				self.l3ButtonDown = false
			end
			if not self.r3ButtonDown and not self.l3ButtonDown then
				self.gamepadDollySpeedMultiplier = 1
			end
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Pass
	end
end
function OrbitalCamera:BindGamepadInputActions()
	if FFlagPlayerScriptsBindAtPriority2 then
		self:BindAction("OrbitalCamGamepadPan", function(name, state, input)
			return self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		self:BindAction("OrbitalCamGamepadZoom", function(name, state, input)
			return self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonR3, Enum.KeyCode.ButtonL3)
	else
		local ContextActionService = game:GetService("ContextActionService")
		ContextActionService:BindAction("OrbitalCamGamepadPan", function(name, state, input)
			self:GetGamepadPan(name, state, input)
		end, false, Enum.KeyCode.Thumbstick2)
		ContextActionService:BindAction("OrbitalCamGamepadZoom", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonR3)
		ContextActionService:BindAction("OrbitalCamGamepadZoomAlt", function(name, state, input)
			self:DoGamepadZoom(name, state, input)
		end, false, Enum.KeyCode.ButtonL3)
	end
end
function OrbitalCamera:Update(dt)
	local now = tick()
	local timeDelta = now - self.lastUpdate
	local userPanningTheCamera = self.UserPanningTheCamera == true
	local camera = workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera and camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	local isOnASkateboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end
	if self.lastUpdate then
		local gamepadRotation = self:UpdateGamepad()
		if self:ShouldUseVRRotation() then
			self.RotateInput = self.RotateInput + self:GetVRRotationInput()
		else
			local delta = math.min(0.1, timeDelta)
			if gamepadRotation ~= ZERO_VECTOR2 then
				userPanningTheCamera = true
				self.rotateInput = self.rotateInput + gamepadRotation * delta
			end
			local angle = 0
			if not isInVehicle and not isOnASkateboard then
				angle = angle + (self.TurningLeft and -120 or 0)
				angle = angle + (self.TurningRight and 120 or 0)
			end
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(math.rad(angle * delta), 0)
				userPanningTheCamera = true
			end
		end
	end
	if userPanningTheCamera then
		tweenSpeed = 0
		self.lastUserPanCamera = tick()
	end
	local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
	local subjectPosition = self:GetSubjectPosition()
	if subjectPosition and player and camera then
		if self.gamepadDollySpeedMultiplier ~= 1 then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance * self.gamepadDollySpeedMultiplier)
		end
		local VREnabled = VRService.VREnabled
		newCameraFocus = VREnabled and self:GetVRFocus(subjectPosition, timeDelta) or CFrame.new(subjectPosition)
		local cameraFocusP = newCameraFocus.p
		if VREnabled and not self:IsInFirstPerson() then
			local cameraHeight = self:GetCameraHeight()
			local vecToSubject = subjectPosition - camera.CFrame.p
			local distToSubject = vecToSubject.magnitude
			if distToSubject > self.currentSubjectDistance or self.rotateInput.x ~= 0 then
				local desiredDist = math.min(distToSubject, self.currentSubjectDistance)
				vecToSubject = self:CalculateNewLookVector(vecToSubject.unit * X1_Y0_Z1, Vector2.new(self.rotateInput.x, 0)) * desiredDist
				local newPos = cameraFocusP - vecToSubject
				local desiredLookDir = camera.CFrame.lookVector
				if self.rotateInput.x ~= 0 then
					desiredLookDir = vecToSubject
				end
				local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
				self.RotateInput = ZERO_VECTOR2
				newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
			end
		else
			self.curAzimuthRad = self.curAzimuthRad - self.rotateInput.x
			if self.useAzimuthLimits then
				self.curAzimuthRad = Util.Clamp(self.minAzimuthAbsoluteRad, self.maxAzimuthAbsoluteRad, self.curAzimuthRad)
			else
				self.curAzimuthRad = self.curAzimuthRad ~= 0 and math.sign(self.curAzimuthRad) * (math.abs(self.curAzimuthRad) % TAU) or 0
			end
			self.curElevationRad = Util.Clamp(self.minElevationRad, self.maxElevationRad, self.curElevationRad + self.rotateInput.y)
			local cameraPosVector = self.currentSubjectDistance * (CFrame.fromEulerAnglesYXZ(-self.curElevationRad, self.curAzimuthRad, 0) * UNIT_Z)
			local camPos = subjectPosition + cameraPosVector
			newCameraCFrame = CFrame.new(camPos, subjectPosition)
			self.rotateInput = ZERO_VECTOR2
		end
		self.lastCameraTransform = newCameraCFrame
		self.lastCameraFocus = newCameraFocus
		if (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
			self.lastSubjectCFrame = cameraSubject.CFrame
		else
			self.lastSubjectCFrame = nil
		end
	end
	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end
return OrbitalCamera
]]></ProtectedString><string name="Name">OrbitalCamera</string></Properties></Item><Item class="ModuleScript" referent="RBX636"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UNIT_X = Vector3.new(1, 0, 0)
local UNIT_Y = Vector3.new(0, 1, 0)
local UNIT_Z = Vector3.new(0, 0, 1)
local X1_Y0_Z1 = Vector3.new(1, 0, 1)
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local ZERO_VECTOR2 = Vector2.new(0, 0)
local VR_PITCH_FRACTION = 0.25
local tweenAcceleration = math.rad(220)
local tweenSpeed = math.rad(0)
local tweenMaxSpeed = math.rad(250)
local TIME_BEFORE_AUTO_ROTATE = 2
local PORTRAIT_OFFSET = Vector3.new(0, -3, 0)
local Util = require(script.Parent:WaitForChild("CameraUtils"))
local PlayersService = game:GetService("Players")
local VRService = game:GetService("VRService")
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local LegacyCamera = setmetatable({}, BaseCamera)
LegacyCamera.__index = LegacyCamera
function LegacyCamera.new()
	local self = setmetatable(BaseCamera.new(), LegacyCamera)
	self.cameraType = Enum.CameraType.Fixed
	self.lastUpdate = tick()
	self.lastDistanceToSubject = nil
	return self
end
function LegacyCamera:GetModuleName()
	return "LegacyCamera"
end
function LegacyCamera:Test()
	print("LegacyCamera:Test()")
end
function LegacyCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	return BaseCamera.SetCameraToSubjectDistance(self, desiredSubjectDistance)
end
function LegacyCamera:Update(dt)
	if not self.cameraType then
		return
	end
	local now = tick()
	local timeDelta = now - self.lastUpdate
	local camera = workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera and camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	local isOnASkateboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastDistanceToSubject = nil
	end
	local subjectPosition = self:GetSubjectPosition()
	if self.cameraType == Enum.CameraType.Fixed then
		if self.lastUpdate then
			local delta = math.min(0.1, now - self.lastUpdate)
			local gamepadRotation = self:UpdateGamepad()
			self.rotateInput = self.rotateInput + gamepadRotation * delta
		end
		if subjectPosition and player and camera then
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local newLookVector = self:CalculateNewLookVector()
			self.rotateInput = ZERO_VECTOR2
			newCameraFocus = camera.Focus
			newCameraCFrame = CFrame.new(camera.CFrame.p, camera.CFrame.p + distanceToSubject * newLookVector)
		end
	elseif self.cameraType == Enum.CameraType.Attach then
		if subjectPosition and camera then
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local humanoid = self:GetHumanoid()
			if self.lastUpdate and humanoid and humanoid.RootPart then
				local delta = math.min(0.1, now - self.lastUpdate)
				local gamepadRotation = self:UpdateGamepad()
				self.rotateInput = self.rotateInput + gamepadRotation * delta
				local forwardVector = humanoid.RootPart.CFrame.lookVector
				local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
				if Util.IsFinite(y) then
					self.rotateInput = Vector2.new(y, self.rotateInput.Y)
				end
			end
			local newLookVector = self:CalculateNewLookVector()
			self.rotateInput = ZERO_VECTOR2
			newCameraFocus = CFrame.new(subjectPosition)
			newCameraCFrame = CFrame.new(subjectPosition - distanceToSubject * newLookVector, subjectPosition)
		end
	elseif self.cameraType == Enum.CameraType.Watch then
		if subjectPosition and player and camera then
			local cameraLook
			local humanoid = self:GetHumanoid()
			if humanoid and humanoid.RootPart then
				local diffVector = subjectPosition - camera.CFrame.p
				cameraLook = diffVector.unit
				if self.lastDistanceToSubject and self.lastDistanceToSubject == self:GetCameraToSubjectDistance() then
					local newDistanceToSubject = diffVector.magnitude
					self:SetCameraToSubjectDistance(newDistanceToSubject)
				end
			end
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local newLookVector = self:CalculateNewLookVector(cameraLook)
			self.rotateInput = ZERO_VECTOR2
			newCameraFocus = CFrame.new(subjectPosition)
			newCameraCFrame = CFrame.new(subjectPosition - distanceToSubject * newLookVector, subjectPosition)
			self.lastDistanceToSubject = distanceToSubject
		end
	else
		return camera.CFrame, camera.Focus
	end
	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end
return LegacyCamera
]]></ProtectedString><string name="Name">LegacyCamera</string></Properties></Item></Item><Item class="ModuleScript" referent="RBX642"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ControlModule = {}
ControlModule.__index = ControlModule
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local Keyboard = require(script:WaitForChild("Keyboard"))
local Gamepad = require(script:WaitForChild("Gamepad"))
local TouchDPad = require(script:WaitForChild("TouchDPad"))
local DynamicThumbstick = require(script:WaitForChild("DynamicThumbstick"))
local ClickToMove = require(script:WaitForChild("ClickToMoveController"))
local TouchThumbstick = require(script:WaitForChild("TouchThumbstick"))
local TouchThumbpad = require(script:WaitForChild("TouchThumbpad"))
local TouchJump = require(script:WaitForChild("TouchJump"))
local VehicleController = require(script:WaitForChild("VehicleController"))
local CONTROL_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
local movementEnumToModuleMap = {
	[Enum.TouchMovementMode.DPad] = TouchDPad,
	[Enum.DevTouchMovementMode.DPad] = TouchDPad,
	[Enum.TouchMovementMode.Thumbpad] = TouchThumbpad,
	[Enum.DevTouchMovementMode.Thumbpad] = TouchThumbpad,
	[Enum.TouchMovementMode.Thumbstick] = TouchThumbstick,
	[Enum.DevTouchMovementMode.Thumbstick] = TouchThumbstick,
	[Enum.TouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
	[Enum.DevTouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
	[Enum.TouchMovementMode.ClickToMove] = ClickToMove,
	[Enum.DevTouchMovementMode.ClickToMove] = ClickToMove,
	[Enum.TouchMovementMode.Default] = DynamicThumbstick,
	[Enum.ComputerMovementMode.Default] = Keyboard,
	[Enum.ComputerMovementMode.KeyboardMouse] = Keyboard,
	[Enum.DevComputerMovementMode.KeyboardMouse] = Keyboard,
	[Enum.DevComputerMovementMode.Scriptable] = nil,
	[Enum.ComputerMovementMode.ClickToMove] = ClickToMove,
	[Enum.DevComputerMovementMode.ClickToMove] = ClickToMove
}
local computerInputTypeToModuleMap = {
	[Enum.UserInputType.Keyboard] = Keyboard,
	[Enum.UserInputType.MouseButton1] = Keyboard,
	[Enum.UserInputType.MouseButton2] = Keyboard,
	[Enum.UserInputType.MouseButton3] = Keyboard,
	[Enum.UserInputType.MouseWheel] = Keyboard,
	[Enum.UserInputType.MouseMovement] = Keyboard,
	[Enum.UserInputType.Gamepad1] = Gamepad,
	[Enum.UserInputType.Gamepad2] = Gamepad,
	[Enum.UserInputType.Gamepad3] = Gamepad,
	[Enum.UserInputType.Gamepad4] = Gamepad
}
function ControlModule.new()
	local self = setmetatable({}, ControlModule)
	self.controllers = {}
	self.activeControlModule = nil
	self.activeController = nil
	self.touchJumpController = nil
	self.moveFunction = Players.LocalPlayer.Move
	self.humanoid = nil
	self.lastInputType = Enum.UserInputType.None
	self.cameraRelative = true
	self.humanoidSeatedConn = nil
	self.vehicleController = nil
	self.touchControlFrame = nil
	self.vehicleController = VehicleController.new(CONTROL_ACTION_PRIORITY)
	Players.LocalPlayer.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char)
	end)
	Players.LocalPlayer.CharacterRemoving:Connect(function(char)
		self:OnCharacterAdded(char)
	end)
	if Players.LocalPlayer.Character then
		self:OnCharacterAdded(Players.LocalPlayer.Character)
	end
	RunService:BindToRenderStep("ControlScriptRenderstep", Enum.RenderPriority.Input.Value, function(dt)
		self:OnRenderStepped(dt)
	end)
	UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
		self:OnLastInputTypeChanged(newLastInputType)
	end)
	local propertyChangeListeners = {
		UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
			self:OnTouchMovementModeChange()
		end),
		Players.LocalPlayer:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
			self:OnTouchMovementModeChange()
		end),
		UserGameSettings:GetPropertyChangedSignal("ComputerMovementMode"):Connect(function()
			self:OnComputerMovementModeChange()
		end),
		Players.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
			self:OnComputerMovementModeChange()
		end)
	}
	self.playerGui = nil
	self.touchGui = nil
	self.playerGuiAddedConn = nil
	if UserInputService.TouchEnabled then
		self.playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
		if self.playerGui then
			self:CreateTouchGuiContainer()
			self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
		else
			self.playerGuiAddedConn = Players.LocalPlayer.ChildAdded:Connect(function(child)
				if child:IsA("PlayerGui") then
					self.playerGui = child
					self:CreateTouchGuiContainer()
					self.playerGuiAddedConn:Disconnect()
					self.playerGuiAddedConn = nil
					self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
				end
			end)
		end
	else
		self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
	end
	return self
end
function ControlModule:GetMoveVector()
	if self.activeController then
		return self.activeController:GetMoveVector()
	end
	return Vector3.new(0, 0, 0)
end
function ControlModule:GetActiveController()
	return self.activeController
end
function ControlModule:EnableActiveControlModule()
	if self.activeControlModule == ClickToMove then
		self.activeController:Enable(true, Players.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice, self.touchJumpController)
	elseif self.touchControlFrame then
		self.activeController:Enable(true, self.touchControlFrame)
	else
		self.activeController:Enable(true)
	end
end
function ControlModule:Enable(enable)
	if not self.activeController then
		return
	end
	if enable == nil then
		enable = true
	end
	if enable then
		self:EnableActiveControlModule()
	else
		self:Disable()
	end
end
function ControlModule:Disable()
	if self.activeController then
		self.activeController:Enable(false)
		if self.moveFunction then
			self.moveFunction(Players.LocalPlayer, Vector3.new(0, 0, 0), self.cameraRelative)
		end
	end
end
function ControlModule:SelectComputerMovementModule()
	if not UserInputService.KeyboardEnabled and not UserInputService.GamepadEnabled then
		return nil, false
	end
	local computerModule
	local DevMovementMode = Players.LocalPlayer.DevComputerMovementMode
	if DevMovementMode == Enum.DevComputerMovementMode.UserChoice then
		computerModule = computerInputTypeToModuleMap[lastInputType]
		if UserGameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove and computerModule == Keyboard then
			computerModule = ClickToMove
		end
	else
		computerModule = movementEnumToModuleMap[DevMovementMode]
		if not computerModule and DevMovementMode ~= Enum.DevComputerMovementMode.Scriptable then
			warn("No character control module is associated with DevComputerMovementMode ", DevMovementMode)
		end
	end
	if computerModule then
		return computerModule, true
	elseif DevMovementMode == Enum.DevComputerMovementMode.Scriptable then
		return nil, true
	else
		return nil, false
	end
end
function ControlModule:SelectTouchModule()
	if not UserInputService.TouchEnabled then
		return nil, false
	end
	local touchModule
	local DevMovementMode = Players.LocalPlayer.DevTouchMovementMode
	if DevMovementMode == Enum.DevTouchMovementMode.UserChoice then
		touchModule = movementEnumToModuleMap[UserGameSettings.TouchMovementMode]
	elseif DevMovementMode == Enum.DevTouchMovementMode.Scriptable then
		return nil, true
	else
		touchModule = movementEnumToModuleMap[DevMovementMode]
	end
	return touchModule, true
end
function ControlModule:OnRenderStepped(dt)
	if self.activeController and self.activeController.enabled and self.humanoid then
		local moveVector = self.activeController:GetMoveVector()
		local vehicleConsumedInput = false
		if self.vehicleController then
			moveVector, vehicleConsumedInput = self.vehicleController:Update(moveVector, self.activeControlModule == Gamepad)
		end
		self.moveFunction(Players.LocalPlayer, moveVector, self.cameraRelative)
		self.humanoid.Jump = not self.activeController:GetIsJumping() and self.touchJumpController and self.touchJumpController:GetIsJumping()
	end
end
function ControlModule:OnHumanoidSeated(active, currentSeatPart)
	if active then
		if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
			if not self.vehicleController then
				self.vehicleController = self.vehicleController.new(CONTROL_ACTION_PRIORITY)
			end
			self.vehicleController:Enable(true, currentSeatPart)
		end
	elseif self.vehicleController then
		self.vehicleController:Enable(false, currentSeatPart)
	end
end
function ControlModule:OnCharacterAdded(char)
	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	while not self.humanoid do
		char.ChildAdded:wait()
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
	end
	if self.humanoidSeatedConn then
		self.humanoidSeatedConn:Disconnect()
		self.humanoidSeatedConn = nil
	end
	self.humanoidSeatedConn = self.humanoid.Seated:Connect(function(active, currentSeatPart)
		self:OnHumanoidSeated(active, currentSeatPart)
	end)
end
function ControlModule:OnCharacterRemoving(char)
	self.humanoid = nil
end
function ControlModule:SwitchToController(controlModule)
	if not controlModule then
		if self.activeController then
			self.activeController:Enable(false)
		end
		self.activeController = nil
		self.activeControlModule = nil
	else
		if not self.controllers[controlModule] then
			self.controllers[controlModule] = controlModule.new(CONTROL_ACTION_PRIORITY)
		end
		if self.activeController ~= self.controllers[controlModule] then
			if self.activeController then
				self.activeController:Enable(false)
			end
			self.activeController = self.controllers[controlModule]
			self.activeControlModule = controlModule
			if self.touchControlFrame and (self.activeControlModule == TouchThumbpad or self.activeControlModule == TouchThumbstick or self.activeControlModule == ClickToMove or self.activeControlModule == DynamicThumbstick) then
				if not self.controllers[TouchJump] then
					self.controllers[TouchJump] = TouchJump.new()
				end
				self.touchJumpController = self.controllers[TouchJump]
				self.touchJumpController:Enable(true, self.touchControlFrame)
			elseif self.touchJumpController then
				self.touchJumpController:Enable(false)
			end
			self:EnableActiveControlModule()
		end
	end
end
function ControlModule:OnLastInputTypeChanged(newLastInputType)
	if lastInputType == newLastInputType then
		warn("LastInputType Change listener called with current type.")
	end
	lastInputType = newLastInputType
	if lastInputType == Enum.UserInputType.Touch then
		local touchModule, success = self:SelectTouchModule()
		if success then
			while not self.touchControlFrame do
				wait()
			end
			self:SwitchToController(touchModule)
		end
	elseif computerInputTypeToModuleMap[lastInputType] ~= nil then
		local computerModule = self:SelectComputerMovementModule()
		if computerModule then
			self:SwitchToController(computerModule)
		end
	end
end
function ControlModule:OnComputerMovementModeChange()
	local controlModule, success = self:SelectComputerMovementModule()
	if success then
		self:SwitchToController(controlModule)
	end
end
function ControlModule:OnTouchMovementModeChange()
	local touchModule, success = self:SelectTouchModule()
	if success then
		while not self.touchControlFrame do
			wait()
		end
		self:SwitchToController(touchModule)
	end
end
function ControlModule:CreateTouchGuiContainer()
	if self.touchGui then
		self.touchGui:Destroy()
	end
	self.touchGui = Instance.new("ScreenGui")
	self.touchGui.Name = "TouchGui"
	self.touchGui.ResetOnSpawn = false
	self.touchControlFrame = Instance.new("Frame")
	self.touchControlFrame.Name = "TouchControlFrame"
	self.touchControlFrame.Size = UDim2.new(1, 0, 1, 0)
	self.touchControlFrame.BackgroundTransparency = 1
	self.touchControlFrame.Parent = self.touchGui
	self.touchGui.Parent = self.playerGui
end
function ControlModule:GetClickToMoveController()
	if not self.controllers[ClickToMove] then
		self.controllers[ClickToMove] = ClickToMove.new(CONTROL_ACTION_PRIORITY)
	end
	return self.controllers[ClickToMove]
end
return ControlModule.new()
]]></ProtectedString><string name="Name">ControlModule</string></Properties><Item class="ModuleScript" referent="RBX646"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchJump = setmetatable({}, BaseCharacterController)
TouchJump.__index = TouchJump
function TouchJump.new()
	local self = setmetatable(BaseCharacterController.new(), TouchJump)
	self.parentUIFrame = nil
	self.jumpButton = nil
	self.characterAddedConn = nil
	self.humanoidStateEnabledChangedConn = nil
	self.humanoidJumpPowerConn = nil
	self.humanoidParentConn = nil
	self.externallyEnabled = false
	self.jumpPower = 0
	self.jumpStateEnabled = true
	self.isJumping = false
	self.humanoid = nil
	return self
end
function TouchJump:EnableButton(enable)
	if enable then
		if not self.jumpButton then
			self:Create()
		end
		local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
		if humanoid and self.externallyEnabled and self.externallyEnabled and humanoid.JumpPower > 0 then
			self.jumpButton.Visible = true
		end
	else
		self.jumpButton.Visible = false
		self.isJumping = false
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	end
end
function TouchJump:UpdateEnabled()
	if self.jumpPower > 0 and self.jumpStateEnabled then
		self:EnableButton(true)
	else
		self:EnableButton(false)
	end
end
function TouchJump:HumanoidChanged(prop)
	local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if prop == "JumpPower" then
			self.jumpPower = humanoid.JumpPower
			self:UpdateEnabled()
		elseif prop == "Parent" and not humanoid.Parent then
			self.humanoidChangeConn:Disconnect()
		end
	end
end
function TouchJump:HumanoidStateEnabledChanged(state, isEnabled)
	if state == Enum.HumanoidStateType.Jumping then
		self.jumpStateEnabled = isEnabled
		self:UpdateEnabled()
	end
end
function TouchJump:CharacterAdded(char)
	if self.humanoidChangeConn then
		self.humanoidChangeConn:Disconnect()
		self.humanoidChangeConn = nil
	end
	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	while not self.humanoid do
		char.ChildAdded:wait()
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
	end
	self.humanoidJumpPowerConn = self.humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
		self.jumpPower = self.humanoid.JumpPower
		self:UpdateEnabled()
	end)
	self.humanoidParentConn = self.humanoid:GetPropertyChangedSignal("Parent"):Connect(function()
		if not self.humanoid.Parent then
			self.humanoidJumpPowerConn:Disconnect()
			self.humanoidJumpPowerConn = nil
			self.humanoidParentConn:Disconnect()
			self.humanoidParentConn = nil
		end
	end)
	self.humanoidStateEnabledChangedConn = self.humanoid.StateEnabledChanged:Connect(function(state, enabled)
		self:HumanoidStateEnabledChanged(state, enabled)
	end)
	self.jumpPower = self.humanoid.JumpPower
	self.jumpStateEnabled = self.humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping)
	self:UpdateEnabled()
end
function TouchJump:SetupCharacterAddedFunction()
	self.characterAddedConn = Players.LocalPlayer.CharacterAdded:Connect(function(char)
		self:CharacterAdded(char)
	end)
	if Players.LocalPlayer.Character then
		self:CharacterAdded(Players.LocalPlayer.Character)
	end
end
function TouchJump:Enable(enable, parentFrame)
	if parentFrame then
		self.parentUIFrame = parentFrame
	end
	self.externallyEnabled = enable
	self:EnableButton(enable)
end
function TouchJump:Create()
	if not self.parentUIFrame then
		return
	end
	if self.jumpButton then
		self.jumpButton:Destroy()
		self.jumpButton = nil
	end
	local minAxis = math.min(self.parentUIFrame.AbsoluteSize.x, self.parentUIFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	local jumpButtonSize = isSmallScreen and 70 or 120
	self.jumpButton = Instance.new("ImageButton")
	self.jumpButton.Name = "JumpButton"
	self.jumpButton.Visible = false
	self.jumpButton.BackgroundTransparency = 1
	self.jumpButton.Image = TOUCH_CONTROL_SHEET
	self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	self.jumpButton.ImageRectSize = Vector2.new(144, 144)
	self.jumpButton.Size = UDim2.new(0, jumpButtonSize, 0, jumpButtonSize)
	self.jumpButton.Position = isSmallScreen and UDim2.new(1, -(jumpButtonSize * 1.5 - 10), 1, -jumpButtonSize - 20) or UDim2.new(1, -(jumpButtonSize * 1.5 - 10), 1, -jumpButtonSize * 1.75)
	local touchObject
	self.jumpButton.InputBegan:connect(function(inputObject)
		if touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		touchObject = inputObject
		self.jumpButton.ImageRectOffset = Vector2.new(146, 146)
		self.isJumping = true
	end)
	local function OnInputEnded()
		touchObject = nil
		self.isJumping = false
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	end
	self.jumpButton.InputEnded:connect(function(inputObject)
		if inputObject == touchObject then
			OnInputEnded()
		end
	end)
	GuiService.MenuOpened:connect(function()
		if touchObject then
			OnInputEnded()
		end
	end)
	if not self.characterAddedConn then
		self:SetupCharacterAddedFunction()
	end
	self.jumpButton.Parent = self.parentUIFrame
end
return TouchJump
]]></ProtectedString><string name="Name">TouchJump</string></Properties></Item><Item class="ModuleScript" referent="RBX651"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local Keyboard = setmetatable({}, BaseCharacterController)
Keyboard.__index = Keyboard
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
function Keyboard.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new(), Keyboard)
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	self.textFocusReleasedConn = nil
	self.textFocusGainedConn = nil
	self.windowFocusReleasedConn = nil
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.jumpEnabled = true
	return self
end
function Keyboard:Enable(enable)
	if not UserInputService.KeyboardEnabled then
		return false
	end
	if enable == self.enabled then
		return true
	end
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		self:BindContextActions()
		self:ConnectFocusEventListeners()
	else
		self:UnbindContextActions()
		self:DisconnectFocusEventListeners()
	end
	self.enabled = enable
	return true
end
function Keyboard:UpdateMovement(inputState)
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector = ZERO_VECTOR3
	else
		self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
	end
end
function Keyboard:BindContextActions()
	local function handleMoveForward(actionName, inputState, inputObject)
		self.forwardValue = inputState == Enum.UserInputState.Begin and -1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleMoveBackward(actionName, inputState, inputObject)
		self.backwardValue = inputState == Enum.UserInputState.Begin and 1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleMoveLeft(actionName, inputState, inputObject)
		self.leftValue = inputState == Enum.UserInputState.Begin and -1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleMoveRight(actionName, inputState, inputObject)
		self.rightValue = inputState == Enum.UserInputState.Begin and 1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	local function handleJumpAction(actionName, inputState, inputObject)
		self.isJumping = self.jumpEnabled and inputState == Enum.UserInputState.Begin
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Pass
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		ContextActionService:BindActionAtPriority("moveForwardAction", handleMoveForward, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterForward)
		ContextActionService:BindActionAtPriority("moveBackwardAction", handleMoveBackward, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterBackward)
		ContextActionService:BindActionAtPriority("moveLeftAction", handleMoveLeft, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterLeft)
		ContextActionService:BindActionAtPriority("moveRightAction", handleMoveRight, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterRight)
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false, self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterJump)
	else
		ContextActionService:BindAction("moveForwardAction", handleMoveForward, false, Enum.PlayerActions.CharacterForward)
		ContextActionService:BindAction("moveBackwardAction", handleMoveBackward, false, Enum.PlayerActions.CharacterBackward)
		ContextActionService:BindAction("moveLeftAction", handleMoveLeft, false, Enum.PlayerActions.CharacterLeft)
		ContextActionService:BindAction("moveRightAction", handleMoveRight, false, Enum.PlayerActions.CharacterRight)
		ContextActionService:BindAction("jumpAction", handleJumpAction, false, Enum.PlayerActions.CharacterJump)
	end
end
function Keyboard:UnbindContextActions()
	ContextActionService:UnbindAction("moveForwardAction")
	ContextActionService:UnbindAction("moveBackwardAction")
	ContextActionService:UnbindAction("moveLeftAction")
	ContextActionService:UnbindAction("moveRightAction")
	ContextActionService:UnbindAction("jumpAction")
end
function Keyboard:ConnectFocusEventListeners()
	local function onFocusReleased()
		self.moveVector = ZERO_VECTOR3
		self.forwardValue = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.isJumping = false
	end
	local function onTextFocusGained(textboxFocused)
		self.isJumping = false
	end
	self.textFocusReleasedConn = UserInputService.TextBoxFocusReleased:Connect(onFocusReleased)
	self.textFocusGainedConn = UserInputService.TextBoxFocused:Connect(onTextFocusGained)
	self.windowFocusReleasedConn = UserInputService.WindowFocused:Connect(onFocusReleased)
end
function Keyboard:DisconnectFocusEventListeners()
	if self.textFocusReleasedCon then
		self.textFocusReleasedCon:Disconnect()
		self.textFocusReleasedCon = nil
	end
	if self.textFocusGainedConn then
		self.textFocusGainedConn:Disconnect()
		self.textFocusGainedConn = nil
	end
	if self.windowFocusReleasedConn then
		self.windowFocusReleasedConn:Disconnect()
		self.windowFocusReleasedConn = nil
	end
end
return Keyboard
]]></ProtectedString><string name="Name">Keyboard</string></Properties></Item><Item class="ModuleScript" referent="RBX656"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ClickToMoveDisplay = {}
local FAILURE_ANIMATION_ID = "rbxassetid://2874840706"
local TrailDotIcon = "rbxasset://textures/ui/traildot.png"
local EndWaypointIcon = "rbxasset://textures/ui/waypoint.png"
local WaypointsAlwaysOnTop = false
local WAYPOINT_INCLUDE_FACTOR = 2
local LAST_DOT_DISTANCE = 3
local WAYPOINT_BILLBOARD_SIZE = UDim2.new(0, 42, 0, 50)
local ENDWAYPOINT_SIZE_OFFSET_MIN = Vector2.new(0, 0.5)
local ENDWAYPOINT_SIZE_OFFSET_MAX = Vector2.new(0, 1)
local FAIL_WAYPOINT_SIZE_OFFSET_CENTER = Vector2.new(0, 0.5)
local FAIL_WAYPOINT_SIZE_OFFSET_LEFT = Vector2.new(0.1, 0.5)
local FAIL_WAYPOINT_SIZE_OFFSET_RIGHT = Vector2.new(-0.1, 0.5)
local FAILURE_TWEEN_LENGTH = 0.125
local FAILURE_TWEEN_COUNT = 4
local TWEEN_WAYPOINT_THRESHOLD = 5
local TRAIL_DOT_PARENT_NAME = "ClickToMoveDisplay"
local TrailDotSize = Vector2.new(1.5, 1.5)
local TRAIL_DOT_MIN_SCALE = 1
local TRAIL_DOT_MIN_DISTANCE = 10
local TRAIL_DOT_MAX_SCALE = 2.5
local TRAIL_DOT_MAX_DISTANCE = 100
local PlayersService = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = PlayersService.LocalPlayer
local function CreateWaypointTemplates()
	local TrailDotTemplate = Instance.new("Part")
	TrailDotTemplate.Size = Vector3.new(1, 1, 1)
	TrailDotTemplate.Anchored = true
	TrailDotTemplate.CanCollide = false
	TrailDotTemplate.Name = "TrailDot"
	TrailDotTemplate.Transparency = 1
	local TrailDotImage = Instance.new("ImageHandleAdornment")
	TrailDotImage.Name = "TrailDotImage"
	TrailDotImage.Size = TrailDotSize
	TrailDotImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
	TrailDotImage.AlwaysOnTop = WaypointsAlwaysOnTop
	TrailDotImage.Image = TrailDotIcon
	TrailDotImage.Adornee = TrailDotTemplate
	TrailDotImage.Parent = TrailDotTemplate
	local EndWaypointTemplate = Instance.new("Part")
	EndWaypointTemplate.Size = Vector3.new(2, 2, 2)
	EndWaypointTemplate.Anchored = true
	EndWaypointTemplate.CanCollide = false
	EndWaypointTemplate.Name = "EndWaypoint"
	EndWaypointTemplate.Transparency = 1
	local EndWaypointImage = Instance.new("ImageHandleAdornment")
	EndWaypointImage.Name = "TrailDotImage"
	EndWaypointImage.Size = TrailDotSize
	EndWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
	EndWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
	EndWaypointImage.Image = TrailDotIcon
	EndWaypointImage.Adornee = EndWaypointTemplate
	EndWaypointImage.Parent = EndWaypointTemplate
	local EndWaypointBillboard = Instance.new("BillboardGui")
	EndWaypointBillboard.Name = "EndWaypointBillboard"
	EndWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
	EndWaypointBillboard.LightInfluence = 0
	EndWaypointBillboard.SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MIN
	EndWaypointBillboard.AlwaysOnTop = true
	EndWaypointBillboard.Adornee = EndWaypointTemplate
	EndWaypointBillboard.Parent = EndWaypointTemplate
	local EndWaypointImageLabel = Instance.new("ImageLabel")
	EndWaypointImageLabel.Image = EndWaypointIcon
	EndWaypointImageLabel.BackgroundTransparency = 1
	EndWaypointImageLabel.Size = UDim2.new(1, 0, 1, 0)
	EndWaypointImageLabel.Parent = EndWaypointBillboard
	local FailureWaypointTemplate = Instance.new("Part")
	FailureWaypointTemplate.Size = Vector3.new(2, 2, 2)
	FailureWaypointTemplate.Anchored = true
	FailureWaypointTemplate.CanCollide = false
	FailureWaypointTemplate.Name = "FailureWaypoint"
	FailureWaypointTemplate.Transparency = 1
	local FailureWaypointImage = Instance.new("ImageHandleAdornment")
	FailureWaypointImage.Name = "TrailDotImage"
	FailureWaypointImage.Size = TrailDotSize
	FailureWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
	FailureWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
	FailureWaypointImage.Image = TrailDotIcon
	FailureWaypointImage.Adornee = FailureWaypointTemplate
	FailureWaypointImage.Parent = FailureWaypointTemplate
	local FailureWaypointBillboard = Instance.new("BillboardGui")
	FailureWaypointBillboard.Name = "FailureWaypointBillboard"
	FailureWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
	FailureWaypointBillboard.LightInfluence = 0
	FailureWaypointBillboard.SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER
	FailureWaypointBillboard.AlwaysOnTop = true
	FailureWaypointBillboard.Adornee = FailureWaypointTemplate
	FailureWaypointBillboard.Parent = FailureWaypointTemplate
	local FailureWaypointFrame = Instance.new("Frame")
	FailureWaypointFrame.BackgroundTransparency = 1
	FailureWaypointFrame.Size = UDim2.new(0, 0, 0, 0)
	FailureWaypointFrame.Position = UDim2.new(0.5, 0, 1, 0)
	FailureWaypointFrame.Parent = FailureWaypointBillboard
	local FailureWaypointImageLabel = Instance.new("ImageLabel")
	FailureWaypointImageLabel.Image = EndWaypointIcon
	FailureWaypointImageLabel.BackgroundTransparency = 1
	FailureWaypointImageLabel.Position = UDim2.new(0, -WAYPOINT_BILLBOARD_SIZE.X.Offset / 2, 0, -WAYPOINT_BILLBOARD_SIZE.Y.Offset)
	FailureWaypointImageLabel.Size = WAYPOINT_BILLBOARD_SIZE
	FailureWaypointImageLabel.Parent = FailureWaypointFrame
	return TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate
end
local TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
local function getTrailDotParent()
	local camera = Workspace.CurrentCamera
	local trailParent = camera:FindFirstChild(TRAIL_DOT_PARENT_NAME)
	if not trailParent then
		trailParent = Instance.new("Model")
		trailParent.Name = TRAIL_DOT_PARENT_NAME
		trailParent.Parent = camera
	end
	return trailParent
end
local function placePathWaypoint(waypointModel, position)
	local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
	local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(ray, {
		Workspace.CurrentCamera,
		LocalPlayer.Character
	})
	if hitPart then
		waypointModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
		waypointModel.Parent = getTrailDotParent()
	end
end
local TrailDot = {}
TrailDot.__index = TrailDot
function TrailDot:Destroy()
	self.DisplayModel:Destroy()
end
function TrailDot:NewDisplayModel(position)
	local newDisplayModel = TrailDotTemplate:Clone()
	placePathWaypoint(newDisplayModel, position)
	return newDisplayModel
end
function TrailDot.new(position, closestWaypoint)
	local self = setmetatable({}, TrailDot)
	self.DisplayModel = self:NewDisplayModel(position)
	self.ClosestWayPoint = closestWaypoint
	return self
end
local EndWaypoint = {}
EndWaypoint.__index = EndWaypoint
function EndWaypoint:Destroy()
	self.Destroyed = true
	self.Tween:Cancel()
	self.DisplayModel:Destroy()
end
function EndWaypoint:NewDisplayModel(position)
	local newDisplayModel = EndWaypointTemplate:Clone()
	placePathWaypoint(newDisplayModel, position)
	return newDisplayModel
end
function EndWaypoint:CreateTween()
	local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, -1, true)
	local tween = TweenService:Create(self.DisplayModel.EndWaypointBillboard, tweenInfo, {SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MAX})
	tween:Play()
	return tween
end
function EndWaypoint:TweenInFrom(originalPosition)
	local currentPositon = self.DisplayModel.Position
	local studsOffset = originalPosition - currentPositon
	self.DisplayModel.EndWaypointBillboard.StudsOffset = Vector3.new(0, studsOffset.Y, 0)
	local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local tween = TweenService:Create(self.DisplayModel.EndWaypointBillboard, tweenInfo, {
		StudsOffset = Vector3.new(0, 0, 0)
	})
	tween:Play()
	return tween
end
function EndWaypoint.new(position, closestWaypoint, originalPosition)
	local self = setmetatable({}, EndWaypoint)
	self.DisplayModel = self:NewDisplayModel(position)
	self.Destroyed = false
	if originalPosition and (originalPosition - position).magnitude > TWEEN_WAYPOINT_THRESHOLD then
		self.Tween = self:TweenInFrom(originalPosition)
		coroutine.wrap(function()
			self.Tween.Completed:Wait()
			if not self.Destroyed then
				self.Tween = self:CreateTween()
			end
		end)()
	else
		self.Tween = self:CreateTween()
	end
	self.ClosestWayPoint = closestWaypoint
	return self
end
local FailureWaypoint = {}
FailureWaypoint.__index = FailureWaypoint
function FailureWaypoint:Hide()
	self.DisplayModel.Parent = nil
end
function FailureWaypoint:Destroy()
	self.DisplayModel:Destroy()
end
function FailureWaypoint:NewDisplayModel(position)
	local newDisplayModel = FailureWaypointTemplate:Clone()
	placePathWaypoint(newDisplayModel, position)
	local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
	local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(ray, {
		Workspace.CurrentCamera,
		LocalPlayer.Character
	})
	if hitPart then
		newDisplayModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
		newDisplayModel.Parent = getTrailDotParent()
	end
	return newDisplayModel
end
function FailureWaypoint:RunFailureTween()
	wait(FAILURE_TWEEN_LENGTH)
	local tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH / 2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local tweenLeft = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo, {SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_LEFT})
	tweenLeft:Play()
	local tweenLeftRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo, {Rotation = 10})
	tweenLeftRoation:Play()
	tweenLeft.Completed:wait()
	tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, FAILURE_TWEEN_COUNT - 1, true)
	local tweenSideToSide = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo, {SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_RIGHT})
	tweenSideToSide:Play()
	tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, FAILURE_TWEEN_COUNT - 1, true)
	local tweenFlash = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame.ImageLabel, tweenInfo, {
		ImageColor3 = Color3.new(0.75, 0.75, 0.75)
	})
	tweenFlash:Play()
	local tweenRotate = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo, {Rotation = -10})
	tweenRotate:Play()
	tweenSideToSide.Completed:wait()
	tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH / 2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local tweenCenter = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo, {SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER})
	tweenCenter:Play()
	local tweenRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo, {Rotation = 0})
	tweenRoation:Play()
	tweenCenter.Completed:wait()
	wait(FAILURE_TWEEN_LENGTH)
end
function FailureWaypoint.new(position)
	local self = setmetatable({}, FailureWaypoint)
	self.DisplayModel = self:NewDisplayModel(position)
	return self
end
local failureAnimation = Instance.new("Animation")
failureAnimation.AnimationId = FAILURE_ANIMATION_ID
local lastHumanoid, lastFailureAnimationTrack
local function getFailureAnimationTrack(myHumanoid)
	if myHumanoid == lastHumanoid then
		return lastFailureAnimationTrack
	end
	lastFailureAnimationTrack = myHumanoid:LoadAnimation(failureAnimation)
	lastFailureAnimationTrack.Priority = Enum.AnimationPriority.Action
	lastFailureAnimationTrack.Looped = false
	return lastFailureAnimationTrack
end
local function findPlayerHumanoid()
	local character = LocalPlayer.Character
	if character then
		return character:FindFirstChildOfClass("Humanoid")
	end
end
local function createTrailDots(wayPoints, originalEndWaypoint)
	local newTrailDots = {}
	local count = 1
	for i = 1, #wayPoints - 1 do
		local closeToEnd = (wayPoints[i].Position - wayPoints[#wayPoints].Position).magnitude < LAST_DOT_DISTANCE
		local includeWaypoint = i % WAYPOINT_INCLUDE_FACTOR == 0 and not closeToEnd
		if includeWaypoint then
			local trailDot = TrailDot.new(wayPoints[i].Position, i)
			newTrailDots[count] = trailDot
			count = count + 1
		end
	end
	local newEndWaypoint = EndWaypoint.new(wayPoints[#wayPoints].Position, #wayPoints, originalEndWaypoint)
	table.insert(newTrailDots, newEndWaypoint)
	local reversedTrailDots = {}
	count = 1
	for i = #newTrailDots, 1, -1 do
		reversedTrailDots[count] = newTrailDots[i]
		count = count + 1
	end
	return reversedTrailDots
end
local function getTrailDotScale(distanceToCamera, defaultSize)
	local rangeLength = TRAIL_DOT_MAX_DISTANCE - TRAIL_DOT_MIN_DISTANCE
	local inRangePoint = math.clamp(distanceToCamera - TRAIL_DOT_MIN_DISTANCE, 0, rangeLength) / rangeLength
	local scale = TRAIL_DOT_MIN_SCALE + (TRAIL_DOT_MAX_SCALE - TRAIL_DOT_MIN_SCALE) * inRangePoint
	return defaultSize * scale
end
local createPathCount = 0
function ClickToMoveDisplay.CreatePathDisplay(wayPoints, originalEndWaypoint)
	createPathCount = createPathCount + 1
	local trailDots = createTrailDots(wayPoints, originalEndWaypoint)
	local function removePathBeforePoint(wayPointNumber)
		for i = #trailDots, 1, -1 do
			local trailDot = trailDots[i]
			if wayPointNumber >= trailDot.ClosestWayPoint then
				trailDot:Destroy()
				trailDots[i] = nil
			else
				break
			end
		end
	end
	local reiszeTrailDotsUpdateName = "ClickToMoveResizeTrail" .. createPathCount
	local function resizeTrailDots()
		if #trailDots == 0 then
			RunService:UnbindFromRenderStep(reiszeTrailDotsUpdateName)
			return
		end
		local cameraPos = Workspace.CurrentCamera.CFrame.p
		for i = 1, #trailDots do
			local trailDotImage = trailDots[i].DisplayModel:FindFirstChild("TrailDotImage")
			if trailDotImage then
				local distanceToCamera = (trailDots[i].DisplayModel.Position - cameraPos).magnitude
				trailDotImage.Size = getTrailDotScale(distanceToCamera, TrailDotSize)
			end
		end
	end
	RunService:BindToRenderStep(reiszeTrailDotsUpdateName, Enum.RenderPriority.Camera.Value - 1, resizeTrailDots)
	local function removePath()
		removePathBeforePoint(#wayPoints)
	end
	return removePath, removePathBeforePoint
end
local lastFailureWaypoint
function ClickToMoveDisplay.DisplayFailureWaypoint(position)
	if lastFailureWaypoint then
		lastFailureWaypoint:Hide()
	end
	local failureWaypoint = FailureWaypoint.new(position)
	lastFailureWaypoint = failureWaypoint
	coroutine.wrap(function()
		failureWaypoint:RunFailureTween()
		failureWaypoint:Destroy()
		failureWaypoint = nil
	end)()
end
function ClickToMoveDisplay.CreateEndWaypoint(position)
	return EndWaypoint.new(position)
end
function ClickToMoveDisplay.PlayFailureAnimation()
	local myHumanoid = findPlayerHumanoid()
	if myHumanoid then
		local animationTrack = getFailureAnimationTrack(myHumanoid)
		animationTrack:Play()
	end
end
function ClickToMoveDisplay.CancelFailureAnimation()
	if lastFailureAnimationTrack ~= nil and lastFailureAnimationTrack.IsPlaying then
		lastFailureAnimationTrack:Stop()
	end
end
function ClickToMoveDisplay.SetWaypointTexture(texture)
	TrailDotIcon = texture
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end
function ClickToMoveDisplay.GetWaypointTexture()
	return TrailDotIcon
end
function ClickToMoveDisplay.SetWaypointRadius(radius)
	TrailDotSize = Vector2.new(radius, radius)
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end
function ClickToMoveDisplay.GetWaypointRadius()
	return TrailDotSize.X
end
function ClickToMoveDisplay.SetEndWaypointTexture(texture)
	EndWaypointIcon = texture
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end
function ClickToMoveDisplay.GetEndWaypointTexture()
	return EndWaypointIcon
end
function ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
	WaypointsAlwaysOnTop = alwaysOnTop
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end
function ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
	return WaypointsAlwaysOnTop
end
return ClickToMoveDisplay
]]></ProtectedString><string name="Name">ClickToMoveDisplay</string></Properties></Item><Item class="ModuleScript" referent="RBX661"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local DPAD_SHEET = "rbxasset://textures/ui/DPadSheet.png"
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local UNIT_Z = Vector3.new(0, 0, 1)
local UNIT_X = Vector3.new(1, 0, 0)
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchThumbpad = setmetatable({}, BaseCharacterController)
TouchThumbpad.__index = TouchThumbpad
function TouchThumbpad.new()
	local self = setmetatable(BaseCharacterController.new(), TouchThumbpad)
	self.thumbpadFrame = nil
	self.touchChangedConn = nil
	self.touchEndedConn = nil
	self.menuOpenedConn = nil
	self.screenPos = nil
	self.isRight, self.isLeft, self.isUp, self.isDown = false, false, false, false
	self.smArrowSize = nil
	self.lgArrowSize = nil
	self.smImgOffset = nil
	self.lgImgOffset = nil
	return self
end
local doTween = function(guiObject, endSize, endPosition)
	guiObject:TweenSizeAndPosition(endSize, endPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, 0.15, true)
end
local function CreateArrowLabel(name, position, size, rectOffset, rectSize, parent)
	local image = Instance.new("ImageLabel")
	image.Name = name
	image.Image = DPAD_SHEET
	image.ImageRectOffset = rectOffset
	image.ImageRectSize = rectSize
	image.BackgroundTransparency = 1
	image.ImageColor3 = Color3.fromRGB(190, 190, 190)
	image.Size = size
	image.Position = position
	image.Parent = parent
	return image
end
function TouchThumbpad:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		if not self.thumbpadFrame then
			self:Create(uiParentFrame)
		end
		self.thumbpadFrame.Visible = true
	else
		self.thumbpadFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end
function TouchThumbpad:OnInputEnded()
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	self.thumbpadFrame.Position = self.screenPos
	self.touchObject = nil
	self.isUp, self.isDown, self.isLeft, self.isRight = false, false, false, false
	doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset))
	doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset))
	doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
	doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
end
function TouchThumbpad:Create(parentFrame)
	if self.thumbpadFrame then
		self.thumbpadFrame:Destroy()
		self.thumbpadFrame = nil
	end
	if self.touchChangedConn then
		self.touchChangedConn:Disconnect()
		self.touchChangedConn = nil
	end
	if self.touchEndedConn then
		self.touchEndedConn:Disconnect()
		self.touchEndedConn = nil
	end
	if self.menuOpenedConn then
		self.menuOpenedConn:Disconnect()
		self.menuOpenedConn = nil
	end
	local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	local thumbpadSize = isSmallScreen and 70 or 120
	self.screenPos = isSmallScreen and UDim2.new(0, thumbpadSize * 1.25, 1, -thumbpadSize - 20) or UDim2.new(0, thumbpadSize * 0.5 - 10, 1, -thumbpadSize * 1.75 - 10)
	self.thumbpadFrame = Instance.new("Frame")
	self.thumbpadFrame.Name = "ThumbpadFrame"
	self.thumbpadFrame.Visible = false
	self.thumbpadFrame.Active = true
	self.thumbpadFrame.Size = UDim2.new(0, thumbpadSize + 20, 0, thumbpadSize + 20)
	self.thumbpadFrame.Position = self.screenPos
	self.thumbpadFrame.BackgroundTransparency = 1
	local outerImage = Instance.new("ImageLabel")
	outerImage.Name = "OuterImage"
	outerImage.Image = TOUCH_CONTROL_SHEET
	outerImage.ImageRectOffset = Vector2.new(0, 0)
	outerImage.ImageRectSize = Vector2.new(220, 220)
	outerImage.BackgroundTransparency = 1
	outerImage.Size = UDim2.new(0, thumbpadSize, 0, thumbpadSize)
	outerImage.Position = UDim2.new(0, 10, 0, 10)
	outerImage.Parent = self.thumbpadFrame
	self.smArrowSize = isSmallScreen and UDim2.new(0, 32, 0, 32) or UDim2.new(0, 64, 0, 64)
	self.lgArrowSize = UDim2.new(0, self.smArrowSize.X.Offset * 2, 0, self.smArrowSize.Y.Offset * 2)
	local imgRectSize = Vector2.new(110, 110)
	self.smImgOffset = isSmallScreen and -4 or -9
	self.lgImgOffset = isSmallScreen and -28 or -55
	self.dArrow = CreateArrowLabel("DownArrow", UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset), self.smArrowSize, Vector2.new(8, 8), imgRectSize, outerImage)
	self.uArrow = CreateArrowLabel("UpArrow", UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset), self.smArrowSize, Vector2.new(8, 266), imgRectSize, outerImage)
	self.lArrow = CreateArrowLabel("LeftArrow", UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset), self.smArrowSize, Vector2.new(137, 137), imgRectSize, outerImage)
	self.rArrow = CreateArrowLabel("RightArrow", UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset), self.smArrowSize, Vector2.new(8, 137), imgRectSize, outerImage)
	local doTween = function(guiObject, endSize, endPosition)
		guiObject:TweenSizeAndPosition(endSize, endPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, 0.15, true)
	end
	local padOrigin
	local deadZone = 0.1
	self.isRight, self.isLeft, self.isUp, self.isDown = false, false, false, false
	local function doMove(pos)
		local moveDelta = pos - padOrigin
		local moveVector2 = 2 * moveDelta / thumbpadSize
		if moveVector2.Magnitude < deadZone then
			self.moveVector = ZERO_VECTOR3
		else
			moveVector2 = moveVector2.unit * ((moveVector2.Magnitude - deadZone) / (1 - deadZone))
			if moveVector2.Magnitude == 0 then
				self.moveVector = ZERO_VECTOR3
			else
				self.moveVector = Vector3.new(moveVector2.x, 0, moveVector2.y).Unit
			end
		end
		local forwardDot = self.moveVector:Dot(-UNIT_Z)
		local rightDot = self.moveVector:Dot(UNIT_X)
		if forwardDot > 0.5 then
			if not self.isUp then
				self.isUp, self.isDown = true, false
				doTween(self.uArrow, self.lgArrowSize, UDim2.new(0.5, -self.smArrowSize.X.Offset, 0, self.smImgOffset - 1.5 * self.smArrowSize.Y.Offset))
				doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset))
			end
		elseif forwardDot < -0.5 then
			if not self.isDown then
				self.isDown, self.isUp = true, false
				doTween(self.dArrow, self.lgArrowSize, UDim2.new(0.5, -self.smArrowSize.X.Offset, 1, self.lgImgOffset + 0.5 * self.smArrowSize.Y.Offset))
				doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset))
			end
		else
			self.isUp, self.isDown = false, false
			doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 1, self.lgImgOffset))
			doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5 * self.smArrowSize.X.Offset, 0, self.smImgOffset))
		end
		if rightDot > 0.5 then
			if not self.isRight then
				self.isRight, self.isLeft = true, false
				doTween(self.rArrow, self.lgArrowSize, UDim2.new(1, self.lgImgOffset + 0.5 * self.smArrowSize.X.Offset, 0.5, -self.smArrowSize.Y.Offset))
				doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
			end
		elseif rightDot < -0.5 then
			if not self.isLeft then
				self.isLeft, self.isRight = true, false
				doTween(self.lArrow, self.lgArrowSize, UDim2.new(0, self.smImgOffset - 1.5 * self.smArrowSize.X.Offset, 0.5, -self.smArrowSize.Y.Offset))
				doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
			end
		else
			self.isRight, self.isLeft = false, false
			doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
			doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5 * self.smArrowSize.Y.Offset))
		end
	end
	self.thumbpadFrame.InputBegan:connect(function(inputObject)
		if self.touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		self.thumbpadFrame.Position = UDim2.new(0, inputObject.Position.x - 0.5 * self.thumbpadFrame.AbsoluteSize.x, 0, inputObject.Position.y - 0.5 * self.thumbpadFrame.Size.Y.Offset)
		padOrigin = Vector3.new(self.thumbpadFrame.AbsolutePosition.x + 0.5 * self.thumbpadFrame.AbsoluteSize.x, self.thumbpadFrame.AbsolutePosition.y + 0.5 * self.thumbpadFrame.AbsoluteSize.y, 0)
		doMove(inputObject.Position)
		self.touchObject = inputObject
	end)
	self.touchChangedConn = UserInputService.TouchMoved:connect(function(inputObject, isProcessed)
		if inputObject == self.touchObject then
			doMove(self.touchObject.Position)
		end
	end)
	self.touchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject)
		if inputObject == self.touchObject then
			self:OnInputEnded()
		end
	end)
	self.menuOpenedConn = GuiService.MenuOpened:Connect(function()
		if self.touchObject then
			self:OnInputEnded()
		end
	end)
	self.thumbpadFrame.Parent = parentFrame
end
return TouchThumbpad
]]></ProtectedString><string name="Name">TouchThumbpad</string></Properties></Item><Item class="ModuleScript" referent="RBX666"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local VRService = game:GetService("VRService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local ContextActionService = game:GetService("ContextActionService")
local StarterGui = game:GetService("StarterGui")
local PathDisplay
local LocalPlayer = Players.LocalPlayer
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local RECALCULATE_PATH_THRESHOLD = 4
local NO_PATH_THRESHOLD = 12
local MAX_PATHING_DISTANCE = 200
local POINT_REACHED_THRESHOLD = 1
local OFFTRACK_TIME_THRESHOLD = 2
local THUMBSTICK_DEADZONE = 0.22
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local XZ_VECTOR3 = Vector3.new(1, 0, 1)
local IsFinite = function(num)
	return num == num and num ~= 1 / 0 and num ~= -1 / 0
end
local function IsFiniteVector3(vec3)
	return IsFinite(vec3.x) and IsFinite(vec3.y) and IsFinite(vec3.z)
end
local movementUpdateEvent = Instance.new("BindableEvent")
movementUpdateEvent.Name = "MovementUpdate"
movementUpdateEvent.Parent = script
coroutine.wrap(function()
	local PathDisplayModule = script.Parent:WaitForChild("PathDisplay")
	if PathDisplayModule then
		PathDisplay = require(PathDisplayModule)
	end
end)()
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local VRNavigation = setmetatable({}, BaseCharacterController)
VRNavigation.__index = VRNavigation
function VRNavigation.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new(), VRNavigation)
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	self.navigationRequestedConn = nil
	self.heartbeatConn = nil
	self.currentDestination = nil
	self.currentPath = nil
	self.currentPoints = nil
	self.currentPointIdx = 0
	self.expectedTimeToNextPoint = 0
	self.timeReachedLastPoint = tick()
	self.moving = false
	self.isJumpBound = false
	self.moveLatch = false
	self.userCFrameEnabledConn = nil
	return self
end
function VRNavigation:SetLaserPointerMode(mode)
	pcall(function()
		StarterGui:SetCore("VRLaserPointerMode", mode)
	end)
end
function VRNavigation:GetLocalHumanoid()
	local character = LocalPlayer.Character
	if not character then
		return
	end
	for _, child in pairs(character:GetChildren()) do
		if child:IsA("Humanoid") then
			return child
		end
	end
	return nil
end
function VRNavigation:HasBothHandControllers()
	return VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) and VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand)
end
function VRNavigation:HasAnyHandControllers()
	return VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) or VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand)
end
function VRNavigation:IsMobileVR()
	return UserInputService.TouchEnabled
end
function VRNavigation:HasGamepad()
	return UserInputService.GamepadEnabled
end
function VRNavigation:ShouldUseNavigationLaser()
	if self:IsMobileVR() then
		return true
	else
		if self:HasBothHandControllers() then
			return false
		end
		if not self:HasAnyHandControllers() then
			return not self:HasGamepad()
		end
		return true
	end
end
function VRNavigation:StartFollowingPath(newPath)
	currentPath = newPath
	currentPoints = currentPath:GetPointCoordinates()
	currentPointIdx = 1
	moving = true
	timeReachedLastPoint = tick()
	local humanoid = self:GetLocalHumanoid()
	if humanoid and humanoid.Torso and #currentPoints >= 1 then
		local dist = (currentPoints[1] - humanoid.Torso.Position).magnitude
		expectedTimeToNextPoint = dist / humanoid.WalkSpeed
	end
	movementUpdateEvent:Fire("targetPoint", self.currentDestination)
end
function VRNavigation:GoToPoint(point)
	currentPath = true
	currentPoints = {point}
	currentPointIdx = 1
	moving = true
	local humanoid = self:GetLocalHumanoid()
	local distance = (humanoid.Torso.Position - point).magnitude
	local estimatedTimeRemaining = distance / humanoid.WalkSpeed
	timeReachedLastPoint = tick()
	expectedTimeToNextPoint = estimatedTimeRemaining
	movementUpdateEvent:Fire("targetPoint", point)
end
function VRNavigation:StopFollowingPath()
	currentPath = nil
	currentPoints = nil
	currentPointIdx = 0
	moving = false
	self.moveVector = ZERO_VECTOR3
end
function VRNavigation:TryComputePath(startPos, destination)
	local numAttempts = 0
	local newPath
	while not newPath and numAttempts < 5 do
		newPath = PathfindingService:ComputeSmoothPathAsync(startPos, destination, MAX_PATHING_DISTANCE)
		numAttempts = numAttempts + 1
		if newPath.Status == Enum.PathStatus.ClosestNoPath or newPath.Status == Enum.PathStatus.ClosestOutOfRange then
			newPath = nil
			break
		end
		if newPath and newPath.Status == Enum.PathStatus.FailStartNotEmpty then
			startPos = startPos + (destination - startPos).unit
			newPath = nil
		end
		if newPath and newPath.Status == Enum.PathStatus.FailFinishNotEmpty then
			destination = destination + Vector3.new(0, 1, 0)
			newPath = nil
		end
	end
	return newPath
end
function VRNavigation:OnNavigationRequest(destinationCFrame, inputUserCFrame)
	local destinationPosition = destinationCFrame.p
	local lastDestination = self.currentDestination
	if not IsFiniteVector3(destinationPosition) then
		return
	end
	self.currentDestination = destinationPosition
	local humanoid = self:GetLocalHumanoid()
	if not humanoid or not humanoid.Torso then
		return
	end
	local currentPosition = humanoid.Torso.Position
	local distanceToDestination = (self.currentDestination - currentPosition).magnitude
	if distanceToDestination < NO_PATH_THRESHOLD then
		self:GoToPoint(self.currentDestination)
		return
	end
	if not lastDestination or (self.currentDestination - lastDestination).magnitude > RECALCULATE_PATH_THRESHOLD then
		local newPath = self:TryComputePath(currentPosition, self.currentDestination)
		if newPath then
			self:StartFollowingPath(newPath)
			if PathDisplay then
				PathDisplay.setCurrentPoints(self.currentPoints)
				PathDisplay.renderPath()
			end
		else
			self:StopFollowingPath()
			if PathDisplay then
				PathDisplay.clearRenderedPath()
			end
		end
	elseif moving then
		self.currentPoints[#currentPoints] = self.currentDestination
	else
		self:GoToPoint(self.currentDestination)
	end
end
function VRNavigation:OnJumpAction(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin then
		self.isJumping = true
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Sink
	end
end
function VRNavigation:BindJumpAction(active)
	if active then
		if not self.isJumpBound then
			self.isJumpBound = true
			if FFlagPlayerScriptsBindAtPriority2 then
				ContextActionService:BindActionAtPriority("VRJumpAction", function()
					return self:OnJumpAction()
				end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
			else
				ContextActionService:BindAction("VRJumpAction", function()
					self:OnJumpAction()
				end, false, Enum.KeyCode.ButtonA)
			end
		end
	elseif self.isJumpBound then
		self.isJumpBound = false
		ContextActionService:UnbindAction("VRJumpAction")
	end
end
function VRNavigation:ControlCharacterGamepad(actionName, inputState, inputObject)
	if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then
		return
	end
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector = ZERO_VECTOR3
		return
	end
	if inputState ~= Enum.UserInputState.End then
		self:StopFollowingPath()
		if PathDisplay then
			PathDisplay.clearRenderedPath()
		end
		if self:ShouldUseNavigationLaser() then
			self:BindJumpAction(true)
			self:SetLaserPointerMode("Hidden")
		end
		if inputObject.Position.magnitude > THUMBSTICK_DEADZONE then
			self.moveVector = Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
			if self.moveVector.magnitude > 0 then
				self.moveVector = self.moveVector.unit * math.min(1, inputObject.Position.magnitude)
			end
			self.moveLatch = true
		end
	else
		self.moveVector = ZERO_VECTOR3
		if self:ShouldUseNavigationLaser() then
			self:BindJumpAction(false)
			self:SetLaserPointerMode("Navigation")
		end
		if self.moveLatch then
			self.moveLatch = false
			movementUpdateEvent:Fire("offtrack")
		end
	end
	if FFlagPlayerScriptsBindAtPriority2 then
		return Enum.ContextActionResult.Sink
	end
end
function VRNavigation:OnHeartbeat(dt)
	local newMoveVector = self.moveVector
	local humanoid = self:GetLocalHumanoid()
	if not humanoid or not humanoid.Torso then
		return
	end
	if self.moving and self.currentPoints then
		local currentPosition = humanoid.Torso.Position
		local goalPosition = currentPoints[1]
		local vectorToGoal = (goalPosition - currentPosition) * XZ_VECTOR3
		local moveDist = vectorToGoal.magnitude
		local moveDir = vectorToGoal / moveDist
		if moveDist < POINT_REACHED_THRESHOLD then
			local estimatedTimeRemaining = 0
			local prevPoint = currentPoints[1]
			for i, point in pairs(currentPoints) do
				if i ~= 1 then
					local dist = (point - prevPoint).magnitude
					prevPoint = point
					estimatedTimeRemaining = estimatedTimeRemaining + dist / humanoid.WalkSpeed
				end
			end
			table.remove(currentPoints, 1)
			currentPointIdx = currentPointIdx + 1
			if #currentPoints == 0 then
				self:StopFollowingPath()
				if PathDisplay then
					PathDisplay.clearRenderedPath()
				end
				return
			else
				if PathDisplay then
					PathDisplay.setCurrentPoints(currentPoints)
					PathDisplay.renderPath()
				end
				local newGoal = currentPoints[1]
				local distanceToGoal = (newGoal - currentPosition).magnitude
				expectedTimeToNextPoint = distanceToGoal / humanoid.WalkSpeed
				timeReachedLastPoint = tick()
			end
		else
			local ignoreTable = {
				game.Players.LocalPlayer.Character,
				workspace.CurrentCamera
			}
			local obstructRay = Ray.new(currentPosition - Vector3.new(0, 1, 0), moveDir * 3)
			local obstructPart, obstructPoint, obstructNormal = workspace:FindPartOnRayWithIgnoreList(obstructRay, ignoreTable)
			if obstructPart then
				local heightOffset = Vector3.new(0, 100, 0)
				local jumpCheckRay = Ray.new(obstructPoint + moveDir * 0.5 + heightOffset, -heightOffset)
				local jumpCheckPart, jumpCheckPoint, jumpCheckNormal = workspace:FindPartOnRayWithIgnoreList(jumpCheckRay, ignoreTable)
				local heightDifference = jumpCheckPoint.Y - currentPosition.Y
				if heightDifference < 6 and heightDifference > -2 then
					humanoid.Jump = true
				end
			end
			local timeSinceLastPoint = tick() - timeReachedLastPoint
			if timeSinceLastPoint > expectedTimeToNextPoint + OFFTRACK_TIME_THRESHOLD then
				self:StopFollowingPath()
				if PathDisplay then
					PathDisplay.clearRenderedPath()
				end
				movementUpdateEvent:Fire("offtrack")
			end
			newMoveVector = self.moveVector:Lerp(moveDir, dt * 10)
		end
	end
	if IsFiniteVector3(newMoveVector) then
		self.moveVector = newMoveVector
	end
end
function VRNavigation:OnUserCFrameEnabled()
	if self:ShouldUseNavigationLaser() then
		self:BindJumpAction(false)
		self:SetLaserPointerMode("Navigation")
	else
		self:BindJumpAction(true)
		self:SetLaserPointerMode("Hidden")
	end
end
function VRNavigation:Enable(enable)
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		self.navigationRequestedConn = VRService.NavigationRequested:Connect(function(destinationCFrame, inputUserCFrame)
			self:OnNavigationRequest(destinationCFrame, inputUserCFrame)
		end)
		self.heartbeatConn = RunService.Heartbeat:Connect(function(dt)
			self:OnHeartbeat(dt)
		end)
		if FFlagPlayerScriptsBindAtPriority2 then
			ContextActionService:BindAction("MoveThumbstick", function(actionName, inputState, inputObject)
				return self:ControlCharacterGamepad(actionName, inputState, inputObject)
			end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
		else
			ContextActionService:BindAction("MoveThumbstick", function(actionName, inputState, inputObject)
				self:ControlCharacterGamepad(actionName, inputState, inputObject)
			end, false, Enum.KeyCode.Thumbstick1)
		end
		ContextActionService:BindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)
		self.userCFrameEnabledConn = VRService.UserCFrameEnabled:Connect(function()
			self:OnUserCFrameEnabled()
		end)
		self:OnUserCFrameEnabled()
		VRService:SetTouchpadMode(Enum.VRTouchpad.Left, Enum.VRTouchpadMode.VirtualThumbstick)
		VRService:SetTouchpadMode(Enum.VRTouchpad.Right, Enum.VRTouchpadMode.ABXY)
		self.enabled = true
	else
		self:StopFollowingPath()
		ContextActionService:UnbindAction("MoveThumbstick")
		ContextActionService:UnbindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)
		self:BindJumpAction(false)
		self:SetLaserPointerMode("Disabled")
		if self.navigationRequestedConn then
			self.navigationRequestedConn:Disconnect()
			self.navigationRequestedConn = nil
		end
		if self.heartbeatConn then
			self.heartbeatConn:Disconnect()
			self.heartbeatConn = nil
		end
		if self.userCFrameEnabledConn then
			self.userCFrameEnabledConn:Disconnect()
			self.userCFrameEnabledConn = nil
		end
		self.enabled = false
	end
end
return VRNavigation
]]></ProtectedString><string name="Name">VRNavigation</string></Properties></Item><Item class="ModuleScript" referent="RBX671"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local NONE = Enum.UserInputType.None
local thumbstickDeadzone = 0.2
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local Gamepad = setmetatable({}, BaseCharacterController)
Gamepad.__index = Gamepad
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
function Gamepad.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new(), Gamepad)
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.activeGamepad = NONE
	self.gamepadConnectedConn = nil
	self.gamepadDisconnectedConn = nil
	return self
end
function Gamepad:Enable(enable)
	if not UserInputService.GamepadEnabled then
		return false
	end
	if enable == self.enabled then
		return true
	end
	self.forwardValue = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		self.activeGamepad = self:GetHighestPriorityGamepad()
		if self.activeGamepad ~= NONE then
			self:BindContextActions()
			self:ConnectGamepadConnectionListeners()
		else
			return false
		end
	else
		self:UnbindContextActions()
		self:DisconnectGamepadConnectionListeners()
		self.activeGamepad = NONE
	end
	self.enabled = enable
	return true
end
function Gamepad:GetHighestPriorityGamepad()
	local connectedGamepads = UserInputService:GetConnectedGamepads()
	local bestGamepad = NONE
	for _, gamepad in pairs(connectedGamepads) do
		if gamepad.Value < bestGamepad.Value then
			bestGamepad = gamepad
		end
	end
	return bestGamepad
end
function Gamepad:BindContextActions()
	if self.activeGamepad == NONE then
		return false
	end
	local function updateMovement(inputState)
		if inputState == Enum.UserInputState.Cancel then
			self.moveVector = ZERO_VECTOR3
		else
			self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		end
	end
	local function handleMoveForward(actionName, inputState, inputObject)
		self.forwardValue = inputState == Enum.UserInputState.Begin and -1 or 0
		updateMovement(inputState)
	end
	local function handleMoveBackward(actionName, inputState, inputObject)
		self.backwardValue = inputState == Enum.UserInputState.Begin and 1 or 0
		updateMovement(inputState)
	end
	local function handleMoveLeft(actionName, inputState, inputObject)
		self.leftValue = inputState == Enum.UserInputState.Begin and -1 or 0
		updateMovement(inputState)
	end
	local function handleMoveRight(actionName, inputState, inputObject)
		self.rightValue = inputState == Enum.UserInputState.Begin and 1 or 0
		updateMovement(inputState)
	end
	local function handleJumpAction(actionName, inputState, inputObject)
		self.isJumping = inputState == Enum.UserInputState.Begin
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	local function handleThumbstickInput(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.Cancel then
			self.moveVector = ZERO_VECTOR3
			return FFlagPlayerScriptsBindAtPriority2 and Enum.ContextActionResult.Sink or nil
		end
		if self.activeGamepad ~= inputObject.UserInputType then
			return FFlagPlayerScriptsBindAtPriority2 and Enum.ContextActionResult.Pass or nil
		end
		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then
			return
		end
		if inputObject.Position.magnitude > thumbstickDeadzone then
			self.moveVector = Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
		else
			self.moveVector = ZERO_VECTOR3
		end
		if FFlagPlayerScriptsBindAtPriority2 then
			return Enum.ContextActionResult.Sink
		end
	end
	ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	if FFlagPlayerScriptsBindAtPriority2 then
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
		ContextActionService:BindActionAtPriority("moveThumbstick", handleThumbstickInput, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
	else
		ContextActionService:BindAction("jumpAction", handleJumpAction, false, Enum.KeyCode.ButtonA)
		ContextActionService:BindAction("moveThumbstick", handleThumbstickInput, false, Enum.KeyCode.Thumbstick1)
	end
	return true
end
function Gamepad:UnbindContextActions()
	if self.activeGamepad ~= NONE then
		ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
	ContextActionService:UnbindAction("moveThumbstick")
	ContextActionService:UnbindAction("jumpAction")
end
function Gamepad:OnNewGamepadConnected()
	local bestGamepad = self:GetHighestPriorityGamepad()
	if bestGamepad == self.activeGamepad then
		return
	end
	if bestGamepad == NONE then
		warn("Gamepad:OnNewGamepadConnected found no connected gamepads")
		self:UnbindContextActions()
		return
	end
	if self.activeGamepad ~= NONE then
		self:UnbindContextActions()
	end
	self.activeGamepad = bestGamepad
	self:BindContextActions()
end
function Gamepad:OnCurrentGamepadDisconnected()
	if self.activeGamepad ~= NONE then
		ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
	local bestGamepad = self:GetHighestPriorityGamepad()
	if self.activeGamepad ~= NONE and bestGamepad == self.activeGamepad then
		warn("Gamepad:OnCurrentGamepadDisconnected found the supposedly disconnected gamepad in connectedGamepads.")
		self:UnbindContextActions()
		self.activeGamepad = NONE
		return
	end
	if bestGamepad == NONE then
		self:UnbindContextActions()
		self.activeGamepad = NONE
	else
		self.activeGamepad = bestGamepad
		ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
end
function Gamepad:ConnectGamepadConnectionListeners()
	self.gamepadConnectedConn = UserInputService.GamepadConnected:Connect(function(gamepadEnum)
		self:OnNewGamepadConnected()
	end)
	self.gamepadDisconnectedConn = UserInputService.GamepadDisconnected:Connect(function(gamepadEnum)
		if self.activeGamepad == gamepadEnum then
			self:OnCurrentGamepadDisconnected()
		end
	end)
end
function Gamepad:DisconnectGamepadConnectionListeners()
	if self.gamepadConnectedConn then
		self.gamepadConnectedConn:Disconnect()
		self.gamepadConnectedConn = nil
	end
	if self.gamepadDisconnectedConn then
		self.gamepadDisconnectedConn:Disconnect()
		self.gamepadDisconnectedConn = nil
	end
end
return Gamepad
]]></ProtectedString><string name="Name">Gamepad</string></Properties></Item><Item class="ModuleScript" referent="RBX676"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local UserInputService = game:GetService("UserInputService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local DebrisService = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local CollectionService = game:GetService("CollectionService")
local ShowPath = true
local PlayFailureAnimation = true
local UseDirectPath = false
local movementKeys = {
	[Enum.KeyCode.W] = true,
	[Enum.KeyCode.A] = true,
	[Enum.KeyCode.S] = true,
	[Enum.KeyCode.D] = true,
	[Enum.KeyCode.Up] = true,
	[Enum.KeyCode.Down] = true
}
local FFlagUserNavigationClickToMoveSkipPassedWaypointsSuccess, FFlagUserNavigationClickToMoveSkipPassedWaypointsResult = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNavigationClickToMoveSkipPassedWaypoints")
end)
local FFlagUserNavigationClickToMoveSkipPassedWaypoints = FFlagUserNavigationClickToMoveSkipPassedWaypointsSuccess and FFlagUserNavigationClickToMoveSkipPassedWaypointsResult
local FFlagUserNewClickToMoveDisplaySuccess, FFlagUserNewClickToMoveDisplayValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNewClickToMoveDisplay")
end)
local FFlagUserNewClickToMoveDisplay = FFlagUserNewClickToMoveDisplaySuccess and FFlagUserNewClickToMoveDisplayValue
local FFlagUserFixClickToMoveWithACMSuccess, FFlagUserFixClickToMoveWithACMResult = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserFixClickToMoveWithACM")
end)
local FFlagUserFixClickToMoveWithACM = FFlagUserFixClickToMoveWithACMSuccess and FFlagUserFixClickToMoveWithACMResult
local Player = Players.LocalPlayer
local ClickToMoveDisplay
if FFlagUserNewClickToMoveDisplay then
	ClickToMoveDisplay = require(script.Parent:WaitForChild("ClickToMoveDisplay"))
end
local CurrentSeatPart, DrivingTo
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local ZERO_VECTOR2 = Vector2.new(0, 0)
local Utility = {}
do
	local function FindCharacterAncestor(part)
		if part then
			local humanoid = part:FindFirstChildOfClass("Humanoid")
			if humanoid then
				return part, humanoid
			else
				return FindCharacterAncestor(part.Parent)
			end
		end
	end
	Utility.FindCharacterAncestor = FindCharacterAncestor
	local function Raycast(ray, ignoreNonCollidable, ignoreList)
		ignoreList = ignoreList or {}
		local hitPart, hitPos, hitNorm, hitMat = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
		if hitPart then
			if ignoreNonCollidable and hitPart.CanCollide == false then
				local _, humanoid
				if FFlagUserFixClickToMoveWithACM then
					_, humanoid = FindCharacterAncestor(hitPart)
				end
				if humanoid == nil then
					table.insert(ignoreList, hitPart)
					return Raycast(ray, ignoreNonCollidable, ignoreList)
				end
			end
			return hitPart, hitPos, hitNorm, hitMat
		end
		return nil, nil
	end
	Utility.Raycast = Raycast
end
local humanoidCache = {}
local function findPlayerHumanoid(player)
	local character = player and player.Character
	if character then
		local resultHumanoid = humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			humanoidCache[player] = nil
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoidCache[player] = humanoid
			end
			return humanoid
		end
	end
end
local CurrentIgnoreList, CurrentIgnoreTag, TaggedInstanceAddedConnection, TaggedInstanceRemovedConnection
local function GetCharacter()
	return Player and Player.Character
end
local function UpdateIgnoreTag(newIgnoreTag)
	if newIgnoreTag == CurrentIgnoreTag then
		return
	end
	if TaggedInstanceAddedConnection then
		TaggedInstanceAddedConnection:Disconnect()
		TaggedInstanceAddedConnection = nil
	end
	if TaggedInstanceRemovedConnection then
		TaggedInstanceRemovedConnection:Disconnect()
		TaggedInstanceRemovedConnection = nil
	end
	CurrentIgnoreTag = newIgnoreTag
	CurrentIgnoreList = {
		GetCharacter()
	}
	if CurrentIgnoreTag ~= nil then
		local ignoreParts = CollectionService:GetTagged(CurrentIgnoreTag)
		for _, ignorePart in ipairs(ignoreParts) do
			table.insert(CurrentIgnoreList, ignorePart)
		end
		TaggedInstanceAddedConnection = CollectionService:GetInstanceAddedSignal(CurrentIgnoreTag):Connect(function(ignorePart)
			table.insert(CurrentIgnoreList, ignorePart)
		end)
		TaggedInstanceRemovedConnection = CollectionService:GetInstanceRemovedSignal(CurrentIgnoreTag):Connect(function(ignorePart)
			for i = 1, #CurrentIgnoreList do
				if CurrentIgnoreList[i] == ignorePart then
					CurrentIgnoreList[i] = CurrentIgnoreList[#CurrentIgnoreList]
					table.remove(CurrentIgnoreList)
					break
				end
			end
		end)
	end
end
local function getIgnoreList()
	if CurrentIgnoreList then
		return CurrentIgnoreList
	end
	CurrentIgnoreList = {}
	table.insert(CurrentIgnoreList, GetCharacter())
	return CurrentIgnoreList
end
local popupAdornee
local function getPopupAdorneePart()
	if popupAdornee and not popupAdornee.Parent then
		popupAdornee = nil
	end
	if not popupAdornee then
		popupAdornee = Instance.new("Part")
		popupAdornee.Name = "ClickToMovePopupAdornee"
		popupAdornee.Transparency = 1
		popupAdornee.CanCollide = false
		popupAdornee.Anchored = true
		popupAdornee.Size = Vector3.new(2, 2, 2)
		popupAdornee.CFrame = CFrame.new()
		popupAdornee.Parent = Workspace.CurrentCamera
	end
	return popupAdornee
end
local activePopups = {}
local function createNewPopup(popupType)
	local newModel = Instance.new("ImageHandleAdornment")
	newModel.AlwaysOnTop = false
	newModel.Transparency = 1
	newModel.Size = ZERO_VECTOR2
	newModel.SizeRelativeOffset = ZERO_VECTOR3
	newModel.Image = "rbxasset://textures/ui/move.png"
	newModel.ZIndex = 20
	local radius = 0
	if popupType == "DestinationPopup" then
		newModel.Color3 = Color3.fromRGB(0, 175, 255)
		radius = 1.25
	elseif popupType == "DirectWalkPopup" then
		newModel.Color3 = Color3.fromRGB(0, 175, 255)
		radius = 1.25
	elseif popupType == "FailurePopup" then
		newModel.Color3 = Color3.fromRGB(255, 100, 100)
		radius = 1.25
	elseif popupType == "PatherPopup" then
		newModel.Color3 = Color3.fromRGB(255, 255, 255)
		radius = 1
		newModel.ZIndex = 10
	end
	newModel.Size = Vector2.new(5, 0.1) * radius
	local dataStructure = {}
	dataStructure.Model = newModel
	activePopups[#activePopups + 1] = newModel
	function dataStructure:TweenIn()
		local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out)
		local tween1 = TweenService:Create(newModel, tweenInfo, {
			Size = Vector2.new(2, 2) * radius
		})
		tween1:Play()
		TweenService:Create(newModel, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, 0.1), {
			Transparency = 0,
			SizeRelativeOffset = Vector3.new(0, radius * 1.5, 0)
		}):Play()
		return tween1
	end
	function dataStructure:TweenOut()
		local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
		local tween1 = TweenService:Create(newModel, tweenInfo, {Size = ZERO_VECTOR2})
		tween1:Play()
		coroutine.wrap(function()
			tween1.Completed:Wait()
			for i = 1, #activePopups do
				if activePopups[i] == newModel then
					table.remove(activePopups, i)
					break
				end
			end
		end)()
		return tween1
	end
	function dataStructure:Place(position)
		if not self.Model.Parent then
			local popupAdorneePart = getPopupAdorneePart()
			self.Model.Parent = popupAdorneePart
			self.Model.Adornee = popupAdorneePart
			local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
			local _, hitPoint = Workspace:FindPartOnRayWithIgnoreList(ray, {
				Workspace.CurrentCamera,
				Player.Character
			})
			self.Model.CFrame = CFrame.new(hitPoint) + Vector3.new(0, -radius, 0)
		end
	end
	return dataStructure
end
local function createPopupPath(points, numCircles)
	local popups = {}
	local stopTraversing = false
	local function killPopup(i)
		for iter, v in pairs(popups) do
			if iter <= i then
				do
					local tween = v:TweenOut()
					coroutine.wrap(function()
						tween.Completed:Wait()
						v.Model:Destroy()
					end)()
					popups[iter] = nil
				end
			end
		end
	end
	local function stopFunction()
		stopTraversing = true
		killPopup(#points)
	end
	coroutine.wrap(function()
		for i = 1, #points do
			if stopTraversing then
				break
			end
			local includeWaypoint = i % numCircles == 0 and i < #points and (points[#points].Position - points[i].Position).magnitude > 4
			if includeWaypoint then
				local popup = createNewPopup("PatherPopup")
				popups[i] = popup
				popup:Place(points[i].Position)
				popup:TweenIn()
				wait(0.2)
			end
		end
	end)()
	return stopFunction, killPopup
end
local function Pather(character, endPoint, surfaceNormal)
	local this = {}
	this.Cancelled = false
	this.Started = false
	this.Finished = Instance.new("BindableEvent")
	this.PathFailed = Instance.new("BindableEvent")
	this.PathComputing = false
	this.PathComputed = false
	this.OriginalPoint = endPoint
	this.TargetPoint = endPoint
	this.TargetSurfaceNormal = surfaceNormal
	this.DiedConn = nil
	this.SeatedConn = nil
	this.MoveToConn = nil
	this.BlockedConn = nil
	this.CurrentPoint = 0
	function this:Cleanup()
		if this.stopTraverseFunc then
			this.stopTraverseFunc()
			this.stopTraverseFunc = nil
		end
		if this.MoveToConn then
			this.MoveToConn:Disconnect()
			this.MoveToConn = nil
		end
		if this.BlockedConn then
			this.BlockedConn:Disconnect()
			this.BlockedConn = nil
		end
		if this.DiedConn then
			this.DiedConn:Disconnect()
			this.DiedConn = nil
		end
		if this.SeatedConn then
			this.SeatedConn:Disconnect()
			this.SeatedConn = nil
		end
		this.humanoid = nil
	end
	function this:Cancel()
		this.Cancelled = true
		this:Cleanup()
	end
	function this:IsActive()
		return this.humanoid and this.Started and not this.Cancelled
	end
	function this:OnPathInterrupted()
		this.Cancelled = true
		this:OnPointReached(false)
	end
	function this:ComputePath()
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if torso then
			if this.PathComputed or this.PathComputing then
				return
			end
			this.PathComputing = true
			pcall(function()
				this.pathResult = PathfindingService:FindPathAsync(torso.CFrame.p, this.TargetPoint)
			end)
			this.pointList = this.pathResult and this.pathResult:GetWaypoints()
			if this.pathResult then
				this.BlockedConn = this.pathResult.Blocked:Connect(function(blockedIdx)
					this:OnPathBlocked(blockedIdx)
				end)
			end
			this.PathComputing = false
			this.PathComputed = this.pathResult and this.pathResult.Status == Enum.PathStatus.Success or false
		end
		return true
	end
	function this:IsValidPath()
		if not this.pathResult then
			this:ComputePath()
		end
		return this.pathResult.Status == Enum.PathStatus.Success
	end
	this.Recomputing = false
	function this:OnPathBlocked(blockedWaypointIdx)
		local pathBlocked = blockedWaypointIdx >= this.CurrentPoint
		if not pathBlocked or this.Recomputing then
			return
		end
		this.Recomputing = true
		if this.stopTraverseFunc then
			this.stopTraverseFunc()
			this.stopTraverseFunc = nil
		end
		this.pathResult:ComputeAsync(this.humanoid.Torso.CFrame.p, this.TargetPoint)
		this.pointList = this.pathResult:GetWaypoints()
		this.PathComputed = this.pathResult and this.pathResult.Status == Enum.PathStatus.Success or false
		if ShowPath then
			if FFlagUserNewClickToMoveDisplay then
				this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList)
			else
				this.stopTraverseFunc, this.setPointFunc = createPopupPath(this.pointList, 4, true)
			end
		end
		if this.PathComputed then
			this.humanoid = findPlayerHumanoid(Player)
			this.CurrentPoint = 1
			this:OnPointReached(true)
		else
			this.PathFailed:Fire()
			this:Cleanup()
		end
		this.Recomputing = false
	end
	function this:OnPointReached(reached)
		if reached and not this.Cancelled then
			local nextWaypointIdx = this.CurrentPoint + 1
			if nextWaypointIdx > #this.pointList then
				if this.stopTraverseFunc then
					this.stopTraverseFunc()
				end
				this.Finished:Fire()
				this:Cleanup()
			else
				local currentWaypoint = this.pointList[this.CurrentPoint]
				local nextWaypoint = this.pointList[nextWaypointIdx]
				local currentState = this.humanoid:GetState()
				local isInAir = currentState == Enum.HumanoidStateType.FallingDown or currentState == Enum.HumanoidStateType.Freefall or currentState == Enum.HumanoidStateType.Jumping
				if isInAir then
					local shouldWaitForGround = nextWaypoint.Action == Enum.PathWaypointAction.Jump
					shouldWaitForGround = shouldWaitForGround
					if shouldWaitForGround then
						this.humanoid.FreeFalling:Wait()
						wait(0.1)
					end
				end
				if FFlagUserNavigationClickToMoveSkipPassedWaypoints then
					local nextWaypointAlreadyReached
					local planeNormal = currentWaypoint.Position - nextWaypoint.Position
					if planeNormal.Magnitude > 1.0E-6 then
						planeNormal = planeNormal.Unit
						local planeDistance = planeNormal:Dot(nextWaypoint.Position)
						local humanoidPosition = this.humanoid.RootPart.Position - Vector3.new(0, 0.5 * this.humanoid.RootPart.Size.y + this.humanoid.HipHeight, 0)
						local dist = planeNormal:Dot(humanoidPosition) - planeDistance
						nextWaypointAlreadyReached = dist < 1
					else
						nextWaypointAlreadyReached = true
					end
					if this.setPointFunc then
						this.setPointFunc(nextWaypointIdx)
					end
					this.CurrentPoint = nextWaypointIdx
					if nextWaypointAlreadyReached then
						this:OnPointReached(true)
					else
						if nextWaypoint.Action == Enum.PathWaypointAction.Jump then
							this.humanoid.Jump = true
						end
						this.humanoid:MoveTo(nextWaypoint.Position)
					end
				else
					if this.setPointFunc then
						this.setPointFunc(nextWaypointIdx)
					end
					if nextWaypoint.Action == Enum.PathWaypointAction.Jump then
						this.humanoid.Jump = true
					end
					this.humanoid:MoveTo(nextWaypoint.Position)
					this.CurrentPoint = nextWaypointIdx
				end
			end
		else
			this.PathFailed:Fire()
			this:Cleanup()
		end
	end
	function this:Start(overrideShowPath)
		if CurrentSeatPart then
			return
		end
		this.humanoid = findPlayerHumanoid(Player)
		if not this.humanoid then
			this.PathFailed:Fire()
			return
		end
		if this.Started then
			return
		end
		this.Started = true
		if FFlagUserNewClickToMoveDisplay then
			ClickToMoveDisplay.CancelFailureAnimation()
		end
		if ShowPath then
			if FFlagUserNewClickToMoveDisplay then
				if overrideShowPath == nil or overrideShowPath then
					this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList, this.OriginalPoint)
				end
			else
				this.stopTraverseFunc, this.setPointFunc = createPopupPath(this.pointList, 4)
			end
		end
		if #this.pointList > 0 then
			this.SeatedConn = this.humanoid.Seated:Connect(function(reached)
				this:OnPathInterrupted()
			end)
			this.DiedConn = this.humanoid.Died:Connect(function(reached)
				this:OnPathInterrupted()
			end)
			this.MoveToConn = this.humanoid.MoveToFinished:Connect(function(reached)
				this:OnPointReached(reached)
			end)
			this.CurrentPoint = 1
			this:OnPointReached(true)
		else
			this.PathFailed:Fire()
			if this.stopTraverseFunc then
				this.stopTraverseFunc()
			end
		end
	end
	if FFlagUserNewClickToMoveDisplay then
		local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal * 1.5
		local ray = Ray.new(offsetPoint, Vector3.new(0, -1, 0) * 50)
		local newHitPart, newHitPos = Workspace:FindPartOnRayWithIgnoreList(ray, getIgnoreList())
		if newHitPart then
			this.TargetPoint = newHitPos
		end
		this:ComputePath()
	else
		this:ComputePath()
		if not this.PathComputed then
			local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal * 1.5
			local ray = Ray.new(offsetPoint, Vector3.new(0, -1, 0) * 50)
			local newHitPart, newHitPos = Workspace:FindPartOnRayWithIgnoreList(ray, getIgnoreList())
			if newHitPart then
				this.TargetPoint = newHitPos
			end
			this:ComputePath()
		end
	end
	return this
end
local function CheckAlive()
	local humanoid = findPlayerHumanoid(Player)
	return humanoid ~= nil and humanoid.Health > 0
end
local GetEquippedTool = function(character)
	if character ~= nil then
		for _, child in pairs(character:GetChildren()) do
			if child:IsA("Tool") then
				return child
			end
		end
	end
end
local ExistingPather, ExistingIndicator, PathCompleteListener, PathFailedListener
local function CleanupPath()
	DrivingTo = nil
	if ExistingPather then
		ExistingPather:Cancel()
	end
	if PathCompleteListener then
		PathCompleteListener:Disconnect()
		PathCompleteListener = nil
	end
	if PathFailedListener then
		PathFailedListener:Disconnect()
		PathFailedListener = nil
	end
	if ExistingIndicator then
		if FFlagUserNewClickToMoveDisplay then
			ExistingIndicator:Destroy()
		else
			do
				local obj = ExistingIndicator
				local tween = obj:TweenOut()
				local tweenCompleteEvent
				tweenCompleteEvent = tween.Completed:connect(function()
					tweenCompleteEvent:Disconnect()
					obj.Model:Destroy()
				end)
				ExistingIndicator = nil
			end
		end
	end
end
local getExtentsSize = function(Parts)
	local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge
	local minX, minY, minZ = math.huge, math.huge, math.huge
	for i = 1, #Parts do
		local position = Parts[i].Position
		maxX = math.max(maxX, position.X)
		maxY = math.max(maxY, position.Y)
		maxZ = math.max(maxZ, position.Z)
		minX = math.min(minX, position.X)
		minY = math.min(minY, position.Y)
		minZ = math.min(minZ, position.Z)
	end
	return Region3.new(Vector3.new(minX, minY, minZ), Vector3.new(maxX, maxY, maxZ))
end
local inExtents = function(Extents, Position)
	if Position.X < Extents.CFrame.p.X - Extents.Size.X / 2 or Position.X > Extents.CFrame.p.X + Extents.Size.X / 2 then
		return false
	end
	if Position.Z < Extents.CFrame.p.Z - Extents.Size.Z / 2 or Position.Z > Extents.CFrame.p.Z + Extents.Size.Z / 2 then
		return false
	end
	return true
end
local function showQuickPopupAsync(position, popupType)
	local popup = createNewPopup(popupType)
	popup:Place(position)
	local tweenIn = popup:TweenIn()
	tweenIn.Completed:Wait()
	local tweenOut = popup:TweenOut()
	tweenOut.Completed:Wait()
	popup.Model:Destroy()
end
local function HandleDirectMoveTo(hitPt, myHumanoid)
	if myHumanoid then
		if myHumanoid.Sit then
			myHumanoid.Jump = true
		end
		myHumanoid:MoveTo(hitPt)
	end
	local endWaypoint = ClickToMoveDisplay.CreateEndWaypoint(hitPt)
	ExistingIndicator = endWaypoint
	coroutine.wrap(function()
		myHumanoid.MoveToFinished:wait()
		endWaypoint:Destroy()
	end)
end
local OnTap
local function HandleDriveTo(tapPositions, hitPt, character)
	local destinationPopup
	if FFlagUserNewClickToMoveDisplay then
		destinationPopup = ClickToMoveDisplay.CreateEndWaypoint(hitPt)
	else
		destinationPopup = createNewPopup("DestinationPopup")
		ExistingIndicator = destinationPopup
		destinationPopup:Place(hitPt)
		destinationPopup:TweenIn()
	end
	DrivingTo = hitPt
	local ConnectedParts = CurrentSeatPart:GetConnectedParts(true)
	local heartBeatConnection
	heartBeatConnection = RunService.Heartbeat:Connect(function()
		if CurrentSeatPart and ExistingIndicator == destinationPopup then
			local ExtentsSize = getExtentsSize(ConnectedParts)
			if inExtents(ExtentsSize, hitPt) then
				if FFlagUserNewClickToMoveDisplay then
					destinationPopup:Destroy()
				else
					do
						local popup = destinationPopup
						coroutine.wrap(function()
							local tweenOut = popup:TweenOut()
							tweenOut.Completed:Wait()
							popup.Model:Destroy()
						end)()
					end
				end
				DrivingTo = nil
				heartBeatConnection:Disconnect()
			end
		else
			if CurrentSeatPart == nil and destinationPopup == ExistingIndicator then
				DrivingTo = nil
				OnTap(tapPositions, hitPt)
			end
			if FFlagUserNewClickToMoveDisplay then
				destinationPopup:Destroy()
			else
				do
					local popup = destinationPopup
					coroutine.wrap(function()
						local tweenOut = popup:TweenOut()
						tweenOut.Completed:Wait()
						popup.Model:Destroy()
					end)()
				end
			end
			heartBeatConnection:Disconnect()
		end
	end)
end
local function HandleMoveTo(thisPather, hitPt, hitChar, character, overrideShowPath)
	thisPather:Start(overrideShowPath)
	CleanupPath()
	local destinationPopup, failurePopup
	if not FFlagUserNewClickToMoveDisplay then
		destinationPopup = createNewPopup("DestinationPopup")
		destinationPopup:Place(hitPt, Vector3.new(0, hitPt.y, 0))
		failurePopup = createNewPopup("FailurePopup")
		destinationPopup:TweenIn()
		ExistingIndicator = destinationPopup
	end
	ExistingPather = thisPather
	PathCompleteListener = thisPather.Finished.Event:Connect(function()
		if destinationPopup then
			if ExistingIndicator == destinationPopup then
				ExistingIndicator = nil
			end
			do
				local tween = destinationPopup:TweenOut()
				local tweenCompleteEvent
				tweenCompleteEvent = tween.Completed:Connect(function()
					tweenCompleteEvent:Disconnect()
					destinationPopup.Model:Destroy()
					destinationPopup = nil
				end)
			end
		end
		if hitChar then
			local currentWeapon = GetEquippedTool(character)
			if currentWeapon then
				currentWeapon:Activate()
			end
		end
	end)
	PathFailedListener = thisPather.PathFailed.Event:Connect(function()
		CleanupPath()
		if FFlagUserNewClickToMoveDisplay then
			if overrideShowPath == nil or overrideShowPath then
				local shouldPlayFailureAnim = PlayFailureAnimation and (not ExistingPather or not ExistingPather:IsActive())
				if shouldPlayFailureAnim then
					ClickToMoveDisplay.PlayFailureAnimation()
				end
				ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
			end
		elseif failurePopup then
			failurePopup:Place(hitPt, Vector3.new(0, hitPt.y, 0))
			local failTweenIn = failurePopup:TweenIn()
			failTweenIn.Completed:Wait()
			local failTweenOut = failurePopup:TweenOut()
			failTweenOut.Completed:Wait()
			failurePopup.Model:Destroy()
			failurePopup = nil
		end
	end)
end
local function ShowPathFailedFeedback(hitPt)
	if ExistingPather and ExistingPather:IsActive() then
		ExistingPather:Cancel()
	end
	if PlayFailureAnimation then
		ClickToMoveDisplay.PlayFailureAnimation()
	end
	ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
end
function OnTap(tapPositions, goToPoint, wasTouchTap)
	local camera = Workspace.CurrentCamera
	local character = Player.Character
	if not CheckAlive() then
		return
	end
	if #tapPositions == 1 or goToPoint then
		if camera then
			local unitRay = camera:ScreenPointToRay(tapPositions[1].x, tapPositions[1].y)
			local ray = Ray.new(unitRay.Origin, unitRay.Direction * 1000)
			local myHumanoid = findPlayerHumanoid(Player)
			local hitPart, hitPt, hitNormal = Utility.Raycast(ray, true, getIgnoreList())
			local hitChar, hitHumanoid = Utility.FindCharacterAncestor(hitPart)
			if FFlagUserFixClickToMoveWithACM and wasTouchTap and hitHumanoid and StarterGui:GetCore("AvatarContextMenuEnabled") then
				local clickedPlayer = Players:GetPlayerFromCharacter(hitHumanoid.Parent)
				if clickedPlayer then
					CleanupPath()
					return
				end
			end
			if goToPoint then
				hitPt = goToPoint
				hitChar = nil
			end
			if UseDirectPath and hitPt and character and not CurrentSeatPart then
				HandleDirectMoveTo(hitPt, myHumanoid)
			elseif hitPt and character and not CurrentSeatPart then
				local thisPather = Pather(character, hitPt, hitNormal)
				if thisPather:IsValidPath() then
					HandleMoveTo(thisPather, hitPt, hitChar, character)
				elseif hitPt then
					if FFlagUserNewClickToMoveDisplay then
						ShowPathFailedFeedback(hitPt)
					else
						coroutine.wrap(showQuickPopupAsync)(hitPt, "FailurePopup")
					end
				end
			elseif hitPt and character and CurrentSeatPart then
				HandleDriveTo(tapPositions, hitPt, character)
			end
		end
	elseif #tapPositions >= 2 and camera then
		local currentWeapon = GetEquippedTool(character)
		if currentWeapon then
			currentWeapon:Activate()
		end
	end
end
local DisconnectEvent = function(event)
	if event then
		event:Disconnect()
	end
end
local KeyboardController = require(script.Parent:WaitForChild("Keyboard"))
local ClickToMove = setmetatable({}, KeyboardController)
ClickToMove.__index = ClickToMove
function ClickToMove.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(KeyboardController.new(CONTROL_ACTION_PRIORITY), ClickToMove)
	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	self.mouse1Down = tick()
	self.mouse1DownPos = Vector2.new()
	self.mouse2DownTime = tick()
	self.mouse2DownPos = Vector2.new()
	self.mouse2UpTime = tick()
	self.tapConn = nil
	self.inputBeganConn = nil
	self.inputChangedConn = nil
	self.inputEndedConn = nil
	self.humanoidDiedConn = nil
	self.characterChildAddedConn = nil
	self.onCharacterAddedConn = nil
	self.characterChildRemovedConn = nil
	self.renderSteppedConn = nil
	self.humanoidSeatedConn = nil
	self.running = false
	self.wasdEnabled = false
	return self
end
function ClickToMove:DisconnectEvents()
	DisconnectEvent(self.tapConn)
	DisconnectEvent(self.inputBeganConn)
	DisconnectEvent(self.inputChangedConn)
	DisconnectEvent(self.inputEndedConn)
	DisconnectEvent(self.humanoidDiedConn)
	DisconnectEvent(self.characterChildAddedConn)
	DisconnectEvent(self.onCharacterAddedConn)
	DisconnectEvent(self.renderSteppedConn)
	DisconnectEvent(self.characterChildRemovedConn)
	DisconnectEvent(self.humanoidSeatedConn)
	RunService:UnbindFromRenderStep("ClickToMoveRenderUpdate")
end
function ClickToMove:OnTouchBegan(input, processed)
	if self.fingerTouches[input] == nil and not processed then
		self.numUnsunkTouches = self.numUnsunkTouches + 1
	end
	self.fingerTouches[input] = processed
end
function ClickToMove:OnTouchChanged(input, processed)
	if self.fingerTouches[input] == nil then
		self.fingerTouches[input] = processed
		if not processed then
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
end
function ClickToMove:OnTouchEnded(input, processed)
	if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
		self.numUnsunkTouches = self.numUnsunkTouches - 1
	end
	self.fingerTouches[input] = nil
end
function ClickToMove:OnCharacterAdded(character)
	self:DisconnectEvents()
	self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchBegan(input, processed)
		end
		if processed == false and input.UserInputType == Enum.UserInputType.Keyboard and movementKeys[input.KeyCode] then
			CleanupPath()
		end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			self.mouse1DownTime = tick()
			self.mouse1DownPos = input.Position
		end
		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.mouse2DownTime = tick()
			self.mouse2DownPos = input.Position
		end
	end)
	self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchChanged(input, processed)
		end
	end)
	self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchEnded(input, processed)
		end
		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.mouse2UpTime = tick()
			local currPos = input.Position
			if self.mouse2UpTime - self.mouse2DownTime < 0.25 and (currPos - self.mouse2DownPos).magnitude < 5 and self.moveVector.Magnitude <= 0 then
				local positions = {currPos}
				OnTap(positions)
			end
		end
	end)
	self.tapConn = UserInputService.TouchTap:Connect(function(touchPositions, processed)
		if not processed then
			OnTap(touchPositions, nil, true)
		end
	end)
	local computeThrottle = function(dist)
		if dist > 0.2 then
			return 0.5 + dist ^ 2 / 2
		else
			return 0
		end
	end
	local kP = 1
	local kD = 0.5
	local function getThrottleAndSteer(object, point)
		local oCF = object.CFrame
		local relativePosition = oCF:pointToObjectSpace(point)
		local relativeZDirection = -relativePosition.z
		local relativeDistance = relativePosition.magnitude
		local throttle = computeThrottle(math.min(1, relativeDistance / 50)) * math.sign(relativeZDirection)
		local steerAngle = -math.atan2(-relativePosition.x, -relativePosition.z)
		local steer = steerAngle / (math.pi / 4)
		local pdSteer = kP * steer + kD * steer
		return throttle, pdSteer
	end
	local function Update()
		if CurrentSeatPart then
			if DrivingTo then
				local throttle, steer = getThrottleAndSteer(CurrentSeatPart, DrivingTo)
				CurrentSeatPart.ThrottleFloat = throttle
				CurrentSeatPart.SteerFloat = steer
			else
				CurrentSeatPart.ThrottleFloat = 0
				CurrentSeatPart.SteerFloat = 0
			end
		end
		local cameraPos = Workspace.CurrentCamera.CFrame.p
		for i = 1, #activePopups do
			local popup = activePopups[i]
			popup.CFrame = CFrame.new(popup.CFrame.p, cameraPos)
		end
	end
	RunService:BindToRenderStep("ClickToMoveRenderUpdate", Enum.RenderPriority.Camera.Value - 1, Update)
	local function onSeated(active, currentSeatPart)
		if active then
			if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
				CurrentSeatPart = currentSeatPart
			end
		else
			CurrentSeatPart = nil
		end
	end
	local function OnCharacterChildAdded(child)
		if UserInputService.TouchEnabled and child:IsA("Tool") then
			child.ManualActivationOnly = true
		end
		if child:IsA("Humanoid") then
			DisconnectEvent(self.humanoidDiedConn)
			self.humanoidDiedConn = child.Died:Connect(function()
				if ExistingIndicator then
					DebrisService:AddItem(ExistingIndicator.Model, 1)
				end
			end)
			if FFlagUserNewClickToMoveDisplay then
			end
		end
	end
	self.characterChildAddedConn = character.ChildAdded:Connect(function(child)
		OnCharacterChildAdded(child)
	end)
	self.characterChildRemovedConn = character.ChildRemoved:Connect(function(child)
		if UserInputService.TouchEnabled and child:IsA("Tool") then
			child.ManualActivationOnly = false
		end
	end)
	for _, child in pairs(character:GetChildren()) do
		OnCharacterChildAdded(child)
	end
end
function ClickToMove:Start()
	self:Enable(true)
end
function ClickToMove:Stop()
	self:Enable(false)
end
function ClickToMove:Enable(enable, enableWASD, touchJumpController)
	if enable then
		if not self.running then
			if Player.Character then
				self:OnCharacterAdded(Player.Character)
			end
			self.onCharacterAddedConn = Player.CharacterAdded:Connect(function(char)
				self:OnCharacterAdded(char)
			end)
			self.running = true
		end
		self.touchJumpController = touchJumpController
		if self.touchJumpController then
			self.touchJumpController:Enable(self.jumpEnabled)
		end
	else
		if self.running then
			self:DisconnectEvents()
			CleanupPath()
			if UserInputService.TouchEnabled then
				local character = Player.Character
				if character then
					for _, child in pairs(character:GetChildren()) do
						if child:IsA("Tool") then
							child.ManualActivationOnly = false
						end
					end
				end
			end
			DrivingTo = nil
			self.running = false
		end
		if self.touchJumpController and not self.jumpEnabled then
			self.touchJumpController:Enable(true)
		end
		self.touchJumpController = nil
	end
	if UserInputService.KeyboardEnabled and enable ~= self.enabled then
		self.forwardValue = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.moveVector = ZERO_VECTOR3
		if enable then
			self:BindContextActions()
			self:ConnectFocusEventListeners()
		else
			self:UnbindContextActions()
			self:DisconnectFocusEventListeners()
		end
	end
	self.wasdEnabled = enable and enableWASD or false
	self.enabled = enable
end
function ClickToMove:UpdateMovement(inputState)
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector = ZERO_VECTOR3
	elseif self.wasdEnabled then
		self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		if FFlagUserNewClickToMoveDisplay and 0 < self.moveVector.magnitude then
			CleanupPath()
			ClickToMoveDisplay.CancelFailureAnimation()
		end
	end
end
function ClickToMove:SetShowPath(value)
	ShowPath = value
end
function ClickToMove:GetShowPath()
	return ShowPath
end
function ClickToMove:SetWaypointTexture(texture)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetWaypointTexture(texture)
	end
end
function ClickToMove:GetWaypointTexture()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetWaypointTexture()
	end
	return ""
end
function ClickToMove:SetWaypointRadius(radius)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetWaypointRadius(radius)
	end
end
function ClickToMove:GetWaypointRadius()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetWaypointRadius()
	end
	return 0
end
function ClickToMove:SetEndWaypointTexture(texture)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetEndWaypointTexture(texture)
	end
end
function ClickToMove:GetEndWaypointTexture()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetEndWaypointTexture()
	end
	return ""
end
function ClickToMove:SetWaypointsAlwaysOnTop(alwaysOnTop)
	if FFlagUserNewClickToMoveDisplay then
		ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
	end
end
function ClickToMove:GetWaypointsAlwaysOnTop()
	if FFlagUserNewClickToMoveDisplay then
		return ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
	end
	return false
end
function ClickToMove:SetFailureAnimationEnabled(enabled)
	PlayFailureAnimation = enabled
end
function ClickToMove:GetFailureAnimationEnabled()
	return PlayFailureAnimation
end
function ClickToMove:SetIgnoredPartsTag(tag)
	UpdateIgnoreTag(tag)
end
function ClickToMove:GetIgnoredPartsTag()
	return CurrentIgnoreTag
end
function ClickToMove:SetUseDirectPath(directPath)
	UseDirectPath = directPath
end
function ClickToMove:GetUseDirectPath()
	return UseDirectPath
end
function ClickToMove:SetUserJumpEnabled(jumpEnabled)
	self.jumpEnabled = jumpEnabled
	if self.touchJumpController then
		self.touchJumpController:Enable(jumpEnabled)
	end
end
function ClickToMove:GetUserJumpEnabled()
	return self.jumpEnabled
end
function ClickToMove:MoveTo(position, showPath)
	local character = Player.Character
	if character == nil then
		return false
	end
	local thisPather = Pather(character, position, Vector3.new(0, 1, 0))
	if thisPather:IsValidPath() then
		HandleMoveTo(thisPather, position, nil, character, showPath)
		return true
	end
	return false
end
return ClickToMove
]]></ProtectedString><string name="Name">ClickToMoveController</string></Properties></Item><Item class="ModuleScript" referent="RBX681"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchThumbstick = setmetatable({}, BaseCharacterController)
TouchThumbstick.__index = TouchThumbstick
function TouchThumbstick.new()
	local self = setmetatable(BaseCharacterController.new(), TouchThumbstick)
	self.isFollowStick = false
	self.thumbstickFrame = nil
	self.moveTouchObject = nil
	self.onTouchMovedConn = nil
	self.onTouchEndedConn = nil
	self.screenPos = nil
	self.stickImage = nil
	self.thumbstickSize = nil
	return self
end
function TouchThumbstick:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		if not self.thumbstickFrame then
			self:Create(uiParentFrame)
		end
		self.thumbstickFrame.Visible = true
	else
		self.thumbstickFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end
function TouchThumbstick:OnInputEnded()
	self.thumbstickFrame.Position = self.screenPos
	self.stickImage.Position = UDim2.new(0, self.thumbstickFrame.Size.X.Offset / 2 - self.thumbstickSize / 4, 0, self.thumbstickFrame.Size.Y.Offset / 2 - self.thumbstickSize / 4)
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	self.thumbstickFrame.Position = self.screenPos
	self.moveTouchObject = nil
end
function TouchThumbstick:Create(parentFrame)
	if self.thumbstickFrame then
		self.thumbstickFrame:Destroy()
		self.thumbstickFrame = nil
		if self.onTouchMovedConn then
			self.onTouchMovedConn:Disconnect()
			self.onTouchMovedConn = nil
		end
		if self.onTouchEndedConn then
			self.onTouchEndedConn:Disconnect()
			self.onTouchEndedConn = nil
		end
	end
	local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	self.thumbstickSize = isSmallScreen and 70 or 120
	self.screenPos = isSmallScreen and UDim2.new(0, self.thumbstickSize / 2 - 10, 1, -self.thumbstickSize - 20) or UDim2.new(0, self.thumbstickSize / 2, 1, -self.thumbstickSize * 1.75)
	self.thumbstickFrame = Instance.new("Frame")
	self.thumbstickFrame.Name = "ThumbstickFrame"
	self.thumbstickFrame.Active = true
	self.thumbstickFrame.Visible = false
	self.thumbstickFrame.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
	self.thumbstickFrame.Position = self.screenPos
	self.thumbstickFrame.BackgroundTransparency = 1
	local outerImage = Instance.new("ImageLabel")
	outerImage.Name = "OuterImage"
	outerImage.Image = TOUCH_CONTROL_SHEET
	outerImage.ImageRectOffset = Vector2.new()
	outerImage.ImageRectSize = Vector2.new(220, 220)
	outerImage.BackgroundTransparency = 1
	outerImage.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
	outerImage.Position = UDim2.new(0, 0, 0, 0)
	outerImage.Parent = self.thumbstickFrame
	self.stickImage = Instance.new("ImageLabel")
	self.stickImage.Name = "StickImage"
	self.stickImage.Image = TOUCH_CONTROL_SHEET
	self.stickImage.ImageRectOffset = Vector2.new(220, 0)
	self.stickImage.ImageRectSize = Vector2.new(111, 111)
	self.stickImage.BackgroundTransparency = 1
	self.stickImage.Size = UDim2.new(0, self.thumbstickSize / 2, 0, self.thumbstickSize / 2)
	self.stickImage.Position = UDim2.new(0, self.thumbstickSize / 2 - self.thumbstickSize / 4, 0, self.thumbstickSize / 2 - self.thumbstickSize / 4)
	self.stickImage.ZIndex = 2
	self.stickImage.Parent = self.thumbstickFrame
	local centerPosition
	local deadZone = 0.05
	local function DoMove(direction)
		local currentMoveVector = direction / (self.thumbstickSize / 2)
		local inputAxisMagnitude = currentMoveVector.magnitude
		if inputAxisMagnitude < deadZone then
			currentMoveVector = Vector3.new()
		else
			currentMoveVector = currentMoveVector.unit * ((inputAxisMagnitude - deadZone) / (1 - deadZone))
			currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
		end
		self.moveVector = currentMoveVector
	end
	local function MoveStick(pos)
		local relativePosition = Vector2.new(pos.x - centerPosition.x, pos.y - centerPosition.y)
		local length = relativePosition.magnitude
		local maxLength = self.thumbstickFrame.AbsoluteSize.x / 2
		if self.isFollowStick and length > maxLength then
			local offset = relativePosition.unit * maxLength
			self.thumbstickFrame.Position = UDim2.new(0, pos.x - self.thumbstickFrame.AbsoluteSize.x / 2 - offset.x, 0, pos.y - self.thumbstickFrame.AbsoluteSize.y / 2 - offset.y)
		else
			length = math.min(length, maxLength)
			relativePosition = relativePosition.unit * length
		end
		self.stickImage.Position = UDim2.new(0, relativePosition.x + self.stickImage.AbsoluteSize.x / 2, 0, relativePosition.y + self.stickImage.AbsoluteSize.y / 2)
	end
	self.thumbstickFrame.InputBegan:Connect(function(inputObject)
		if self.moveTouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		self.moveTouchObject = inputObject
		self.thumbstickFrame.Position = UDim2.new(0, inputObject.Position.x - self.thumbstickFrame.Size.X.Offset / 2, 0, inputObject.Position.y - self.thumbstickFrame.Size.Y.Offset / 2)
		centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x / 2, self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y / 2)
		local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
	end)
	self.onTouchMovedConn = UserInputService.TouchMoved:Connect(function(inputObject, isProcessed)
		if inputObject == self.moveTouchObject then
			centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x / 2, self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y / 2)
			local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
			DoMove(direction)
			MoveStick(inputObject.Position)
		end
	end)
	self.onTouchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject, isProcessed)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	GuiService.MenuOpened:Connect(function()
		if self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	self.thumbstickFrame.Parent = parentFrame
end
return TouchThumbstick
]]></ProtectedString><string name="Name">TouchThumbstick</string></Properties></Item><Item class="ModuleScript" referent="RBX686"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local DPAD_SHEET = "rbxasset://textures/ui/DPadSheet.png"
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local COMPASS_DIR = {
	Vector3.new(1, 0, 0),
	Vector3.new(1, 0, 1).unit,
	Vector3.new(0, 0, 1),
	Vector3.new(-1, 0, 1).unit,
	Vector3.new(-1, 0, 0),
	Vector3.new(-1, 0, -1).unit,
	Vector3.new(0, 0, -1),
	Vector3.new(1, 0, -1).unit
}
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchDPad = setmetatable({}, BaseCharacterController)
TouchDPad.__index = TouchDPad
function TouchDPad.new()
	local self = setmetatable(BaseCharacterController.new(), TouchDPad)
	self.DPadFrame = nil
	self.touchObject = nil
	self.flBtn = nil
	self.frBtn = nil
	return self
end
local function CreateArrowLabel(name, position, size, rectOffset, rectSize, parent)
	local image = Instance.new("ImageLabel")
	image.Name = name
	image.Image = DPAD_SHEET
	image.ImageRectOffset = rectOffset
	image.ImageRectSize = rectSize
	image.BackgroundTransparency = 1
	image.Size = size
	image.Position = position
	image.Parent = parent
	return image
end
function TouchDPad:GetCenterPosition()
	return Vector2.new(self.DPadFrame.AbsolutePosition.x + self.DPadFrame.AbsoluteSize.x * 0.5, self.DPadFrame.AbsolutePosition.y + self.DPadFrame.AbsoluteSize.y * 0.5)
end
function TouchDPad:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	if enable then
		if not self.DPadFrame then
			self:Create(uiParentFrame)
		end
		self.DPadFrame.Visible = true
	else
		self.DPadFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end
function TouchDPad:GetIsJumping()
	local wasJumping = self.isJumping
	self.isJumping = false
	return wasJumping
end
function TouchDPad:OnInputEnded()
	self.touchObject = nil
	if self.flBtn then
		self.flBtn.Visible = false
	end
	if self.frBtn then
		self.frBtn.Visible = false
	end
	self.moveVector = ZERO_VECTOR3
end
function TouchDPad:Create(parentFrame)
	if self.DPadFrame then
		self.DPadFrame:Destroy()
		self.DPadFrame = nil
	end
	local position = UDim2.new(0, 10, 1, -230)
	self.DPadFrame = Instance.new("Frame")
	self.DPadFrame.Name = "DPadFrame"
	self.DPadFrame.Active = true
	self.DPadFrame.Visible = false
	self.DPadFrame.Size = UDim2.new(0, 192, 0, 192)
	self.DPadFrame.Position = position
	self.DPadFrame.BackgroundTransparency = 1
	local smArrowSize = UDim2.new(0, 23, 0, 23)
	local lgArrowSize = UDim2.new(0, 64, 0, 64)
	local smImgOffset = Vector2.new(46, 46)
	local lgImgOffset = Vector2.new(128, 128)
	local bBtn = CreateArrowLabel("BackButton", UDim2.new(0.5, -32, 1, -64), lgArrowSize, Vector2.new(0, 0), lgImgOffset, self.DPadFrame)
	local fBtn = CreateArrowLabel("ForwardButton", UDim2.new(0.5, -32, 0, 0), lgArrowSize, Vector2.new(0, 258), lgImgOffset, self.DPadFrame)
	local lBtn = CreateArrowLabel("LeftButton", UDim2.new(0, 0, 0.5, -32), lgArrowSize, Vector2.new(129, 129), lgImgOffset, self.DPadFrame)
	local rBtn = CreateArrowLabel("RightButton", UDim2.new(1, -64, 0.5, -32), lgArrowSize, Vector2.new(0, 129), lgImgOffset, self.DPadFrame)
	local jumpBtn = CreateArrowLabel("JumpButton", UDim2.new(0.5, -32, 0.5, -32), lgArrowSize, Vector2.new(129, 0), lgImgOffset, self.DPadFrame)
	self.flBtn = CreateArrowLabel("ForwardLeftButton", UDim2.new(0, 35, 0, 35), smArrowSize, Vector2.new(129, 258), smImgOffset, self.DPadFrame)
	self.frBtn = CreateArrowLabel("ForwardRightButton", UDim2.new(1, -55, 0, 35), smArrowSize, Vector2.new(176, 258), smImgOffset, self.DPadFrame)
	self.flBtn.Visible = false
	self.frBtn.Visible = false
	jumpBtn.InputBegan:Connect(function(inputObject)
		self.isJumping = true
	end)
	local function normalizeDirection(inputPosition)
		local jumpRadius = jumpBtn.AbsoluteSize.x * 0.5
		local centerPosition = self:GetCenterPosition()
		local direction = Vector2.new(inputPosition.x - centerPosition.x, inputPosition.y - centerPosition.y)
		if jumpRadius < direction.magnitude then
			local angle = math.atan2(direction.y, direction.x)
			local octant = math.floor(8 * angle / (2 * math.pi) + 8.5) % 8 + 1
			self.moveVector = COMPASS_DIR[octant]
		end
		if not self.flBtn.Visible and self.moveVector == COMPASS_DIR[7] then
			self.flBtn.Visible = true
			self.frBtn.Visible = true
		end
	end
	self.DPadFrame.InputBegan:Connect(function(inputObject)
		if self.touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		self.touchObject = inputObject
		normalizeDirection(self.touchObject.Position)
	end)
	self.DPadFrame.InputChanged:Connect(function(inputObject)
		if inputObject == self.touchObject then
			normalizeDirection(self.touchObject.Position)
			self.isJumping = false
		end
	end)
	self.DPadFrame.InputEnded:connect(function(inputObject)
		if inputObject == self.touchObject then
			self:OnInputEnded()
		end
	end)
	GuiService.MenuOpened:Connect(function()
		if self.touchObject then
			self:OnInputEnded()
		end
	end)
	self.DPadFrame.Parent = parentFrame
end
return TouchDPad
]]></ProtectedString><string name="Name">TouchDPad</string></Properties></Item><Item class="ModuleScript" referent="RBX691"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local TOUCH_CONTROLS_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
local DYNAMIC_THUMBSTICK_ACTION_NAME = "DynamicThumbstickAction"
local DYNAMIC_THUMBSTICK_ACTION_PRIORITY = Enum.ContextActionPriority.High.Value
local MIDDLE_TRANSPARENCIES = {
	0.10999999999999999,
	0.30000000000000004,
	0.4,
	0.5,
	0.6,
	0.7,
	0.75
}
local NUM_MIDDLE_IMAGES = #MIDDLE_TRANSPARENCIES
local FADE_IN_OUT_BACKGROUND = true
local FADE_IN_OUT_MAX_ALPHA = 0.35
local FADE_IN_OUT_HALF_DURATION_DEFAULT = 0.3
local FADE_IN_OUT_BALANCE_DEFAULT = 0.5
local ThumbstickFadeTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local thumbstickUseCASFlagSuccess, thumbstickUseCASFlagValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserDynamicThumbstickUseContextActionSevice")
end)
local FFlagDynamicThumbstickUseContextActionSevice = thumbstickUseCASFlagSuccess and thumbstickUseCASFlagValue
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local DynamicThumbstick = setmetatable({}, BaseCharacterController)
DynamicThumbstick.__index = DynamicThumbstick
function DynamicThumbstick.new()
	local self = setmetatable(BaseCharacterController.new(), DynamicThumbstick)
	self.humanoid = nil
	self.tools = {}
	self.toolEquipped = nil
	self.revertAutoJumpEnabledToFalse = false
	self.moveTouchObject = nil
	self.moveTouchFirstChanged = false
	self.moveTouchStartPosition = nil
	self.startImage = nil
	self.endImage = nil
	self.middleImages = {}
	self.startImageFadeTween = nil
	self.endImageFadeTween = nil
	self.middleImageFadeTweens = {}
	self.isFirstTouch = true
	self.isFollowStick = false
	self.thumbstickFrame = nil
	if not FFlagDynamicThumbstickUseContextActionSevice then
		self.onTouchMovedConn = nil
		self.onTouchEndedConn = nil
		self.onTouchActivateConn = nil
	end
	self.onRenderSteppedConn = nil
	self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
	self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
	self.hasFadedBackgroundInPortrait = false
	self.hasFadedBackgroundInLandscape = false
	self.tweenInAlphaStart = nil
	self.tweenOutAlphaStart = nil
	self.shouldRevertAutoJumpOnDisable = false
	return self
end
function DynamicThumbstick:GetIsJumping()
	local wasJumping = self.isJumping
	self.isJumping = false
	return wasJumping
end
function DynamicThumbstick:EnableAutoJump(enable)
	local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if enable then
			self.shouldRevertAutoJumpOnDisable = humanoid.AutoJumpEnabled == false and Players.LocalPlayer.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice
			humanoid.AutoJumpEnabled = true
		elseif self.shouldRevertAutoJumpOnDisable then
			humanoid.AutoJumpEnabled = false
		end
	end
end
function DynamicThumbstick:Enable(enable, uiParentFrame)
	if enable == nil then
		return false
	end
	enable = enable and true or false
	if self.enabled == enable then
		return true
	end
	if enable then
		if not self.thumbstickFrame then
			self:Create(uiParentFrame)
		end
		if FFlagDynamicThumbstickUseContextActionSevice then
			self:BindContextActions()
		end
		if Players.LocalPlayer.Character then
			self:OnCharacterAdded(Players.LocalPlayer.Character)
		else
			Players.LocalPlayer.CharacterAdded:Connect(function(char)
				self:OnCharacterAdded(char)
			end)
		end
	else
		if FFlagDynamicThumbstickUseContextActionSevice then
			ContextActionService:UnbindAction(DYNAMIC_THUMBSTICK_ACTION_NAME)
		end
		self:OnInputEnded()
	end
	self.enabled = enable
	self.thumbstickFrame.Visible = enable
end
function DynamicThumbstick:OnCharacterAdded(char)
	for _, child in ipairs(char:GetChildren()) do
		if child:IsA("Tool") then
			self.toolEquipped = child
		end
	end
	char.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			self.toolEquipped = child
		elseif child:IsA("Humanoid") then
			self:EnableAutoJump(true)
		end
	end)
	char.ChildRemoved:Connect(function(child)
		if child == self.toolEquipped then
			self.toolEquipped = nil
		end
	end)
	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	if self.humanoid then
		self:EnableAutoJump(true)
	end
end
function DynamicThumbstick:OnInputEnded()
	self.moveTouchObject = nil
	self.moveVector = ZERO_VECTOR3
	self:FadeThumbstick(false)
	if not FFlagDynamicThumbstickUseContextActionSevice then
		self.thumbstickFrame.Active = true
	end
end
function DynamicThumbstick:FadeThumbstick(visible)
	if not visible and self.moveTouchObject then
		return
	end
	if self.isFirstTouch then
		return
	end
	if self.startImageFadeTween then
		self.startImageFadeTween:Cancel()
	end
	if self.endImageFadeTween then
		self.endImageFadeTween:Cancel()
	end
	for i = 1, #self.middleImages do
		if self.middleImageFadeTweens[i] then
			self.middleImageFadeTweens[i]:Cancel()
		end
	end
	if visible then
		self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, {ImageTransparency = 0})
		self.startImageFadeTween:Play()
		self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, {ImageTransparency = 0.2})
		self.endImageFadeTween:Play()
		for i = 1, #self.middleImages do
			self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, {
				ImageTransparency = MIDDLE_TRANSPARENCIES[i]
			})
			self.middleImageFadeTweens[i]:Play()
		end
	else
		self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, {ImageTransparency = 1})
		self.startImageFadeTween:Play()
		self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, {ImageTransparency = 1})
		self.endImageFadeTween:Play()
		for i = 1, #self.middleImages do
			self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, {ImageTransparency = 1})
			self.middleImageFadeTweens[i]:Play()
		end
	end
end
function DynamicThumbstick:FadeThumbstickFrame(fadeDuration, fadeRatio)
	self.fadeInAndOutHalfDuration = fadeDuration * 0.5
	self.fadeInAndOutBalance = fadeRatio
	self.tweenInAlphaStart = tick()
end
function DynamicThumbstick:InputInFrame(inputObject)
	local frameCornerTopLeft = self.thumbstickFrame.AbsolutePosition
	local frameCornerBottomRight = frameCornerTopLeft + self.thumbstickFrame.AbsoluteSize
	local inputPosition = inputObject.Position
	if inputPosition.X >= frameCornerTopLeft.X and inputPosition.Y >= frameCornerTopLeft.Y and inputPosition.X <= frameCornerBottomRight.X and inputPosition.Y <= frameCornerBottomRight.Y then
		return true
	end
	return false
end
function DynamicThumbstick:DoFadeInBackground()
	local playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
	local hasFadedBackgroundInOrientation = false
	if playerGui then
		if playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight then
			hasFadedBackgroundInOrientation = self.hasFadedBackgroundInLandscape
			self.hasFadedBackgroundInLandscape = true
		elseif playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait then
			hasFadedBackgroundInOrientation = self.hasFadedBackgroundInPortrait
			self.hasFadedBackgroundInPortrait = true
		end
	end
	if not hasFadedBackgroundInOrientation then
		self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
		self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
		self.tweenInAlphaStart = tick()
	end
end
function DynamicThumbstick:DoMove(direction)
	local currentMoveVector = direction
	local inputAxisMagnitude = currentMoveVector.magnitude
	if inputAxisMagnitude < self.radiusOfDeadZone then
		currentMoveVector = Vector3.new()
	else
		currentMoveVector = currentMoveVector.unit * (1 - math.max(0, (self.radiusOfMaxSpeed - currentMoveVector.magnitude) / self.radiusOfMaxSpeed))
		currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
	end
	self.moveVector = currentMoveVector
end
function DynamicThumbstick:LayoutMiddleImages(startPos, endPos)
	local startDist = self.thumbstickSize / 2 + self.middleSize
	local vector = endPos - startPos
	local distAvailable = vector.magnitude - self.thumbstickRingSize / 2 - self.middleSize
	local direction = vector.unit
	local distNeeded = self.middleSpacing * NUM_MIDDLE_IMAGES
	local spacing = self.middleSpacing
	if distAvailable > distNeeded then
		spacing = distAvailable / NUM_MIDDLE_IMAGES
	end
	for i = 1, NUM_MIDDLE_IMAGES do
		local image = self.middleImages[i]
		local distWithout = startDist + spacing * (i - 2)
		local currentDist = startDist + spacing * (i - 1)
		if distAvailable > distWithout then
			local pos = endPos - direction * currentDist
			local exposedFraction = math.clamp(1 - (currentDist - distAvailable) / spacing, 0, 1)
			image.Visible = true
			image.Position = UDim2.new(0, pos.X, 0, pos.Y)
			image.Size = UDim2.new(0, self.middleSize * exposedFraction, 0, self.middleSize * exposedFraction)
		else
			image.Visible = false
		end
	end
end
function DynamicThumbstick:MoveStick(pos)
	local vector2StartPosition = Vector2.new(self.moveTouchStartPosition.X, self.moveTouchStartPosition.Y)
	local startPos = vector2StartPosition - self.thumbstickFrame.AbsolutePosition
	local endPos = Vector2.new(pos.X, pos.Y) - self.thumbstickFrame.AbsolutePosition
	self.endImage.Position = UDim2.new(0, endPos.X, 0, endPos.Y)
	self:LayoutMiddleImages(startPos, endPos)
end
function DynamicThumbstick:BindContextActions()
	local function inputBegan(inputObject)
		if self.moveTouchObject then
			return Enum.ContextActionResult.Pass
		end
		if not self:InputInFrame(inputObject) then
			return Enum.ContextActionResult.Pass
		end
		if self.isFirstTouch then
			self.isFirstTouch = false
			local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0)
			TweenService:Create(self.startImage, tweenInfo, {
				Size = UDim2.new(0, 0, 0, 0)
			}):Play()
			TweenService:Create(self.endImage, tweenInfo, {
				Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize),
				ImageColor3 = Color3.new(0, 0, 0)
			}):Play()
		end
		self.moveTouchObject = inputObject
		self.moveTouchStartPosition = inputObject.Position
		self.moveTouchFirstChanged = true
		if FADE_IN_OUT_BACKGROUND then
			self:DoFadeInBackground()
		end
		return Enum.ContextActionResult.Pass
	end
	local function inputChanged(inputObject)
		if inputObject == self.moveTouchObject then
			if self.moveTouchFirstChanged then
				self.moveTouchFirstChanged = false
				local startPosVec2 = Vector2.new(inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X, inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y)
				self.startImage.Visible = true
				self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
				self.endImage.Visible = true
				self.endImage.Position = self.startImage.Position
				self:FadeThumbstick(true)
				self:MoveStick(inputObject.Position)
			end
			local direction = Vector2.new(inputObject.Position.x - self.moveTouchStartPosition.x, inputObject.Position.y - self.moveTouchStartPosition.y)
			if 0 < math.abs(direction.x) or 0 < math.abs(direction.y) then
				self:DoMove(direction)
				self:MoveStick(inputObject.Position)
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	local function inputEnded(inputObject)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
			if self.moveTouchLockedIn then
				return Enum.ContextActionResult.Sink
			end
		end
		return Enum.ContextActionResult.Pass
	end
	local function handleInput(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.Begin then
			return inputBegan(inputObject)
		elseif inputState == Enum.UserInputState.Change then
			return inputChanged(inputObject)
		elseif inputState == Enum.UserInputState.End then
			return inputEnded(inputObject)
		elseif inputState == Enum.UserInputState.Cancel then
			self:OnInputEnded()
		end
	end
	ContextActionService:BindActionAtPriority(DYNAMIC_THUMBSTICK_ACTION_NAME, handleInput, false, DYNAMIC_THUMBSTICK_ACTION_PRIORITY, Enum.UserInputType.Touch)
end
function DynamicThumbstick:Create(parentFrame)
	if self.thumbstickFrame then
		self.thumbstickFrame:Destroy()
		self.thumbstickFrame = nil
		if not FFlagDynamicThumbstickUseContextActionSevice then
			if self.onTouchMovedConn then
				self.onTouchMovedConn:Disconnect()
				self.onTouchMovedConn = nil
			end
			if self.onTouchEndedConn then
				self.onTouchEndedCon:Disconnect()
				self.onTouchEndedCon = nil
			end
			if self.onTouchActivateConn then
				self.onTouchActivateConn:Disconnect()
				self.onTouchActivateConn = nil
			end
		end
		if self.onRenderSteppedConn then
			self.onRenderSteppedConn:Disconnect()
			self.onRenderSteppedConn = nil
		end
	end
	self.thumbstickSize = 45
	self.thumbstickRingSize = 20
	self.middleSize = 10
	self.middleSpacing = self.middleSize + 4
	self.radiusOfDeadZone = 2
	self.radiusOfMaxSpeed = 20
	local screenSize = parentFrame.AbsoluteSize
	local isBigScreen = math.min(screenSize.x, screenSize.y) > 500
	if isBigScreen then
		self.thumbstickSize = self.thumbstickSize * 2
		self.thumbstickRingSize = self.thumbstickRingSize * 2
		self.middleSize = self.middleSize * 2
		self.middleSpacing = self.middleSpacing * 2
		self.radiusOfDeadZone = self.radiusOfDeadZone * 2
		self.radiusOfMaxSpeed = self.radiusOfMaxSpeed * 2
	end
	local function layoutThumbstickFrame(portraitMode)
		if portraitMode then
			self.thumbstickFrame.Size = UDim2.new(1, 0, 0.4, 0)
			self.thumbstickFrame.Position = UDim2.new(0, 0, 0.6, 0)
		else
			self.thumbstickFrame.Size = UDim2.new(0.4, 0, 0.6666666666666666, 0)
			self.thumbstickFrame.Position = UDim2.new(0, 0, 0.3333333333333333, 0)
		end
	end
	self.thumbstickFrame = Instance.new("TextButton")
	self.thumbstickFrame.Text = ""
	self.thumbstickFrame.Name = "DynamicThumbstickFrame"
	self.thumbstickFrame.Visible = false
	self.thumbstickFrame.BackgroundTransparency = 1
	self.thumbstickFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	if FFlagDynamicThumbstickUseContextActionSevice then
		self.thumbstickFrame.Active = false
	end
	layoutThumbstickFrame(false)
	self.startImage = Instance.new("ImageLabel")
	self.startImage.Name = "ThumbstickStart"
	self.startImage.Visible = true
	self.startImage.BackgroundTransparency = 1
	self.startImage.Image = TOUCH_CONTROLS_SHEET
	self.startImage.ImageRectOffset = Vector2.new(1, 1)
	self.startImage.ImageRectSize = Vector2.new(144, 144)
	self.startImage.ImageColor3 = Color3.new(0, 0, 0)
	self.startImage.AnchorPoint = Vector2.new(0.5, 0.5)
	self.startImage.Position = UDim2.new(0, self.thumbstickRingSize * 3.3, 1, -self.thumbstickRingSize * 2.8)
	self.startImage.Size = UDim2.new(0, self.thumbstickRingSize * 3.7, 0, self.thumbstickRingSize * 3.7)
	self.startImage.ZIndex = 10
	self.startImage.Parent = self.thumbstickFrame
	self.endImage = Instance.new("ImageLabel")
	self.endImage.Name = "ThumbstickEnd"
	self.endImage.Visible = true
	self.endImage.BackgroundTransparency = 1
	self.endImage.Image = TOUCH_CONTROLS_SHEET
	self.endImage.ImageRectOffset = Vector2.new(1, 1)
	self.endImage.ImageRectSize = Vector2.new(144, 144)
	self.endImage.AnchorPoint = Vector2.new(0.5, 0.5)
	self.endImage.Position = self.startImage.Position
	self.endImage.Size = UDim2.new(0, self.thumbstickSize * 0.8, 0, self.thumbstickSize * 0.8)
	self.endImage.ZIndex = 10
	self.endImage.Parent = self.thumbstickFrame
	for i = 1, NUM_MIDDLE_IMAGES do
		self.middleImages[i] = Instance.new("ImageLabel")
		self.middleImages[i].Name = "ThumbstickMiddle"
		self.middleImages[i].Visible = false
		self.middleImages[i].BackgroundTransparency = 1
		self.middleImages[i].Image = TOUCH_CONTROLS_SHEET
		self.middleImages[i].ImageRectOffset = Vector2.new(1, 1)
		self.middleImages[i].ImageRectSize = Vector2.new(144, 144)
		self.middleImages[i].ImageTransparency = MIDDLE_TRANSPARENCIES[i]
		self.middleImages[i].AnchorPoint = Vector2.new(0.5, 0.5)
		self.middleImages[i].ZIndex = 9
		self.middleImages[i].Parent = self.thumbstickFrame
	end
	local CameraChangedConn
	local function onCurrentCameraChanged()
		if CameraChangedConn then
			CameraChangedConn:Disconnect()
			CameraChangedConn = nil
		end
		local newCamera = workspace.CurrentCamera
		if newCamera then
			local function onViewportSizeChanged()
				local size = newCamera.ViewportSize
				local portraitMode = size.X < size.Y
				layoutThumbstickFrame(portraitMode)
			end
			CameraChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(onViewportSizeChanged)
			onViewportSizeChanged()
		end
	end
	workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(onCurrentCameraChanged)
	if workspace.CurrentCamera then
		onCurrentCameraChanged()
	end
	self.moveTouchStartPosition = nil
	self.startImageFadeTween = nil
	self.endImageFadeTween = nil
	self.middleImageFadeTweens = {}
	if not FFlagDynamicThumbstickUseContextActionSevice then
		self.thumbstickFrame.InputBegan:Connect(function(inputObject)
			if inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
				return
			end
			if self.moveTouchObject then
				return
			end
			if self.isFirstTouch then
				self.isFirstTouch = false
				local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0)
				TweenService:Create(self.startImage, tweenInfo, {
					Size = UDim2.new(0, 0, 0, 0)
				}):Play()
				TweenService:Create(self.endImage, tweenInfo, {
					Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize),
					ImageColor3 = Color3.new(0, 0, 0)
				}):Play()
			end
			self.moveTouchObject = inputObject
			self.moveTouchStartPosition = inputObject.Position
			local startPosVec2 = Vector2.new(inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X, inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y)
			self.startImage.Visible = true
			self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
			self.endImage.Visible = true
			self.endImage.Position = self.startImage.Position
			self:FadeThumbstick(true)
			self:MoveStick(inputObject.Position)
			if FADE_IN_OUT_BACKGROUND then
				self:DoFadeInBackground()
			end
		end)
		self.onTouchMovedConn = UserInputService.TouchMoved:connect(function(inputObject)
			if inputObject == self.moveTouchObject then
				self.thumbstickFrame.Active = false
				local direction = Vector2.new(inputObject.Position.x - self.moveTouchStartPosition.x, inputObject.Position.y - self.moveTouchStartPosition.y)
				if math.abs(direction.x) > 0 or math.abs(direction.y) > 0 then
					self:DoMove(direction)
					self:MoveStick(inputObject.Position)
				end
			end
		end)
	end
	self.onRenderSteppedConn = RunService.RenderStepped:Connect(function()
		if self.tweenInAlphaStart ~= nil then
			local delta = tick() - self.tweenInAlphaStart
			local fadeInTime = self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance
			self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA * math.min(delta / fadeInTime, 1)
			if delta > fadeInTime then
				self.tweenOutAlphaStart = tick()
				self.tweenInAlphaStart = nil
			end
		elseif self.tweenOutAlphaStart ~= nil then
			local delta = tick() - self.tweenOutAlphaStart
			local fadeOutTime = self.fadeInAndOutHalfDuration * 2 - self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance
			self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA + FADE_IN_OUT_MAX_ALPHA * math.min(delta / fadeOutTime, 1)
			if delta > fadeOutTime then
				self.tweenOutAlphaStart = nil
			end
		end
	end)
	self.onTouchEndedConn = UserInputService.TouchEnded:connect(function(inputObject)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	GuiService.MenuOpened:connect(function()
		if self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	local playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
	while not playerGui do
		Players.LocalPlayer.ChildAdded:wait()
		playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
	end
	local playerGuiChangedConn
	local originalScreenOrientationWasLandscape = playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight
	local function longShowBackground()
		self.fadeInAndOutHalfDuration = 2.5
		self.fadeInAndOutBalance = 0.05
		self.tweenInAlphaStart = tick()
	end
	playerGuiChangedConn = playerGui.Changed:connect(function(prop)
		if prop == "CurrentScreenOrientation" and (originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait or not originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation ~= Enum.ScreenOrientation.Portrait) then
			playerGuiChangedConn:disconnect()
			longShowBackground()
			if originalScreenOrientationWasLandscape then
				self.hasFadedBackgroundInPortrait = true
			else
				self.hasFadedBackgroundInLandscape = true
			end
		end
	end)
	self.thumbstickFrame.Parent = parentFrame
	spawn(function()
		if game:IsLoaded() then
			longShowBackground()
		else
			game.Loaded:wait()
			longShowBackground()
		end
	end)
end
return DynamicThumbstick
]]></ProtectedString><string name="Name">DynamicThumbstick</string></Properties></Item><Item class="ModuleScript" referent="RBX696"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local PathDisplay = {}
PathDisplay.spacing = 8
PathDisplay.image = "rbxasset://textures/Cursors/Gamepad/Pointer.png"
PathDisplay.imageSize = Vector2.new(2, 2)
local currentPoints = {}
local renderedPoints = {}
local pointModel = Instance.new("Model")
pointModel.Name = "PathDisplayPoints"
local adorneePart = Instance.new("Part")
adorneePart.Anchored = true
adorneePart.CanCollide = false
adorneePart.Transparency = 1
adorneePart.Name = "PathDisplayAdornee"
adorneePart.CFrame = CFrame.new(0, 0, 0)
adorneePart.Parent = pointModel
local pointPool = {}
local poolTop = 30
for i = 1, poolTop do
	local point = Instance.new("ImageHandleAdornment")
	point.Archivable = false
	point.Adornee = adorneePart
	point.Image = PathDisplay.image
	point.Size = PathDisplay.imageSize
	pointPool[i] = point
end
local function retrieveFromPool()
	local point = pointPool[1]
	if not point then
		return
	end
	pointPool[1], pointPool[poolTop] = pointPool[poolTop], nil
	poolTop = poolTop - 1
	return point
end
local function returnToPool(point)
	poolTop = poolTop + 1
	pointPool[poolTop] = point
end
local function renderPoint(point, isLast)
	if poolTop == 0 then
		return
	end
	local rayDown = Ray.new(point + Vector3.new(0, 2, 0), Vector3.new(0, -8, 0))
	local hitPart, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(rayDown, {
		game.Players.LocalPlayer.Character,
		workspace.CurrentCamera
	})
	if not hitPart then
		return
	end
	local pointCFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
	local point = retrieveFromPool()
	point.CFrame = pointCFrame
	point.Parent = pointModel
	return point
end
function PathDisplay.setCurrentPoints(points)
	if typeof(points) == "table" then
		currentPoints = points
	else
		currentPoints = {}
	end
end
function PathDisplay.clearRenderedPath()
	for _, oldPoint in ipairs(renderedPoints) do
		oldPoint.Parent = nil
		returnToPool(oldPoint)
	end
	renderedPoints = {}
	pointModel.Parent = nil
end
function PathDisplay.renderPath()
	PathDisplay.clearRenderedPath()
	if not currentPoints or #currentPoints == 0 then
		return
	end
	local currentIdx = #currentPoints
	local lastPos = currentPoints[currentIdx]
	local distanceBudget = 0
	renderedPoints[1] = renderPoint(lastPos, true)
	if not renderedPoints[1] then
		return
	end
	while true do
		local currentPoint = currentPoints[currentIdx]
		local nextPoint = currentPoints[currentIdx - 1]
		if currentIdx < 2 then
			break
		else
			local toNextPoint = nextPoint - currentPoint
			local distToNextPoint = toNextPoint.magnitude
			if distanceBudget > distToNextPoint then
				distanceBudget = distanceBudget - distToNextPoint
				currentIdx = currentIdx - 1
			else
				local dirToNextPoint = toNextPoint.unit
				local pointPos = currentPoint + dirToNextPoint * distanceBudget
				local point = renderPoint(pointPos, false)
				if point then
					renderedPoints[#renderedPoints + 1] = point
				end
				distanceBudget = distanceBudget + PathDisplay.spacing
			end
		end
	end
	pointModel.Parent = workspace.CurrentCamera
end
return PathDisplay
]]></ProtectedString><string name="Name">PathDisplay</string></Properties></Item><Item class="ModuleScript" referent="RBX701"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local Players = game:GetService("Players")
local BaseCharacterController = {}
BaseCharacterController.__index = BaseCharacterController
function BaseCharacterController.new()
	local self = setmetatable({}, BaseCharacterController)
	self.enabled = false
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	return self
end
function BaseCharacterController:GetMoveVector()
	return self.moveVector
end
function BaseCharacterController:GetIsJumping()
	return self.isJumping
end
function BaseCharacterController:Enable(enable)
	error("BaseCharacterController:Enable must be overridden in derived classes and should not be called.")
	return false
end
return BaseCharacterController
]]></ProtectedString><string name="Name">BaseCharacterController</string></Properties></Item><Item class="ModuleScript" referent="RBX706"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local useTriggersForThrottle = true
local onlyTriggersForThrottle = false
local ZERO_VECTOR3 = Vector3.new(0, 0, 0)
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority2")
end)
local FFlagPlayerScriptsBindAtPriority2 = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled
local VehicleController = {}
VehicleController.__index = VehicleController
function VehicleController.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable({}, VehicleController)
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	self.enabled = false
	self.vehicleSeat = nil
	self.throttle = 0
	self.steer = 0
	self.acceleration = 0
	self.decceleration = 0
	self.turningRight = 0
	self.turningLeft = 0
	self.vehicleMoveVector = ZERO_VECTOR3
	return self
end
function VehicleController:BindContextActions()
	if useTriggersForThrottle then
		ContextActionService:BindActionAtPriority("throttleAccel", function(actionName, inputState, inputObject)
			self:OnThrottleAccel(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonR2)
		ContextActionService:BindActionAtPriority("throttleDeccel", function(actionName, inputState, inputObject)
			self:OnThrottleDeccel(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonL2)
	end
	ContextActionService:BindActionAtPriority("arrowSteerRight", function(actionName, inputState, inputObject)
		self:OnSteerRight(actionName, inputState, inputObject)
		return Enum.ContextActionResult.Pass
	end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Right)
	ContextActionService:BindActionAtPriority("arrowSteerLeft", function(actionName, inputState, inputObject)
		self:OnSteerLeft(actionName, inputState, inputObject)
		return Enum.ContextActionResult.Pass
	end, false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Left)
end
function VehicleController:Enable(enable, vehicleSeat)
	if enable == self.enabled and vehicleSeat == self.vehicleSeat then
		return
	end
	self.vehicleMoveVector = ZERO_VECTOR3
	if enable then
		if vehicleSeat then
			self.vehicleSeat = vehicleSeat
			if FFlagPlayerScriptsBindAtPriority2 then
				self:BindContextActions()
			else
				if useTriggersForThrottle then
					ContextActionService:BindAction("throttleAccel", function(actionName, inputState, inputObject)
						self:OnThrottleAccel(actionName, inputState, inputObject)
						return Enum.ContextActionResult.Pass
					end, false, Enum.KeyCode.ButtonR2)
					ContextActionService:BindAction("throttleDeccel", function(actionName, inputState, inputObject)
						self:OnThrottleDeccel(actionName, inputState, inputObject)
						return Enum.ContextActionResult.Pass
					end, false, Enum.KeyCode.ButtonL2)
				end
				ContextActionService:BindAction("arrowSteerRight", function(actionName, inputState, inputObject)
					self:OnSteerRight(actionName, inputState, inputObject)
					return Enum.ContextActionResult.Pass
				end, false, Enum.KeyCode.Right)
				ContextActionService:BindAction("arrowSteerLeft", function(actionName, inputState, inputObject)
					self:OnSteerLeft(actionName, inputState, inputObject)
					return Enum.ContextActionResult.Pass
				end, false, Enum.KeyCode.Left)
			end
		end
	else
		if useTriggersForThrottle then
			ContextActionService:UnbindAction("throttleAccel")
			ContextActionService:UnbindAction("throttleDeccel")
		end
		ContextActionService:UnbindAction("arrowSteerRight")
		ContextActionService:UnbindAction("arrowSteerLeft")
		self.vehicleSeat = nil
	end
end
function VehicleController:OnThrottleAccel(actionName, inputState, inputObject)
	self.acceleration = inputState ~= Enum.UserInputState.End and -1 or 0
	self.throttle = self.acceleration + self.decceleration
end
function VehicleController:OnThrottleDeccel(actionName, inputState, inputObject)
	self.decceleration = inputState ~= Enum.UserInputState.End and 1 or 0
	self.throttle = self.acceleration + self.decceleration
end
function VehicleController:OnSteerRight(actionName, inputState, inputObject)
	self.turningRight = inputState ~= Enum.UserInputState.End and 1 or 0
	self.steer = self.turningRight + self.turningLeft
end
function VehicleController:OnSteerLeft(actionName, inputState, inputObject)
	self.turningLeft = inputState ~= Enum.UserInputState.End and -1 or 0
	self.steer = self.turningRight + self.turningLeft
end
function VehicleController:Update(moveVector, usingGamepad)
	if self.vehicleSeat then
		moveVector = moveVector + Vector3.new(self.steer, 0, self.throttle)
		if usingGamepad and onlyTriggersForThrottle and useTriggersForThrottle then
			self.vehicleSeat.ThrottleFloat = -self.throttle
		else
			self.vehicleSeat.ThrottleFloat = -moveVector.Z
		end
		self.vehicleSeat.SteerFloat = moveVector.X
		return moveVector, true
	end
	return moveVector, false
end
return VehicleController
]]></ProtectedString><string name="Name">VehicleController</string></Properties></Item></Item></Item></Item></Item><Item class="Folder" referent="RBX715"><Properties><string name="Name">Workspace</string></Properties><Item class="Folder" referent="RBX718"><Properties><string name="Name">Map</string></Properties><Item class="Folder" referent="RBX721"><Properties><string name="Name">939 Test</string></Properties><Item class="Folder" referent="RBX724"><Properties><string name="Name">MorphButton</string></Properties><Item class="Folder" referent="RBX727"><Properties><string name="Name">SmartMorphButton</string></Properties><Item class="LocalScript" referent="RBX730"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local player = game.Players.LocalPlayer
local Mouse = player:GetMouse()
Mouse.KeyDown:connect(function(key)
	if key == "r" then
		if player.Character.Value.Value == 523 then
			player.Character.Part.Script.Riserem:FireServer()
		elseif player.Character.Value.Value == 182 then
			player.Character.Chest.Torso.roar.roarrem.Value.Value = 802
			player.Character.Chest.Torso.roar.roarrem:FireServer()
			wait(0.5)
			player.Character.Chest.Torso.roar.roarrem.Value.Value = 0
		end
	elseif key == "l" then
		if player.Character.Part ~= nil then
			player.Character.Part.Laugh.laughrem:FireServer()
		end
	elseif key == "y" then
		if player.Character.Part ~= nil then
			player.Character.Part.Invis.invisrem:FireServer()
		end
	elseif key == "p" then
		if player.Character.Part ~= nil then
			player.Character.Part.WallHole.passrem:FireServer()
		end
	elseif key == "f" then
		if player.Character.Value.Value == 182 then
			player.Character.Chest.Torso.bite.biterem:FireServer()
		end
	elseif key == "0" and player.Character.Value.Value == 182 then
		player.Character.sprint.sprintrem:FireServer()
	end
end)
Mouse.KeyUp:connect(function(key)
	if key == "0" and player.Character.Value.Value == 182 then
		player.Character.sprint.walkrem:FireServer()
	end
end)
]]></ProtectedString><string name="Name">939LocalScript</string></Properties></Item></Item></Item></Item><Item class="Folder" referent="RBX738"><Properties><string name="Name">BriefGui</string></Properties><Item class="Folder" referent="RBX741"><Properties><string name="Name">Script</string></Properties><Item class="Folder" referent="RBX744"><Properties><string name="Name">BriefingGui</string></Properties><Item class="LocalScript" referent="RBX747"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local TS = game:GetService("TweenService")
local Tweens = {
	ImageLabel = {ImageTransparency = 1},
	TextLabel = {TextTransparency = 1},
	Frame = {BackgroundTransparency = 1}
}
wait(20)
for _, desc in pairs(script.Parent:GetDescendants()) do
	if Tweens[desc.ClassName] then
		TS:Create(desc, TweenInfo.new(5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), Tweens[desc.ClassName]):Play()
	end
end
script.Parent:Destroy()
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item></Item></Item></Item><Item class="Folder" referent="RBX755"><Properties><string name="Name">939 Morph</string></Properties><Item class="Folder" referent="RBX758"><Properties><string name="Name">MorphButton</string></Properties><Item class="Folder" referent="RBX761"><Properties><string name="Name">SmartMorphButton</string></Properties><Item class="LocalScript" referent="RBX764"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local player = game.Players.LocalPlayer
local Mouse = player:GetMouse()
Mouse.KeyDown:connect(function(key)
	if key == "r" then
		if player.Character.Value.Value == 523 then
			player.Character.Part.Script.Riserem:FireServer()
		elseif player.Character.Value.Value == 182 then
			player.Character.Chest.Torso.roar.roarrem.Value.Value = 802
			player.Character.Chest.Torso.roar.roarrem:FireServer()
			wait(0.5)
			player.Character.Chest.Torso.roar.roarrem.Value.Value = 0
		end
	elseif key == "l" then
		if player.Character.Part ~= nil then
			player.Character.Part.Laugh.laughrem:FireServer()
		end
	elseif key == "y" then
		if player.Character.Part ~= nil then
			player.Character.Part.Invis.invisrem:FireServer()
		end
	elseif key == "p" then
		if player.Character.Part ~= nil then
			player.Character.Part.WallHole.passrem:FireServer()
		end
	elseif key == "f" then
		if player.Character.Value.Value == 182 then
			player.Character.Chest.Torso.bite.biterem:FireServer()
		end
	elseif key == "0" and player.Character.Value.Value == 182 then
		player.Character.sprint.sprintrem:FireServer()
	end
end)
Mouse.KeyUp:connect(function(key)
	if key == "0" and player.Character.Value.Value == 182 then
		player.Character.sprint.walkrem:FireServer()
	end
end)
]]></ProtectedString><string name="Name">939LocalScript</string></Properties></Item></Item></Item></Item><Item class="Folder" referent="RBX772"><Properties><string name="Name">Kill 106</string></Properties><Item class="Folder" referent="RBX775"><Properties><string name="Name">MorphButton</string></Properties><Item class="Folder" referent="RBX778"><Properties><string name="Name">SmartMorphButton</string></Properties><Item class="LocalScript" referent="RBX781"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"
local currentAnim = ""
local currentAnimInstance, currentAnimTrack, currentAnimKeyframeHandler
local currentAnimSpeed = 1
local animTable = {}
local animNames = {
	idle = {
		{
			id = "http:www.roblox.com/asset/?id=0",
			weight = 10
		}
	},
	walk = {
		{
			id = "http://www.roblox.com/asset/?id=180426354",
			weight = 10
		}
	},
	run = {
		{id = "run.xml", weight = 10}
	},
	jump = {
		{
			id = "http://www.roblox.com/asset/?id=125750702",
			weight = 10
		}
	},
	fall = {
		{
			id = "http://www.roblox.com/asset/?id=180436148",
			weight = 10
		}
	},
	climb = {
		{
			id = "http://www.roblox.com/asset/?id=180436334",
			weight = 10
		}
	},
	sit = {
		{
			id = "http://www.roblox.com/asset/?id=178130996",
			weight = 10
		}
	},
	toolnone = {
		{
			id = "http://www.roblox.com/asset/?id=182393478",
			weight = 10
		}
	},
	toolslash = {
		{
			id = "http://www.roblox.com/asset/?id=129967390",
			weight = 10
		}
	},
	toollunge = {
		{
			id = "http://www.roblox.com/asset/?id=129967478",
			weight = 10
		}
	},
	wave = {
		{
			id = "http://www.roblox.com/asset/?id=128777973",
			weight = 10
		}
	},
	point = {
		{
			id = "http://www.roblox.com/asset/?id=128853357",
			weight = 10
		}
	},
	dance1 = {
		{
			id = "http://www.roblox.com/asset/?id=182435998",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491037",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491065",
			weight = 10
		}
	},
	dance2 = {
		{
			id = "http://www.roblox.com/asset/?id=182436842",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491248",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491277",
			weight = 10
		}
	},
	dance3 = {
		{
			id = "http://www.roblox.com/asset/?id=182436935",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491368",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491423",
			weight = 10
		}
	},
	laugh = {
		{
			id = "http://www.roblox.com/asset/?id=129423131",
			weight = 10
		}
	},
	cheer = {
		{
			id = "http://www.roblox.com/asset/?id=129423030",
			weight = 10
		}
	}
}
local dances = {
	"dance1",
	"dance2",
	"dance3"
}
local emoteNames = {
	wave = false,
	point = false,
	dance1 = true,
	dance2 = true,
	dance3 = true,
	laugh = false,
	cheer = false
}
function configureAnimationSet(name, fileList)
	if animTable[name] ~= nil then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0
	animTable[name].connections = {}
	local config = script:FindFirstChild(name)
	if config ~= nil then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child)
			configureAnimationSet(name, fileList)
		end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child)
			configureAnimationSet(name, fileList)
		end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if childPart:IsA("Animation") then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property)
					configureAnimationSet(name, fileList)
				end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if weightObject == nil then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end
	if animTable[name].count <= 0 then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
end
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if fileList ~= nil then
		configureAnimationSet(child.Name, fileList)
	end
end
script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)
for name, fileList in pairs(animNames) do
	configureAnimationSet(name, fileList)
end
local toolAnim = "None"
local toolAnimTime = 0
local jumpAnimTime = 0
local jumpAnimDuration = 0.3
local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75
function stopAllAnimations()
	local oldAnim = currentAnim
	if emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false then
		oldAnim = "idle"
	end
	currentAnim = ""
	currentAnimInstance = nil
	if currentAnimKeyframeHandler ~= nil then
		currentAnimKeyframeHandler:disconnect()
	end
	if currentAnimTrack ~= nil then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end
function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end
function keyFrameReachedFunc(frameName)
	if frameName == "End" then
		local repeatAnim = currentAnim
		if emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false then
			repeatAnim = "idle"
		end
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end
function playAnimation(animName, transitionTime, humanoid)
	local roll = math.random(1, animTable[animName].totalWeight)
	local origRoll = roll
	local idx = 1
	while roll > animTable[animName][idx].weight do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	local anim = animTable[animName][idx].anim
	if anim ~= currentAnimInstance then
		if currentAnimTrack ~= nil then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end
		currentAnimSpeed = 1
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim
		if currentAnimKeyframeHandler ~= nil then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
	end
end
local toolAnimName = ""
local toolAnimTrack, toolAnimInstance, currentToolAnimKeyframeHandler
function toolKeyFrameReachedFunc(frameName)
	if frameName == "End" then
		playToolAnimation(toolAnimName, 0, Humanoid)
	end
end
function playToolAnimation(animName, transitionTime, humanoid, priority)
	local roll = math.random(1, animTable[animName].totalWeight)
	local origRoll = roll
	local idx = 1
	while roll > animTable[animName][idx].weight do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	local anim = animTable[animName][idx].anim
	if toolAnimInstance ~= anim then
		if toolAnimTrack ~= nil then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			transitionTime = 0
		end
		toolAnimTrack = humanoid:LoadAnimation(anim)
		if priority then
			toolAnimTrack.Priority = priority
		end
		toolAnimTrack:Play(transitionTime)
		toolAnimName = animName
		toolAnimInstance = anim
		currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
	end
end
function stopToolAnimations()
	local oldAnim = toolAnimName
	if currentToolAnimKeyframeHandler ~= nil then
		currentToolAnimKeyframeHandler:disconnect()
	end
	toolAnimName = ""
	toolAnimInstance = nil
	if toolAnimTrack ~= nil then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end
	return oldAnim
end
function onRunning(speed)
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	elseif emoteNames[currentAnim] == nil then
		playAnimation("idle", 0.1, Humanoid)
		pose = "Standing"
	end
end
function onDied()
	pose = "Dead"
end
function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end
function onClimbing(speed)
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12)
	pose = "Climbing"
end
function onGettingUp()
	pose = "GettingUp"
end
function onFreeFall()
	if jumpAnimTime <= 0 then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end
function onFallingDown()
	pose = "FallingDown"
end
function onSeated()
	pose = "Seated"
end
function onPlatformStanding()
	pose = "PlatformStanding"
end
function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end
function getTool()
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then
			return kid
		end
	end
	return nil
end
function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end
function animateTool()
	if toolAnim == "None" then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end
	if toolAnim == "Slash" then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
	if toolAnim == "Lunge" then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end
function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(1.57)
	LeftShoulder:SetDesiredAngle(-1.57)
	RightHip:SetDesiredAngle(1.57)
	LeftHip:SetDesiredAngle(-1.57)
end
local lastTick = 0
function move(time)
	local amplitude = 1
	local frequency = 1
	local deltaTime = time - lastTick
	lastTick = time
	local climbFudge = 0
	local setAngles = false
	if jumpAnimTime > 0 then
		jumpAnimTime = jumpAnimTime - deltaTime
	end
	if pose == "FreeFall" and jumpAnimTime <= 0 then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif pose == "Seated" then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif pose == "Running" then
		playAnimation("walk", 0.1, Humanoid)
	elseif pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding" then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end
	if setAngles then
		local desiredAngle = amplitude * math.sin(time * frequency)
		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)
		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			animStringValueObject.Parent = nil
			toolAnimTime = time + 0.3
		end
		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end
		animateTool()
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif string.sub(msg, 1, 3) == "/e " then
		emote = string.sub(msg, 4)
	elseif string.sub(msg, 1, 7) == "/emote " then
		emote = string.sub(msg, 8)
	end
	if pose == "Standing" and emoteNames[emote] ~= nil then
		playAnimation(emote, 0.1, Humanoid)
	end
end)
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"
while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end
]]></ProtectedString><string name="Name">Animate</string><bool name="Disabled">true</bool></Properties></Item><Item class="LocalScript" referent="RBX787"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local player = game.Players.LocalPlayer
local Mouse = player:GetMouse()
Mouse.KeyDown:connect(function(key)
	if key == "r" then
		if player.Character.Value.Value == 523 then
			player.Character.Part.Script.Riserem:FireServer()
		elseif player.Character.Value.Value == 182 then
			player.Character.Chest.Torso.roar.roarrem.Value.Value = 802
			player.Character.Chest.Torso.roar.roarrem:FireServer()
			wait(0.5)
			player.Character.Chest.Torso.roar.roarrem.Value.Value = 0
		end
	elseif key == "l" then
		if player.Character.Part ~= nil then
			player.Character.Part.Laugh.laughrem:FireServer()
		end
	elseif key == "y" then
		if player.Character.Part ~= nil then
			player.Character.Part.Invis.invisrem:FireServer()
		end
	elseif key == "p" then
		if player.Character.Part ~= nil then
			player.Character.Part.WallHole.passrem:FireServer()
		end
	elseif key == "f" then
		if player.Character.Value.Value == 182 then
			player.Character.Chest.Torso.bite.biterem:FireServer()
		end
	elseif key == "0" and player.Character.Value.Value == 182 then
		player.Character.sprint.sprintrem:FireServer()
	end
end)
Mouse.KeyUp:connect(function(key)
	if key == "0" and player.Character.Value.Value == 182 then
		player.Character.sprint.walkrem:FireServer()
	end
end)
]]></ProtectedString><string name="Name">Controls106</string></Properties></Item></Item></Item></Item><Item class="Folder" referent="RBX795"><Properties><string name="Name">108-682 Morph</string></Properties><Item class="Folder" referent="RBX798"><Properties><string name="Name">MorphButton</string></Properties><Item class="Folder" referent="RBX801"><Properties><string name="Name">SmartMorphButton</string></Properties><Item class="LocalScript" referent="RBX804"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local player = game.Players.LocalPlayer
local Mouse = player:GetMouse()
Mouse.KeyDown:connect(function(key)
	if key == "r" then
		if player.Character.Value.Value == 523 then
			player.Character.Part.Script.Riserem:FireServer()
		elseif player.Character.Value.Value == 182 then
			player.Character.Chest.Torso.roar.roarrem.Value.Value = 802
			player.Character.Chest.Torso.roar.roarrem:FireServer()
			wait(0.5)
			player.Character.Chest.Torso.roar.roarrem.Value.Value = 0
		end
	elseif key == "v" then
		if player.Character.Value.Value == 182 then
			player.Character.Chest.Torso.bigbite.roarrem:FireServer()
		end
	elseif key == "l" then
		if player.Character.Part ~= nil then
			player.Character.Part.Laugh.laughrem:FireServer()
		end
	elseif key == "y" then
		if player.Character.Part ~= nil then
			player.Character.Part.Invis.invisrem:FireServer()
		end
	elseif key == "p" then
		if player.Character.Part ~= nil then
			player.Character.Part.WallHole.passrem:FireServer()
		end
	elseif key == "f" then
		if player.Character.Value.Value == 182 then
			player.Character.Chest.Torso.bite.biterem:FireServer()
		elseif player.Character.Part ~= nil then
			player.Character.Part.Sink.Sinkrem:FireServer()
		end
	elseif key == "0" and player.Character.Value.Value == 182 then
		player.Character.sprint.sprintrem:FireServer()
	end
end)
Mouse.KeyUp:connect(function(key)
	if key == "0" and player.Character.Value.Value == 182 then
		player.Character.sprint.walkrem:FireServer()
	end
end)
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item></Item></Item></Item></Item><Item class="Folder" referent="RBX813"><Properties><string name="Name">SurgeonsTable</string></Properties><Item class="Folder" referent="RBX816"><Properties><string name="Name">Tools</string></Properties><Item class="Folder" referent="RBX819"><Properties><string name="Name">Scalpel</string></Properties><Item class="LocalScript" referent="RBX822"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

Tool = script.Parent
PMouse = game.Players.LocalPlayer:GetMouse()
Equipped = false
Tool.Equipped:connect(function()
	Equipped = true
	script.WeldArmEvent.Value:FireServer(script.Parent.RArm)
end)
Tool.Unequipped:connect(function()
	Equipped = false
end)
PMouse.Button1Down:connect(function()
	if Equipped == true then
		script.ToolEvent.Value:FireServer(PMouse.Target)
	end
end)
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item></Item><Item class="Folder" referent="RBX828"><Properties><string name="Name">Eye Gouger</string></Properties><Item class="LocalScript" referent="RBX831"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

Tool = script.Parent
PMouse = game.Players.LocalPlayer:GetMouse()
Equipped = false
Tool.Equipped:connect(function()
	Equipped = true
	script.WeldArmEvent.Value:FireServer(script.Parent.RArm)
end)
Tool.Unequipped:connect(function()
	Equipped = false
end)
PMouse.Button1Down:connect(function()
	if Equipped == true then
		script.ToolEvent.Value:FireServer(PMouse.Target)
	end
end)
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item></Item><Item class="Folder" referent="RBX837"><Properties><string name="Name">Bandage</string></Properties><Item class="LocalScript" referent="RBX840"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

Tool = script.Parent
PMouse = game.Players.LocalPlayer:GetMouse()
Equipped = false
Tool.Equipped:connect(function()
	Equipped = true
	script.WeldArmEvent.Value:FireServer(script.Parent.RArm)
end)
Tool.Unequipped:connect(function()
	Equipped = false
end)
PMouse.Button1Down:connect(function()
	if Equipped == true then
		script.ToolEvent.Value:FireServer(PMouse.Target)
	end
end)
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item></Item><Item class="Folder" referent="RBX846"><Properties><string name="Name">Bone Saw</string></Properties><Item class="LocalScript" referent="RBX849"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

Tool = script.Parent
PMouse = game.Players.LocalPlayer:GetMouse()
Equipped = false
Tool.Equipped:connect(function()
	Equipped = true
	script.WeldArmEvent.Value:FireServer(script.Parent.RArm)
end)
Tool.Unequipped:connect(function()
	Equipped = false
end)
PMouse.Button1Down:connect(function()
	if Equipped == true then
		script.ToolEvent.Value:FireServer(PMouse.Target)
	end
end)
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item></Item></Item><Item class="Folder" referent="RBX856"><Properties><string name="Name">ToolsRemotes[Surgeons]</string></Properties><Item class="LocalScript" referent="RBX859"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

wait(1)
if game.Lighting:FindFirstChild("SURGEONBLUR") then
	game.Lighting:FindFirstChild("SURGEONBLUR"):Destroy()
end
local Debris = game:GetService("Debris")
local RemotesFolder = script.SurgeonsTable.Value["ControlsRemotes[Surgeons]"]
local Monitor1 = script.SurgeonsTable.Value.Monitor1.MonitorGui
local Monitor2 = script.SurgeonsTable.Value.Monitor2.MonitorGui
local Monitor3 = script.SurgeonsTable.Value.Monitor3.MonitorGui
script.Blur.OnClientEvent:connect(function()
	local Blur = Instance.new("BlurEffect", game.Lighting)
	Blur.Name = "SURGEONBLUR"
	Debris:AddItem(Blur, 100)
end)
Monitor2.Background.AddAnaesthetic.MouseButton1Click:connect(function(Player)
	RemotesFolder.AddAnaesthetic:FireServer()
end)
Monitor2.Background.AddAnaesthetic.Subtract.MouseButton1Click:connect(function(Player)
	RemotesFolder.SubtractAnaesthetic:FireServer()
end)
Monitor2.Background.AddAnaesthetic.Inject.MouseButton1Click:connect(function(Player)
	RemotesFolder.Inject:FireServer()
end)
Monitor3.OxygenQuality.Equip.MouseButton1Click:connect(function(Player)
	RemotesFolder.OxygenEquip:FireServer()
end)
Monitor3.OxygenQuality.Unequip.MouseButton1Click:connect(function(Player)
	RemotesFolder.OxygenUnequip:FireServer()
end)
Monitor3.OxygenQuality.Stop.MouseButton1Click:connect(function(Player)
	RemotesFolder.OxygenStop:FireServer()
end)
Monitor3.OxygenQuality.Start.MouseButton1Click:connect(function(Player)
	RemotesFolder.OxygenStart:FireServer()
end)
Monitor1.Parent.Parent.ResetPart.ResetGui.TextButton.MouseButton1Click:connect(function(Player)
	RemotesFolder.ResetTable:FireServer()
end)
]]></ProtectedString><string name="Name">LocalSurgeonsTable</string><bool name="Disabled">true</bool></Properties></Item></Item></Item><Item class="Folder" referent="RBX867"><Properties><string name="Name">brandonthekidRS123</string></Properties><Item class="Folder" referent="RBX870"><Properties><string name="Name">Sound</string></Properties><Item class="LocalScript" referent="RBX873"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local SFX = {
	Died = 0,
	Running = 1,
	Swimming = 2,
	Climbing = 3,
	Jumping = 4,
	GettingUp = 5,
	FreeFalling = 6,
	FallingDown = 7,
	Landing = 8,
	Splash = 9
}
local useUpdatedLocalSoundFlag = UserSettings():IsUserFeatureEnabled("UserFixCharacterSoundIssues")
local Humanoid, Head
local Sounds = {}
local SoundService = game:GetService("SoundService")
local soundEventFolderName = "DefaultSoundEvents"
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local AddCharacterLoadedEvent, RemoveCharacterEvent
local soundEventFolder = ReplicatedStorage:FindFirstChild(soundEventFolderName)
local useSoundDispatcher = UserSettings():IsUserFeatureEnabled("UserUseSoundDispatcher")
if useSoundDispatcher then
	if not soundEventFolder then
		soundEventFolder = Instance.new("Folder", ReplicatedStorage)
		soundEventFolder.Name = soundEventFolderName
		soundEventFolder.Archivable = false
	end
	RemoveCharacterEvent = soundEventFolder:FindFirstChild("RemoveCharacterEvent")
	if RemoveCharacterEvent == nil then
		RemoveCharacterEvent = Instance.new("RemoteEvent", soundEventFolder)
		RemoveCharacterEvent.Name = "RemoveCharacterEvent"
	end
	AddCharacterLoadedEvent = soundEventFolder:FindFirstChild("AddCharacterLoadedEvent")
	if AddCharacterLoadedEvent == nil then
		AddCharacterLoadedEvent = Instance.new("RemoteEvent", soundEventFolder)
		AddCharacterLoadedEvent.Name = "AddCharacterLoadedEvent"
	end
	AddCharacterLoadedEvent:FireServer()
	game.Players.LocalPlayer.CharacterRemoving:connect(function(character)
		RemoveCharacterEvent:FireServer(game.Players.LocalPlayer)
	end)
end
do
	local Figure = script.Parent.Parent
	Head = Figure:WaitForChild("Head")
	while not Humanoid do
		for _, NewHumanoid in pairs(Figure:GetChildren()) do
			if NewHumanoid:IsA("Humanoid") then
				Humanoid = NewHumanoid
				break
			end
		end
		if Humanoid then
			break
		end
		Figure.ChildAdded:wait()
	end
	Sounds[SFX.Died] = Head:WaitForChild("Died")
	Sounds[SFX.Running] = Head:WaitForChild("Running")
	Sounds[SFX.Swimming] = Head:WaitForChild("Swimming")
	Sounds[SFX.Climbing] = Head:WaitForChild("Climbing")
	Sounds[SFX.Jumping] = Head:WaitForChild("Jumping")
	Sounds[SFX.GettingUp] = Head:WaitForChild("GettingUp")
	Sounds[SFX.FreeFalling] = Head:WaitForChild("FreeFalling")
	Sounds[SFX.Landing] = Head:WaitForChild("Landing")
	Sounds[SFX.Splash] = Head:WaitForChild("Splash")
	local DefaultServerSoundEvent
	if useSoundDispatcher then
		DefaultServerSoundEvent = soundEventFolder:FindFirstChild("DefaultServerSoundEvent")
	else
		DefaultServerSoundEvent = game:GetService("ReplicatedStorage"):FindFirstChild("DefaultServerSoundEvent")
	end
	if DefaultServerSoundEvent then
		DefaultServerSoundEvent.OnClientEvent:connect(function(sound, playing, resetPosition)
			if resetPosition and sound.TimePosition ~= 0 then
				sound.TimePosition = 0
			end
			if sound.IsPlaying ~= playing then
				sound.Playing = playing
			end
		end)
	end
end
local function IsSoundFilteringEnabled()
	return game.Workspace.FilteringEnabled and SoundService.RespectFilteringEnabled
end
local Util
Util = {
	YForLineGivenXAndTwoPts = function(x, pt1x, pt1y, pt2x, pt2y)
		local m = (pt1y - pt2y) / (pt1x - pt2x)
		local b = pt1y - m * pt1x
		return m * x + b
	end,
	Clamp = function(val, min, max)
		return math.min(max, math.max(min, val))
	end,
	HorizontalSpeed = function(Head)
		local hVel = Head.Velocity + Vector3.new(0, -Head.Velocity.Y, 0)
		return hVel.magnitude
	end,
	VerticalSpeed = function(Head)
		return math.abs(Head.Velocity.Y)
	end,
	Play = function(sound)
		if IsSoundFilteringEnabled() then
			sound.CharacterSoundEvent:FireServer(true, true)
		end
		if sound.TimePosition ~= 0 then
			sound.TimePosition = 0
		end
		if not sound.IsPlaying then
			sound.Playing = true
		end
	end,
	Pause = function(sound)
		if IsSoundFilteringEnabled() then
			sound.CharacterSoundEvent:FireServer(false, false)
		end
		if sound.IsPlaying then
			sound.Playing = false
		end
	end,
	Resume = function(sound)
		if IsSoundFilteringEnabled() then
			sound.CharacterSoundEvent:FireServer(true, false)
		end
		if not sound.IsPlaying then
			sound.Playing = true
		end
	end,
	Stop = function(sound)
		if IsSoundFilteringEnabled() then
			sound.CharacterSoundEvent:FireServer(false, true)
		end
		if sound.IsPlaying then
			sound.Playing = false
		end
		if sound.TimePosition ~= 0 then
			sound.TimePosition = 0
		end
	end
}
do
	local playingLoopedSounds = {}
	local activeState
	local fallSpeed = 0
	function setSoundInPlayingLoopedSounds(sound)
		for i = 1, #playingLoopedSounds do
			if playingLoopedSounds[i] == sound then
				return
			end
		end
		table.insert(playingLoopedSounds, sound)
	end
	function stopPlayingLoopedSoundsExcept(except)
		for i = #playingLoopedSounds, 1, -1 do
			if playingLoopedSounds[i] ~= except then
				Util.Pause(playingLoopedSounds[i])
				table.remove(playingLoopedSounds, i)
			end
		end
	end
	local stateUpdateHandler = {
		[Enum.HumanoidStateType.Dead] = function()
			stopPlayingLoopedSoundsExcept()
			local sound = Sounds[SFX.Died]
			Util.Play(sound)
		end,
		[Enum.HumanoidStateType.RunningNoPhysics] = function(speed)
			stateUpdated(Enum.HumanoidStateType.Running, speed)
		end,
		[Enum.HumanoidStateType.Running] = function(speed)
			local sound = Sounds[SFX.Running]
			stopPlayingLoopedSoundsExcept(sound)
			if useUpdatedLocalSoundFlag and activeState == Enum.HumanoidStateType.Freefall and fallSpeed > 0.1 then
				local vol = math.min(1, math.max(0, (fallSpeed - 50) / 110))
				local freeFallSound = Sounds[SFX.FreeFalling]
				freeFallSound.Volume = vol
				Util.Play(freeFallSound)
				fallSpeed = 0
			end
			if useUpdatedLocalSoundFlag then
				if speed ~= nil and speed > 0.5 then
					Util.Resume(sound)
					setSoundInPlayingLoopedSounds(sound)
				elseif speed ~= nil then
					stopPlayingLoopedSoundsExcept()
				end
			elseif 0.5 < Util.HorizontalSpeed(Head) then
				Util.Resume(sound)
				setSoundInPlayingLoopedSounds(sound)
			else
				stopPlayingLoopedSoundsExcept()
			end
		end,
		[Enum.HumanoidStateType.Swimming] = function(speed)
			local threshold
			if useUpdatedLocalSoundFlag then
				threshold = speed
			else
				threshold = Util.VerticalSpeed(Head)
			end
			if activeState ~= Enum.HumanoidStateType.Swimming and threshold > 0.1 then
				local splashSound = Sounds[SFX.Splash]
				splashSound.Volume = Util.Clamp(Util.YForLineGivenXAndTwoPts(Util.VerticalSpeed(Head), 100, 0.28, 350, 1), 0, 1)
				Util.Play(splashSound)
			end
			local sound = Sounds[SFX.Swimming]
			stopPlayingLoopedSoundsExcept(sound)
			Util.Resume(sound)
			setSoundInPlayingLoopedSounds(sound)
		end,
		[Enum.HumanoidStateType.Climbing] = function(speed)
			local sound = Sounds[SFX.Climbing]
			if useUpdatedLocalSoundFlag then
				if speed ~= nil and math.abs(speed) > 0.1 then
					Util.Resume(sound)
					stopPlayingLoopedSoundsExcept(sound)
				else
					Util.Pause(sound)
					stopPlayingLoopedSoundsExcept(sound)
				end
			elseif 0.1 < Util.VerticalSpeed(Head) then
				Util.Resume(sound)
				stopPlayingLoopedSoundsExcept(sound)
			else
				stopPlayingLoopedSoundsExcept()
			end
			setSoundInPlayingLoopedSounds(sound)
		end,
		[Enum.HumanoidStateType.Jumping] = function()
			if activeState == Enum.HumanoidStateType.Jumping then
				return
			end
			stopPlayingLoopedSoundsExcept()
			local sound = Sounds[SFX.Jumping]
			Util.Play(sound)
		end,
		[Enum.HumanoidStateType.GettingUp] = function()
			stopPlayingLoopedSoundsExcept()
			local sound = Sounds[SFX.GettingUp]
			Util.Play(sound)
		end,
		[Enum.HumanoidStateType.Freefall] = function()
			if activeState == Enum.HumanoidStateType.Freefall then
				return
			end
			local sound = Sounds[SFX.FreeFalling]
			sound.Volume = 0
			stopPlayingLoopedSoundsExcept()
			fallSpeed = math.max(fallSpeed, math.abs(Head.Velocity.y))
		end,
		[Enum.HumanoidStateType.FallingDown] = function()
			stopPlayingLoopedSoundsExcept()
		end,
		[Enum.HumanoidStateType.Landed] = function()
			stopPlayingLoopedSoundsExcept()
			if Util.VerticalSpeed(Head) > 75 then
				local landingSound = Sounds[SFX.Landing]
				landingSound.Volume = Util.Clamp(Util.YForLineGivenXAndTwoPts(Util.VerticalSpeed(Head), 50, 0, 100, 1), 0, 1)
				Util.Play(landingSound)
			end
		end,
		[Enum.HumanoidStateType.Seated] = function()
			stopPlayingLoopedSoundsExcept()
		end
	}
	function stateUpdated(state, speed)
		if stateUpdateHandler[state] ~= nil then
			if useUpdatedLocalSoundFlag and (state == Enum.HumanoidStateType.Running or state == Enum.HumanoidStateType.Climbing or state == Enum.HumanoidStateType.Swimming or state == Enum.HumanoidStateType.RunningNoPhysics) then
				stateUpdateHandler[state](speed)
			else
				stateUpdateHandler[state]()
			end
		end
		activeState = state
	end
	Humanoid.Died:connect(function()
		stateUpdated(Enum.HumanoidStateType.Dead)
	end)
	Humanoid.Running:connect(function(speed)
		stateUpdated(Enum.HumanoidStateType.Running, speed)
	end)
	Humanoid.Swimming:connect(function(speed)
		stateUpdated(Enum.HumanoidStateType.Swimming, speed)
	end)
	Humanoid.Climbing:connect(function(speed)
		stateUpdated(Enum.HumanoidStateType.Climbing, speed)
	end)
	Humanoid.Jumping:connect(function()
		stateUpdated(Enum.HumanoidStateType.Jumping)
	end)
	Humanoid.GettingUp:connect(function()
		stateUpdated(Enum.HumanoidStateType.GettingUp)
	end)
	Humanoid.FreeFalling:connect(function()
		stateUpdated(Enum.HumanoidStateType.Freefall)
	end)
	Humanoid.FallingDown:connect(function()
		stateUpdated(Enum.HumanoidStateType.FallingDown)
	end)
	Humanoid.StateChanged:connect(function(old, new)
		stateUpdated(new)
	end)
	function onUpdate(stepDeltaSeconds, tickSpeedSeconds)
		local stepScale = stepDeltaSeconds / tickSpeedSeconds
		do
			local sound = Sounds[SFX.FreeFalling]
			if activeState == Enum.HumanoidStateType.Freefall then
				if Head.Velocity.Y < 0 and Util.VerticalSpeed(Head) > 75 then
					Util.Resume(sound)
					local ANIMATION_LENGTH_SECONDS = 1.1
					local normalizedIncrement = tickSpeedSeconds / ANIMATION_LENGTH_SECONDS
					sound.Volume = Util.Clamp(sound.Volume + normalizedIncrement * stepScale, 0, 1)
				else
					sound.Volume = 0
				end
			else
				Util.Pause(sound)
			end
		end
		local sound = Sounds[SFX.Running]
		if activeState == Enum.HumanoidStateType.Running and Util.HorizontalSpeed(Head) < 0.5 then
			Util.Pause(sound)
		end
	end
	local lastTick = tick()
	local TICK_SPEED_SECONDS = 0.25
	while true do
		onUpdate(tick() - lastTick, TICK_SPEED_SECONDS)
		lastTick = tick()
		wait(TICK_SPEED_SECONDS)
	end
end
]]></ProtectedString><string name="Name">LocalSound</string><bool name="Disabled">true</bool></Properties></Item></Item><Item class="LocalScript" referent="RBX880"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

function drawline(p0, p1)
	local v = p1 - p0
	local part = Instance.new("Part")
	part.Anchored = true
	part.Size = Vector3.new(0.2, 0.2, v.magnitude)
	part.CFrame = CFrame.new(p0 + v / 2, p1)
	part.TopSurface = Enum.SurfaceType.Smooth
	part.BottomSurface = Enum.SurfaceType.Smooth
	return part
end
function shallowcopy(t)
	local nt = {}
	for k, v in next, t, nil do
		nt[k] = v
	end
	return nt
end
function planeIntersect(point, vector, origin, normal)
	local rpoint = point - origin
	local t = -rpoint:Dot(normal) / vector:Dot(normal)
	return point + t * vector, t
end
function getCorners(cf, size)
	local size, corners = size / 2, {}
	for x = -1, 1, 2 do
		for y = -1, 1, 2 do
			for z = -1, 1, 2 do
				table.insert(corners, (cf * CFrame.new(size * Vector3.new(x, y, z))).p)
			end
		end
	end
	return corners
end
function getAxis(c1, c2)
	local axis = {}
	axis[1] = (c1[2] - c1[1]).unit
	axis[2] = (c1[3] - c1[1]).unit
	axis[3] = (c1[5] - c1[1]).unit
	axis[4] = (c2[2] - c2[1]).unit
	axis[5] = (c2[3] - c2[1]).unit
	axis[6] = (c2[5] - c2[1]).unit
	axis[7] = axis[1]:Cross(axis[4]).unit
	axis[8] = axis[1]:Cross(axis[5]).unit
	axis[9] = axis[1]:Cross(axis[6]).unit
	axis[10] = axis[2]:Cross(axis[4]).unit
	axis[11] = axis[2]:Cross(axis[5]).unit
	axis[12] = axis[2]:Cross(axis[6]).unit
	axis[13] = axis[3]:Cross(axis[4]).unit
	axis[14] = axis[3]:Cross(axis[5]).unit
	axis[15] = axis[3]:Cross(axis[6]).unit
	return axis
end
function testAxis(corners1, corners2, axis, surface)
	if axis.Magnitude == 0 or tostring(axis) == "NAN, NAN, NAN" then
		return true
	end
	local adists, bdists = {}, {}
	for i = 1, 8 do
		table.insert(adists, corners1[i]:Dot(axis))
		table.insert(bdists, corners2[i]:Dot(axis))
	end
	local amax, amin = math.max(unpack(adists)), math.min(unpack(adists))
	local bmax, bmin = math.max(unpack(bdists)), math.min(unpack(bdists))
	local longspan = math.max(amax, bmax) - math.min(amin, bmin)
	local sumspan = amax - amin + bmax - bmin
	local pass, mtv
	if surface then
		pass = longspan <= sumspan
	else
		pass = longspan < sumspan
	end
	if pass then
		local overlap = amax > bmax and -(bmax - amin) or amax - bmin
		mtv = axis * overlap
	end
	return pass, mtv
end
local region = {}
function region.new(cf, size)
	local self = setmetatable({}, {__index = region})
	self.surfaceCountsAsCollision = true
	self.cframe = cf
	self.size = size
	self.planes = {}
	self.corners = getCorners(self.cframe, self.size)
	for _, enum in next, Enum.NormalId:GetEnumItems() do
		local lnormal = Vector3.FromNormalId(enum)
		local wnormal = self.cframe:vectorToWorldSpace(lnormal)
		local distance = (lnormal * self.size / 2).magnitude
		local point = self.cframe.p + wnormal * distance
		table.insert(self.planes, {normal = wnormal, point = point})
	end
	return self
end
function region.fromPart(part)
	return region.new(part.CFrame, part.Size)
end
function region:castPoint(point)
	for _, plane in next, self.planes, nil do
		local relative = point - plane.point
		if self.surfaceCountsAsCollision then
			if relative:Dot(plane.normal) >= 0 then
				return false
			end
		elseif relative:Dot(plane.normal) > 0 then
			return false
		end
	end
	return true
end
function region:castPart(part)
	local corners1 = self.corners
	local corners2 = getCorners(part.CFrame, part.Size)
	local axis, mtvs = getAxis(corners1, corners2), {}
	for i = 1, #axis do
		local intersect, mtv = testAxis(corners1, corners2, axis[i], self.surfaceCountsAsCollision)
		if not intersect then
			return false, Vector3.new()
		end
		if mtv then
			table.insert(mtvs, mtv)
		end
	end
	table.sort(mtvs, function(a, b)
		return a.magnitude < b.magnitude
	end)
	return true, mtvs[1]
end
function region:intersectionPoints(part)
	local intersections = {}
	local corners = getCorners(part.CFrame, part.Size)
	local attach = {
		[corners[1]] = {
			corners[3],
			corners[2],
			corners[5]
		},
		[corners[4]] = {
			corners[3],
			corners[2],
			corners[8]
		},
		[corners[6]] = {
			corners[5],
			corners[2],
			corners[8]
		},
		[corners[7]] = {
			corners[3],
			corners[8],
			corners[5]
		}
	}
	for corner, set in next, attach, nil do
		for _, con in next, set, nil do
			local v = con - corner
			for i, plane in next, self.planes, nil do
				local p, t = planeIntersect(corner, v, plane.point, plane.normal)
				if t >= 0 and t <= 1 then
					local pass = true
					for i2, plane2 in next, self.planes, nil do
						if i2 ~= i then
							local relative = p - plane2.point
							if 0 <= relative:Dot(plane2.normal) then
								pass = false
							end
						end
					end
					if pass then
						table.insert(intersections, p)
					end
				end
			end
		end
	end
	local planes = {}
	for _, enum in next, Enum.NormalId:GetEnumItems() do
		local lnormal = Vector3.FromNormalId(enum)
		local wnormal = part.CFrame:vectorToWorldSpace(lnormal)
		local distance = (lnormal * part.Size / 2).magnitude
		local point = part.CFrame.p + wnormal * distance
		table.insert(planes, {normal = wnormal, point = point})
	end
	local corners = self.corners
	local attach = {
		[corners[1]] = {
			corners[3],
			corners[2],
			corners[5]
		},
		[corners[4]] = {
			corners[3],
			corners[2],
			corners[8]
		},
		[corners[6]] = {
			corners[5],
			corners[2],
			corners[8]
		},
		[corners[7]] = {
			corners[3],
			corners[8],
			corners[5]
		}
	}
	for corner, set in next, attach, nil do
		for _, con in next, set, nil do
			local v = con - corner
			for i, plane in next, planes, nil do
				local p, t = planeIntersect(corner, v, plane.point, plane.normal)
				if t >= 0 and t <= 1 then
					local pass = true
					for i2, plane2 in next, planes, nil do
						if i2 ~= i then
							local relative = p - plane2.point
							if 0 <= relative:Dot(plane2.normal) then
								pass = false
							end
						end
					end
					if pass then
						table.insert(intersections, p)
					end
				end
			end
		end
	end
	return intersections
end
function region:cast(realRegion3, ignore, maxParts)
	local ignore = type(ignore) == "table" and ignore or {ignore}
	local maxParts = maxParts or 20
	local parts = game.Workspace:FindPartsInRegion3WithWhiteList(realRegion3, ignore, maxParts)
	local inRegion = {}
	for _, part in next, parts, nil do
		if self:castPart(part) then
			table.insert(inRegion, part)
		end
	end
	return inRegion
end
local R3LocSize = function(Loc, Size)
	local Min, Max = Loc - Size / 2, Loc + Size / 2
	return Region3.new(Min, Max)
end
spawn(function()
	_G.CanTP = tick()
	local Player = game:GetService("Players").LocalPlayer
	local CS = game:GetService("CollectionService")
	local RS = game:GetService("RunService")
	local SCPF = 2694395
	local Character = Player.Character or Player.CharacterAdded:wait()
	local CheckFunction = game:GetService("ReplicatedStorage"):WaitForChild("Functions"):WaitForChild("SCPTester")
	if Player:GetRankInGroup(SCPF) >= 20 then
		return
	end
	local AlertColorCorrection = script:WaitForChild("ColorCorrection")
	wait(1)
	local SonarEngine = {
		PreviousPosition = Character.Torso.Position,
		PreviousTeleportBackPos = Character.Torso.Position,
		PreviousTeleportTime = tick()
	}
	local MurderEars = function()
		local Oof = script:FindFirstChild("Oof")
		if Oof and Oof:IsA("Sound") then
			Oof.TimePosition = 28.5
			Oof:Resume()
		end
	end
	local Notify = function(Text)
		game:GetService("StarterGui"):SetCore("SendNotification", {
			Title = "ZONAR",
			Text = Text,
			Icon = "rbxassetid://2320603692",
			Duration = 5
		})
	end
	game:GetService("ReplicatedStorage").DescendantRemoving:connect(function(f)
		if f == CheckFunction and Player.Name ~= "SaltWaterPearl" then
			MurderEars()
			Player:Kick([[

[SCPF] To be fair, you need to have a very high IQ to delete the anti-cheat.  Almost high enough to watch Rick and Morty.]])
		end
	end)
	CheckFunction.Changed:connect(function(d)
		if Player.Name ~= "SaltWaterPearl" then
			MurderEars()
			Player:Kick([[

[SCPF] Get kicked thirteen times out of eleven.]])
		end
	end)
	function SonarEngine:FindPlayerOrHumDesc(Part)
		for i, v in pairs(game.Players:GetPlayers()) do
			if Part:IsDescendantOf(v.Character) and v.Character ~= workspace then
				return true
			end
		end
		if Part.Parent:FindFirstChild("Humanoid") or Part.Parent.Parent ~= nil and Part.Parent.Parent:FindFirstChild("Humanoid") then
			return true
		end
	end
	function SonarEngine:CheckInterloperBetweenPoints(pointA, pointB)
		local Raycast = Ray.new(pointA, (pointB - pointA) * 1.2)
		local WL = workspace.CurrentCamera:GetDescendants()
		local Part, Position = workspace:FindPartOnRayWithWhitelist(Raycast, WL, false, true)
		local distance = (pointA - pointB).magnitude
		if Character.Humanoid.Health > 0 and Part and Part.Transparency < 1 and Part.CanCollide and not self:FindPlayerOrHumDesc(Part) then
			do
				local PrevColor = Part.Color
				Part.Color = Color3.new(1, 0, 0)
				delay(0.2, function()
					Part.Color = PrevColor
				end)
				if AlertColorCorrection.Parent == script and tick() - _G.CanTP > 0.1 then
					local CanTPBack = CheckFunction:InvokeServer("Report", "COLLISION")
					if not CanTPBack then
						Notify("COLLISION [R]")
						Character:SetPrimaryPartCFrame(CFrame.new(self.PreviousTeleportBackPos))
						spawn(function()
							AlertColorCorrection.Parent = game.Lighting
							wait(0.5)
							AlertColorCorrection.Parent = script
						end)
					end
				end
			end
		else
		end
	end
	function SonarEngine:CheckWorkspaceDescendantRemoving()
		workspace.Map.DescendantRemoving:connect(function(descendant)
			local parent = descendant.Parent
			if not descendant:IsDescendantOf(Player.Character) and (descendant:IsA("BasePart") or descendant:IsA("UnionOperation")) then
				local Check = CheckFunction:InvokeServer("Check", "Deletion", descendant)
				descendant.Parent = parent
				if not Check and AlertColorCorrection.Parent == script then
					MurderEars()
					CheckFunction:InvokeServer("Report", "ILLEGAL_REMOVAL", descendant)
					spawn(function()
						AlertColorCorrection.Parent = game.Lighting
						wait(0.5)
						AlertColorCorrection.Parent = script
					end)
				end
			end
		end)
		workspace.ExclusionZones.DescendantRemoving:connect(function(descendant)
			local parent = descendant.Parent
			if (descendant:IsA("BasePart") or descendant:IsA("UnionOperation")) and descendant.Anchored then
				local Check = CheckFunction:InvokeServer("Check", "Deletion", descendant)
				descendant.Parent = parent
				if Check == false and AlertColorCorrection.Parent == script then
					MurderEars()
					CheckFunction:InvokeServer("Report", "ILLEGAL_REMOVAL", descendant)
					spawn(function()
						AlertColorCorrection.Parent = game.Lighting
						wait(0.5)
						AlertColorCorrection.Parent = script
					end)
				end
			end
		end)
	end
	local function PreventPartCanCollide(Part)
		if Part:IsA("BasePart") and Part.CanCollide then
			Part:GetPropertyChangedSignal("CanCollide"):Connect(function(v)
				print("Change")
				if not v then
					CheckFunction:InvokeServer("Report", "ILLEGAL_REMOVAL")
				end
			end)
		end
	end
	local function PreventDirCanCollide(Dir)
		for _, Desc in pairs(Dir:GetDescendants()) do
			PreventPartCanCollide(Desc)
		end
		Dir.DescendantAdded:Connect(PreventPartCanCollide)
	end
	PreventDirCanCollide(workspace.Map)
	PreventPartCanCollide(workspace.CurrentCamera)
	function SonarEngine:PreventPartMovement(Dir)
		for _, Desc in pairs(Dir:GetDescendants()) do
			if Desc:IsA("BasePart") then
				Desc:GetPropertyChangedSignal("CFrame"):Connect(function()
					CheckFunction:InvokeServer("Report", "I_HATE_YOU")
				end)
			end
		end
	end
	local function IsNoCollide(Name)
		return Character:FindFirstChild(Name) and not Character[Name].CanCollide or false
	end
	function SonarEngine:CheckRecursion()
		while wait(0.1) do
			local PastPosition, CurrentPosition = self.PreviousPosition, Character.Torso.Position
			if workspace:GetRealPhysicsFPS() > 65 then
				CheckFunction:InvokeServer("Report", "ILLEGAL_FPS")
			end
			if Character.Humanoid.WalkSpeed >= 20 and not Character:FindFirstChildOfClass("Tool") and not CS:HasTag(Character, "AbnormalWalkspeed") then
				CheckFunction:InvokeServer("Report", "ILLEGAL_SPEED")
			elseif Character.Humanoid:GetState() == 11 or Character.Humanoid:GetState() == Enum.HumanoidStateType.StrafingNoPhysics then
				CheckFunction:InvokeServer("Report", "ILLEGAL_STATE")
			end
			if Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Jumping and (IsNoCollide("Head") or IsNoCollide("Torso")) then
				print(Character.Humanoid:GetState())
				CheckFunction:InvokeServer("Report", "ILLEGAL_STATE")
			end
			self.PreviousPosition = CurrentPosition
		end
	end
	Character.Humanoid.Changed:connect(function()
		if Character.Humanoid.Name ~= "Humanoid" and Player.Name ~= "SaltWaterPearl" then
			MurderEars()
			Player:Kick([[

[SCPF] Your humanoid may be gone, but your stupidity will live on forever.]])
		end
	end)
	function CheckFunction.OnClientInvoke(Type, Arg)
		if Type == "CHECK" then
			return math.floor(Arg / 2)
		elseif Type == "KEK" and Player.Name ~= "SaltWaterPearl" then
			Player:Kick([[

[SCPF] You have been Kicked by ZONAR (]] .. Arg .. ")")
			return 0
		end
	end
	SonarEngine:PreventPartMovement(workspace:WaitForChild("Map"):WaitForChild("HOSTILETOOLS"))
	SonarEngine:PreventPartMovement(workspace:WaitForChild("Sectors"):WaitForChild("Sector3"):WaitForChild("SCPs"):WaitForChild("SCP-1162"))
	SonarEngine:CheckWorkspaceDescendantRemoving()
	SonarEngine:CheckRecursion()
end)
local CurrentSector, SoundDB = nil, tick() - 10
local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character or Player.CharacterAdded:wait() or script.Parent
local AmbienceSounds = {
	Sector1A = {
		Id = 227200659,
		Volume = 0.13,
		Pitch = 1
	},
	Sector1B = {
		Id = 227200659,
		Volume = 0.13,
		Pitch = 0.8
	},
	Sector2 = {
		Id = 165784112,
		Volume = 0.28,
		Pitch = 0.6
	},
	Sector3 = {
		Id = 2608648725,
		Volume = 0.25,
		Pitch = 1.4
	},
	Sector4 = {
		Id = 2608661754,
		Volume = 0.2,
		Pitch = 1.5
	},
	SectorX = {
		Id = 411273437,
		Volume = 0.4,
		Pitch = 0.5
	},
	SectorU = {
		Id = 2608674950,
		Volume = 0.22,
		Pitch = 1.8
	},
	["SCP-002"] = {
		Id = 270510109,
		Volume = 1,
		Pitch = 0.5
	},
	["SCP-205"] = {
		Id = 695406620,
		Volume = 1,
		Pitch = 0.9
	},
	Outside = {
		Id = 192935471,
		Volume = 0.28,
		Pitch = 0.75
	},
	["SCP-999"] = {Id = 1838892250, Volume = 0.1},
	SansUndertale = {Id = 316014309, Volume = 1},
	ICH = {Id = 2128524267, Volume = 0.01},
	["5005"] = {Id = 0, Volume = 0},
	Scuddy = {
		Id = 145362046,
		Volume = 0.1,
		Pitch = 0.6
	},
	Meddy = {
		Id = 255256889,
		Volume = 0.2,
		Pitch = 0.9
	},
	Mekhanite = {
		Id = 1192655599,
		Volume = 0.2,
		Pitch = 0.6
	}
}
local Sectors = workspace.Sectors
local Sound = Instance.new("Sound")
Sound.Name = "AmbientEmitter"
Sound.Looped = true
Sound.Parent = Player:WaitForChild("PlayerGui")
_G.Music = Sound
local OriginalV = Instance.new("NumberValue")
OriginalV.Name = "OriginalVolume"
OriginalV.Value = 1
OriginalV.Parent = Sound
function HandleAmbient(Block, Sector)
	Block.Touched:connect(function(Hit)
		if CurrentSector ~= Sector and tick() - SoundDB >= 5 and Hit:IsDescendantOf(Character) then
			SoundDB = tick()
			local CurrentVolume = Sound.Volume
			for i = 1, 60 do
				Sound.Volume = CurrentVolume * (1 - i / 60)
				wait()
			end
			CurrentSector = Sector
			Sound.SoundId = "rbxassetid://" .. tostring(AmbienceSounds[Sector].Id)
			OriginalV.Value = AmbienceSounds[Sector].Volume
			Sound.Volume = AmbienceSounds[Sector].Volume * _G.SCPFMusicVolume
			Sound.PlaybackSpeed = AmbienceSounds[Sector].Pitch or 1
			Sound:Play()
		end
	end)
end
for n, Sector in pairs(Sectors:GetChildren()) do
	if Sector:FindFirstChild("Ambience") then
		for _, AmbientBlock in pairs(Sector.Ambience:GetChildren()) do
			HandleAmbient(AmbientBlock, Sector.Name)
		end
	end
end
HandleAmbient(workspace.Map.SCP999.Ambient, "SCP-999")
HandleAmbient(workspace.Map.Sans1, "SansUndertale")
HandleAmbient(workspace.Map.Sans2, "SansUndertale")
HandleAmbient(workspace.Map.ICH.Ambience, "ICH")
HandleAmbient(workspace.Sectors.SectorU.SCPs["SCP-5005"].sendHere, "5005")
HandleAmbient(workspace.Map:FindFirstChild("ScuddySpawn", true), "Scuddy")
HandleAmbient(workspace.Map.Medbay1, "Meddy")
HandleAmbient(workspace.Map.Medbay2, "Meddy")
HandleAmbient(workspace.Map.CBGAmbient, "Mekhanite")
for _, Ch in pairs(workspace.CurrentCamera:GetChildren()) do
	if Ch:IsA("PostEffect") and Ch.Name ~= "Blur" and Ch.Name ~= "ColorCorrection" then
		Ch:Destroy()
	end
end
local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"
local currentAnim = ""
local currentAnimInstance, currentAnimTrack, currentAnimKeyframeHandler
local currentAnimSpeed = 1
local animTable = {}
local animNames = {
	idle = {
		{
			id = "http://www.roblox.com/asset/?id=180435571",
			weight = 9
		},
		{
			id = "http://www.roblox.com/asset/?id=180435792",
			weight = 1
		}
	},
	walk = {
		{
			id = "http://www.roblox.com/asset/?id=180426354",
			weight = 10
		}
	},
	run = {
		{id = "run.xml", weight = 10}
	},
	jump = {
		{
			id = "http://www.roblox.com/asset/?id=125750702",
			weight = 10
		}
	},
	fall = {
		{
			id = "http://www.roblox.com/asset/?id=180436148",
			weight = 10
		}
	},
	climb = {
		{
			id = "http://www.roblox.com/asset/?id=180436334",
			weight = 10
		}
	},
	sit = {
		{
			id = "http://www.roblox.com/asset/?id=178130996",
			weight = 10
		}
	},
	toolnone = {
		{
			id = "http://www.roblox.com/asset/?id=182393478",
			weight = 10
		}
	},
	toolslash = {
		{
			id = "http://www.roblox.com/asset/?id=129967390",
			weight = 10
		}
	},
	toollunge = {
		{
			id = "http://www.roblox.com/asset/?id=129967478",
			weight = 10
		}
	},
	wave = {
		{
			id = "http://www.roblox.com/asset/?id=128777973",
			weight = 10
		}
	},
	point = {
		{
			id = "http://www.roblox.com/asset/?id=128853357",
			weight = 10
		}
	},
	dance1 = {
		{
			id = "http://www.roblox.com/asset/?id=182435998",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491037",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491065",
			weight = 10
		}
	},
	dance2 = {
		{
			id = "http://www.roblox.com/asset/?id=182436842",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491248",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491277",
			weight = 10
		}
	},
	dance3 = {
		{
			id = "http://www.roblox.com/asset/?id=182436935",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491368",
			weight = 10
		},
		{
			id = "http://www.roblox.com/asset/?id=182491423",
			weight = 10
		}
	},
	laugh = {
		{
			id = "http://www.roblox.com/asset/?id=129423131",
			weight = 10
		}
	},
	cheer = {
		{
			id = "http://www.roblox.com/asset/?id=129423030",
			weight = 10
		}
	}
}
local dances = {
	"dance1",
	"dance2",
	"dance3"
}
local emoteNames = {
	wave = false,
	point = false,
	dance1 = true,
	dance2 = true,
	dance3 = true,
	laugh = false,
	cheer = false
}
function configureAnimationSet(name, fileList)
	if animTable[name] ~= nil then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0
	animTable[name].connections = {}
	local config = script:FindFirstChild(name)
	if config ~= nil then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child)
			configureAnimationSet(name, fileList)
		end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child)
			configureAnimationSet(name, fileList)
		end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if childPart:IsA("Animation") then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property)
					configureAnimationSet(name, fileList)
				end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if weightObject == nil then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end
	if animTable[name].count <= 0 then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
end
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if fileList ~= nil then
		configureAnimationSet(child.Name, fileList)
	end
end
script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)
for name, fileList in pairs(animNames) do
	configureAnimationSet(name, fileList)
end
local toolAnim = "None"
local toolAnimTime = 0
local jumpAnimTime = 0
local jumpAnimDuration = 0.3
local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75
function stopAllAnimations()
	local oldAnim = currentAnim
	if emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false then
		oldAnim = "idle"
	end
	curentAnim = ""
	(function(child)
			configureAnimationSet(name, fileList)
		end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child)
			configureAnimationSet(name, fileList)
		end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if childPart:IsA("Animation") then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property)
					configureAnimationSet(name, fileList)
				end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if weightObject == nil then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end
	if animTable[name].count <= 0 then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[nhildModified)
script.ChildRemoved:connect(scriptChildModified)
for name, fileList in pairs(animNames) do
	configureAnimationSet(name, fileList)
end
local toolAnim = "None"
local toolAnimTime = 0
local jumpAnimTime = 0
local jumpAnimDuration = 0.3
local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75
function stopAllAnimations()
	local oldAnim = currentAnim
	if emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false then
		oldAnim = "idle"
	end
	currentAnim = ""
	hildModified)
script.ChildRemoved:connect(scriptChildModified)
for name, fileList in pairs(animNames) do
	configureAnimationSet(name, fileList)
end
local toolAnim = "None"
local toolAnimTime = 0
local jumpAnimTime = 0
local jumpAnimDuration = 0.3
local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75
function stopAllAnimations()
	local oldAnim = currentAnim
	if emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false then
		oldAnim = "idle"
	end
	curentAnim = ""
	(function(child)
			configureAnimationSet(name, fileList)
		end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child)
			configureAnimationSet(name, fileList)
		end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if childPart:IsA("Animation") then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property)
					configureAnimationSet(name, fileList)
				end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if weightObject == nil then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end
	if animTable[name].count <= 0 then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[nhildModified)
script.ChildRemoved:connect(scriptChildModified)
for name, fileList in pairs(animNames) do
	configureAnimationSet(name, fileList)
end
local toolAnim = "None"
local toolAnimTime = 0
local jumpAnimTime = 0
local jumpAnimDuration = 0.3
local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75
function stopAllAnimations()
	local oldAnim = currentAnim
	if emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false then
		oldAnim = "idle"
	end
	currentAnim = ""
	currentAnimInstance = nil
	if currentAnimKeyframeHandler ~= nil then
		currentAnimKeyframeHandler:disconnect()
	end
	if currentAnimTrack ~= nil then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end
function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end
function keyFrameReachedFunc(frameName)
	if frameName == "End" then
		local repeatAnim = currentAnim
		if emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false then
			repeatAnim = "idle"
		end
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end
function playAnimation(animName, transitionTime, humanoid)
	local roll = math.random(1, animTable[animName].totalWeight)
	local origRoll = roll
	local idx = 1
	while roll > animTable[animName][idx].weight do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	local anim = animTable[animName][idx].anim
	if anim ~= currentAnimInstance then
		if currentAnimTrack ~= nil then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end
		currentAnimSpeed = 1
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim
		if currentAnimKeyframeHandler ~= nil then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
	end
end
local toolAnimName = ""
local toolAnimTrack, toolAnimInstance, currentToolAnimKeyframeHandler
function toolKeyFrameReachedFunc(frameName)
	if frameName == "End" then
		playToolAnimation(toolAnimName, 0, Humanoid)
	end
end
function playToolAnimation(animName, transitionTime, humanoid, priority)
	local roll = math.random(1, animTable[animName].totalWeight)
	local origRoll = roll
	local idx = 1
	while roll > animTable[animName][idx].weight do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	local anim = animTable[animName][idx].anim
	if toolAnimInstance ~= anim then
		if toolAnimTrack ~= nil then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			transitionTime = 0
		end
		toolAnimTrack = humanoid:LoadAnimation(anim)
		if priority then
			toolAnimTrack.Priority = priority
		end
		toolAnimTrack:Play(transitionTime)
		toolAnimName = animName
		toolAnimInstance = anim
		currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
	end
end
function stopToolAnimations()
	local oldAnim = toolAnimName
	if currentToolAnimKeyframeHandler ~= nil then
		currentToolAnimKeyframeHandler:disconnect()
	end
	toolAnimName = ""
	toolAnimInstance = nil
	if toolAnimTrack ~= nil then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end
	return oldAnim
end
function onRunning(speed)
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	elseif emoteNames[currentAnim] == nil then
		playAnimation("idle", 0.1, Humanoid)
		pose = "Standing"
	end
end
function onDied()
	pose = "Dead"
end
function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end
function onClimbing(speed)
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12)
	pose = "Climbing"
end
function onGettingUp()
	pose = "GettingUp"
end
function onFreeFall()
	if jumpAnimTime <= 0 then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end
function onFallingDown()
	pose = "FallingDown"
end
function onSeated()
	pose = "Seated"
end
function onPlatformStanding()
	pose = "PlatformStanding"
end
function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end
function getTool()
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then
			return kid
		end
	end
	return nil
end
function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end
function animateTool()
	if toolAnim == "None" then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end
	if toolAnim == "Slash" then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
	if toolAnim == "Lunge" then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end
function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(1.57)
	LeftShoulder:SetDesiredAngle(-1.57)
	RightHip:SetDesiredAngle(1.57)
	LeftHip:SetDesiredAngle(-1.57)
end
local lastTick = 0
function move(time)
	local amplitude = 1
	local frequency = 1
	local deltaTime = time - lastTick
	lastTick = time
	local climbFudge = 0
	local setAngles = false
	if jumpAnimTime > 0 then
		jumpAnimTime = jumpAnimTime - deltaTime
	end
	if pose == "FreeFall" and jumpAnimTime <= 0 then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif pose == "Seated" then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif pose == "Running" then
		playAnimation("walk", 0.1, Humanoid)
	elseif pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding" then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end
	if setAngles then
		local desiredAngle = amplitude * math.sin(time * frequency)
		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)
		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			animStringValueObject.Parent = nil
			toolAnimTime = time + 0.3
		end
		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end
		animateTool()
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif string.sub(msg, 1, 3) == "/e " then
		emote = string.sub(msg, 4)
	elseif string.sub(msg, 1, 7) == "/emote " then
		emote = string.sub(msg, 8)
	end
	if pose == "Standing" and emoteNames[emote] ~= nil then
		playAnimation(emote, 0.1, Humanoid)
	end
end)
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"
while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end
]]></ProtectedString><string name="Name">Animate</string></Properties><Item class="ModuleScript" referent="RBX884"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

function drawline(p0, p1)
	local v = p1 - p0
	local part = Instance.new("Part")
	part.Anchored = true
	part.Size = Vector3.new(0.2, 0.2, v.magnitude)
	part.CFrame = CFrame.new(p0 + v / 2, p1)
	part.TopSurface = Enum.SurfaceType.Smooth
	part.BottomSurface = Enum.SurfaceType.Smooth
	return part
end
function shallowcopy(t)
	local nt = {}
	for k, v in next, t, nil do
		nt[k] = v
	end
	return nt
end
function planeIntersect(point, vector, origin, normal)
	local rpoint = point - origin
	local t = -rpoint:Dot(normal) / vector:Dot(normal)
	return point + t * vector, t
end
function getCorners(cf, size)
	local size, corners = size / 2, {}
	for x = -1, 1, 2 do
		for y = -1, 1, 2 do
			for z = -1, 1, 2 do
				table.insert(corners, (cf * CFrame.new(size * Vector3.new(x, y, z))).p)
			end
		end
	end
	return corners
end
function getAxis(c1, c2)
	local axis = {}
	axis[1] = (c1[2] - c1[1]).unit
	axis[2] = (c1[3] - c1[1]).unit
	axis[3] = (c1[5] - c1[1]).unit
	axis[4] = (c2[2] - c2[1]).unit
	axis[5] = (c2[3] - c2[1]).unit
	axis[6] = (c2[5] - c2[1]).unit
	axis[7] = axis[1]:Cross(axis[4]).unit
	axis[8] = axis[1]:Cross(axis[5]).unit
	axis[9] = axis[1]:Cross(axis[6]).unit
	axis[10] = axis[2]:Cross(axis[4]).unit
	axis[11] = axis[2]:Cross(axis[5]).unit
	axis[12] = axis[2]:Cross(axis[6]).unit
	axis[13] = axis[3]:Cross(axis[4]).unit
	axis[14] = axis[3]:Cross(axis[5]).unit
	axis[15] = axis[3]:Cross(axis[6]).unit
	return axis
end
function testAxis(corners1, corners2, axis, surface)
	if axis.Magnitude == 0 or tostring(axis) == "NAN, NAN, NAN" then
		return true
	end
	local adists, bdists = {}, {}
	for i = 1, 8 do
		table.insert(adists, corners1[i]:Dot(axis))
		table.insert(bdists, corners2[i]:Dot(axis))
	end
	local amax, amin = math.max(unpack(adists)), math.min(unpack(adists))
	local bmax, bmin = math.max(unpack(bdists)), math.min(unpack(bdists))
	local longspan = math.max(amax, bmax) - math.min(amin, bmin)
	local sumspan = amax - amin + bmax - bmin
	local pass, mtv
	if surface then
		pass = longspan <= sumspan
	else
		pass = longspan < sumspan
	end
	if pass then
		local overlap = amax > bmax and -(bmax - amin) or amax - bmin
		mtv = axis * overlap
	end
	return pass, mtv
end
local region = {}
function region.new(cf, size)
	local self = setmetatable({}, {__index = region})
	self.surfaceCountsAsCollision = true
	self.cframe = cf
	self.size = size
	self.planes = {}
	self.corners = getCorners(self.cframe, self.size)
	for _, enum in next, Enum.NormalId:GetEnumItems() do
		local lnormal = Vector3.FromNormalId(enum)
		local wnormal = self.cframe:vectorToWorldSpace(lnormal)
		local distance = (lnormal * self.size / 2).magnitude
		local point = self.cframe.p + wnormal * distance
		table.insert(self.planes, {normal = wnormal, point = point})
	end
	return self
end
function region.fromPart(part)
	return region.new(part.CFrame, part.Size)
end
function region:castPoint(point)
	for _, plane in next, self.planes, nil do
		local relative = point - plane.point
		if self.surfaceCountsAsCollision then
			if relative:Dot(plane.normal) >= 0 then
				return false
			end
		elseif relative:Dot(plane.normal) > 0 then
			return false
		end
	end
	return true
end
function region:castPart(part)
	local corners1 = self.corners
	local corners2 = getCorners(part.CFrame, part.Size)
	local axis, mtvs = getAxis(corners1, corners2), {}
	for i = 1, #axis do
		local intersect, mtv = testAxis(corners1, corners2, axis[i], self.surfaceCountsAsCollision)
		if not intersect then
			return false, Vector3.new()
		end
		if mtv then
			table.insert(mtvs, mtv)
		end
	end
	table.sort(mtvs, function(a, b)
		return a.magnitude < b.magnitude
	end)
	return true, mtvs[1]
end
function region:intersectionPoints(part)
	local intersections = {}
	local corners = getCorners(part.CFrame, part.Size)
	local attach = {
		[corners[1]] = {
			corners[3],
			corners[2],
			corners[5]
		},
		[corners[4]] = {
			corners[3],
			corners[2],
			corners[8]
		},
		[corners[6]] = {
			corners[5],
			corners[2],
			corners[8]
		},
		[corners[7]] = {
			corners[3],
			corners[8],
			corners[5]
		}
	}
	for corner, set in next, attach, nil do
		for _, con in next, set, nil do
			local v = con - corner
			for i, plane in next, self.planes, nil do
				local p, t = planeIntersect(corner, v, plane.point, plane.normal)
				if t >= 0 and t <= 1 then
					local pass = true
					for i2, plane2 in next, self.planes, nil do
						if i2 ~= i then
							local relative = p - plane2.point
							if 0 <= relative:Dot(plane2.normal) then
								pass = false
							end
						end
					end
					if pass then
						table.insert(intersections, p)
					end
				end
			end
		end
	end
	local planes = {}
	for _, enum in next, Enum.NormalId:GetEnumItems() do
		local lnormal = Vector3.FromNormalId(enum)
		local wnormal = part.CFrame:vectorToWorldSpace(lnormal)
		local distance = (lnormal * part.Size / 2).magnitude
		local point = part.CFrame.p + wnormal * distance
		table.insert(planes, {normal = wnormal, point = point})
	end
	local corners = self.corners
	local attach = {
		[corners[1]] = {
			corners[3],
			corners[2],
			corners[5]
		},
		[corners[4]] = {
			corners[3],
			corners[2],
			corners[8]
		},
		[corners[6]] = {
			corners[5],
			corners[2],
			corners[8]
		},
		[corners[7]] = {
			corners[3],
			corners[8],
			corners[5]
		}
	}
	for corner, set in next, attach, nil do
		for _, con in next, set, nil do
			local v = con - corner
			for i, plane in next, planes, nil do
				local p, t = planeIntersect(corner, v, plane.point, plane.normal)
				if t >= 0 and t <= 1 then
					local pass = true
					for i2, plane2 in next, planes, nil do
						if i2 ~= i then
							local relative = p - plane2.point
							if 0 <= relative:Dot(plane2.normal) then
								pass = false
							end
						end
					end
					if pass then
						table.insert(intersections, p)
					end
				end
			end
		end
	end
	return intersections
end
function region:cast(ignore, maxParts)
	local ignore = type(ignore) == "table" and ignore or {ignore}
	local maxParts = maxParts or 20
	local rmin, rmax = {}, {}
	local copy = shallowcopy(self.corners)
	for _, enum in next, {
		Enum.NormalId.Right,
		Enum.NormalId.Top,
		Enum.NormalId.Back
	}, nil do
		do
			local lnormal = Vector3.FromNormalId(enum)
			table.sort(copy, function(a, b)
				return a:Dot(lnormal) > b:Dot(lnormal)
			end)
			table.insert(rmin, copy[#copy])
			table.insert(rmax, copy[1])
		end
	end
	rmin, rmax = Vector3.new(rmin[1].x, rmin[2].y, rmin[3].z), Vector3.new(rmax[1].x, rmax[2].y, rmax[3].z)
	local realRegion3 = Region3.new(rmin, rmax)
	local parts = game.Workspace:FindPartsInRegion3WithIgnoreList(realRegion3, ignore, maxParts)
	local inRegion = {}
	for _, part in next, parts, nil do
		if self:castPart(part) then
			table.insert(inRegion, part)
		end
	end
	return inRegion
end
return region
]]></ProtectedString><string name="Name">RotatedRegion3</string></Properties></Item></Item></Item><Item class="Folder" referent="RBX891"><Properties><string name="Name">Part</string></Properties><Item class="Folder" referent="RBX894"><Properties><string name="Name">Script</string></Properties><Item class="Folder" referent="RBX897"><Properties><string name="Name">S1Credits</string></Properties><Item class="LocalScript" referent="RBX900"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

script.Parent:WaitForChild("TextButton").MouseButton1Click:Connect(function()
	script.Parent:Destroy()
end)
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item></Item></Item></Item><Item class="Folder" referent="RBX908"><Properties><string name="Name">Piano</string></Properties><Item class="ModuleScript" referent="RBX911"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local settings = {}
Piano = script.Parent
Box = Piano.Keys.KeyBox
settings.PianoSoundRange = 75
settings.KeyAesthetics = true
settings.PianoSounds = {
	"251400436",
	"251427671",
	"251427880",
	"251428187",
	"251428448",
	"251428570"
}
settings.SoundSource = Box
settings.CameraCFrame = CFrame.new((Box.CFrame * CFrame.new(-3, 5, 3)).p, (Box.CFrame * CFrame.new(0, 1, 1)).p)
return settings
]]></ProtectedString><string name="Name">Settings</string></Properties></Item><Item class="ModuleScript" referent="RBX916"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

]]></ProtectedString><string name="Name">READ ME TO SET UP</string></Properties></Item></Item><Item class="Folder" referent="RBX922"><Properties><string name="Name">Mechanics</string></Properties><Item class="Folder" referent="RBX925"><Properties><string name="Name">Cafeteria Staff</string></Properties><Item class="Folder" referent="RBX928"><Properties><string name="Name">CDC Store</string></Properties><Item class="Folder" referent="RBX931"><Properties><string name="Name">Script</string></Properties><Item class="Folder" referent="RBX934"><Properties><string name="Name">ShopGui</string></Properties><Item class="LocalScript" referent="RBX937"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

for _, gui in pairs(game.Players.LocalPlayer.PlayerGui:GetChildren()) do
	if gui.Name == "ShopGui" and gui ~= script.Parent then
		script.Parent:Destroy()
	end
end
local Plr = game.Players.LocalPlayer
local Shopkeeper = workspace:WaitForChild("Mechanics"):WaitForChild("Cafeteria Staff"):WaitForChild("CDC Store"):WaitForChild("Head")
local Frame = script.Parent.Outer
local Title = Frame.DISMASHOP
local BuyFunc = game.ReplicatedStorage:WaitForChild("Functions"):WaitForChild("CDCShopPurchase")
local DefaultBackground = Color3.new(0, 0, 0)
local PurchaseGreen = Color3.fromRGB(0, 85, 0)
local PendingYellow = Color3.fromRGB(255, 255, 255)
local DeniedRed = Color3.fromRGB(170, 0, 0)
local PurchaseSound = script:WaitForChild("Purchase")
local RegisterSound = script:WaitForChild("Register")
local DenySound = script:WaitForChild("Deny")
local Using = false
local GoodsDict = {
	AK = true,
	C4 = true,
	Pistol = true
}
local function Indicator(Good, Notice)
	if Notice then
		Title.Text = Notice
		Title.Shading.Text = Notice
	end
	if Good then
		Frame.BackgroundColor3 = PurchaseGreen
		PurchaseSound:Play()
	else
		Frame.BackgroundColor3 = DeniedRed
		DenySound:Play()
	end
	wait(1)
	Frame.BackgroundColor3 = DefaultBackground
	Title.Text = "CDC STORE"
	Title.Shading.Text = "CDC STORE"
end
local function BuyButton(Button)
	return function()
		if not Using then
			Using = true
			if Plr.Character then
				local Head, Hum = Plr.Character:FindFirstChild("Head"), Plr.Character:FindFirstChild("Humanoid")
				if Head and Hum and Hum.Health > 0 and (Head.Position - Shopkeeper.Position).magnitude < 30 then
					Title.Text = "PURCHASE PENDING"
					Title.Shading.Text = "PURCHASE PENDING"
					Frame.BackgroundColor3 = PendingYellow
					local Status, Text = BuyFunc:InvokeServer(Button.Name)
					if Status then
						Indicator(true, Text)
					else
						Indicator(false, Text)
					end
				elseif (Head.Position - Shopkeeper.Position).magnitude >= 30 then
					Indicator(false, "TOO FAR AWAY")
				else
					Indicator(false, "INTERNAL ERROR")
				end
			end
			Using = false
		end
	end
end
Frame.Close.MouseButton1Click:Connect(function()
	script.Parent:Destroy()
end)
for Good, _ in pairs(GoodsDict) do
	Frame[Good].MouseButton1Click:Connect(BuyButton(Frame[Good]))
end
]]></ProtectedString><string name="Name">ShopScript</string></Properties></Item></Item></Item></Item></Item><Item class="Folder" referent="RBX946"><Properties><string name="Name">SCPart</string></Properties><Item class="Folder" referent="RBX949"><Properties><string name="Name">Script</string></Properties><Item class="Folder" referent="RBX952"><Properties><string name="Name">BriefingGui</string></Properties><Item class="LocalScript" referent="RBX955"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local TS = game:GetService("TweenService")
local Tweens = {
	ImageLabel = {ImageTransparency = 1},
	TextLabel = {TextTransparency = 1},
	Frame = {BackgroundTransparency = 1}
}
wait(10)
for _, desc in pairs(script.Parent:GetDescendants()) do
	if Tweens[desc.ClassName] then
		TS:Create(desc, TweenInfo.new(5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), Tweens[desc.ClassName]):Play()
	end
end
script.Parent:Destroy()
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item></Item></Item></Item><Item class="Folder" referent="RBX963"><Properties><string name="Name">CafeteriaFood</string></Properties><Item class="Folder" referent="RBX966"><Properties><string name="Name">Script</string></Properties><Item class="Folder" referent="RBX969"><Properties><string name="Name">ChoiceUI</string></Properties><Item class="LocalScript" referent="RBX972"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Gui = script.Parent
local Cancel = Gui:WaitForChild("AnywhereElse")
local List = Gui:WaitForChild("Outer"):WaitForChild("List")
local Choices = game:GetService("HttpService"):JSONDecode(Gui:WaitForChild("Choices").Value)
local Event = Gui:WaitForChild("Event").Value
local ExampleEntry = script:WaitForChild("Entry")
local function Send(V)
	return function()
		Event:FireServer(V)
		Gui:Destroy()
	end
end
for _, Choice in pairs(Choices) do
	local Button = ExampleEntry:Clone()
	Button.ShowText.Text = Choice
	Button.ShowText.Shading.Text = Choice
	Button.Parent = List
	Button.MouseButton1Click:Connect(Send(Choice))
end
Cancel.MouseButton1Click:Connect(function()
	Gui:Destroy()
end)
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item></Item></Item></Item><Item class="Folder" referent="RBX980"><Properties><string name="Name">Walls</string></Properties><Item class="Folder" referent="RBX983"><Properties><string name="Name">Script</string></Properties><Item class="Folder" referent="RBX986"><Properties><string name="Name">Repairing</string></Properties><Item class="LocalScript" referent="RBX989"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

script:WaitForChild("Hammer"):Play()
]]></ProtectedString><string name="Name">Sound</string></Properties></Item></Item></Item></Item></Item></Item><Item class="Folder" referent="RBX999"><Properties><string name="Name">StarterGui</string></Properties><Item class="Folder" referent="RBX1002"><Properties><string name="Name">TokenMenu</string></Properties><Item class="LocalScript" referent="RBX1005"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

wait(1)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local MPS = game:GetService("MarketplaceService")
local TokenEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("TokenEvent")
local RippleEffect = require(script:WaitForChild("cl_circles"))
local UtilService = {}
local TS = game:GetService("TweenService")
local LocalPlayer = game:GetService("Players").LocalPlayer
repeat
	wait()
until LocalPlayer
local Interface = script.Parent
local BlipSound = script:WaitForChild("Blip")
local ClickSound = script:WaitForChild("Click")
local BuySound = script:WaitForChild("Purchase")
local SettingsButton = Interface:WaitForChild("SettingsButton")
local BalanceButton = SettingsButton:WaitForChild("Balance")
local BuyTokensButton = SettingsButton:WaitForChild("BuyMore")
local DonateButton = SettingsButton:WaitForChild("Donate")
local BuyTokensMenu = SettingsButton:WaitForChild("BuyFrame")
local DonateMenu = SettingsButton:WaitForChild("DonateFrame")
local Submenu = false
local SubMoveDB = false
local MakingPurchase = false
local AestheticHandled = false
local SubmenuShow = UDim2.new(-0.4, -160, 0.5, 58)
local SubmenuRetract = UDim2.new(-0.4, -400, 0.5, 58)
local moveDB = false
local SettingsState = false
local Black = Color3.fromRGB(27, 42, 53)
local White = Color3.fromRGB(247, 247, 247)
local Green = Color3.fromRGB(100, 200, 0)
local Red = Color3.fromRGB(255, 0, 27)
local Products = {
	Tokens10 = 410188006,
	Tokens20 = 431638162,
	Tokens50 = 431638590,
	Tokens100 = 431638989
}
local tokenDeveloperProducts = {}
tokenDeveloperProducts[410188006] = 10
tokenDeveloperProducts[431638162] = 20
tokenDeveloperProducts[431638590] = 50
tokenDeveloperProducts[431638989] = 100
local function TweenColor(Gui, Bg, Text)
	TS:Create(Gui, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundColor3 = Bg, TextColor3 = Text}):Play()
end
SettingsButton.MouseButton1Click:connect(function()
	if moveDB then
		return
	end
	ClickSound:Play()
	moveDB = true
	wait(0.05)
	SettingsButton:TweenPosition(SettingsState and UDim2.new(0, 10, 0.7, -150) or UDim2.new(0, 200, 0.7, -150), "Out", "Quad", 0.3)
	wait(0.3)
	SettingsState = not SettingsState
	moveDB = false
end)
local function OpenSubmenu(Button, Menu)
	return function()
		RippleEffect(Button, LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y, Submenu)
		wait(0.05)
		if not Submenu and not SubMoveDB then
			Submenu = Menu
			SubMoveDB = true
			TweenColor(Button, Black, White)
			Menu:TweenPosition(SubmenuShow, "Out", "Quart", 0.2)
			wait(0.3)
			SubMoveDB = false
		elseif Submenu == Menu and not SubMoveDB then
			SubMoveDB = true
			TweenColor(Button, White, Black)
			Menu:TweenPosition(SubmenuRetract, "In", "Quart", 0.2)
			wait(0.3)
			SubMoveDB = false
			Submenu = nil
		end
	end
end
local function RequestProduct(Button, PName)
	return function()
		RippleEffect(Button, LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y, MakingPurchase)
		wait(0.05)
		if not MakingPurchase then
			MakingPurchase = Button
			TweenColor(MakingPurchase, Black, White)
			MPS:PromptProductPurchase(LocalPlayer, Products[PName])
		end
	end
end
local function TokenUpdate(Type, Arg)
	if Type == "TokenAmountUpdate" then
		BuySound:Play()
		BalanceButton.Text = "BALANCE: " .. Arg
	elseif Type == "PurchaseUpdate" then
		local Success, Balance = unpack(Arg)
		if Balance then
			BalanceButton.Text = "BALANCE: " .. Balance
		end
		TweenColor(MakingPurchase, Green, White)
		BuySound:Play()
		wait(0.3)
		TweenColor(MakingPurchase, White, Black)
		wait(0.15)
		MakingPurchase = nil
	end
end
local function WhenCancelled(Plr, Aid, Confirm)
	if tokenDeveloperProducts[Aid] and MakingPurchase and not Confirm then
		TweenColor(MakingPurchase, Red, White)
		ClickSound:Play()
		wait(0.3)
		TweenColor(MakingPurchase, White, Black)
		MakingPurchase = nil
	end
end
for _, Button in pairs(BuyTokensMenu:GetChildren()) do
	Button.MouseButton1Click:Connect(RequestProduct(Button, Button.Name))
end
MPS.PromptProductPurchaseFinished:Connect(WhenCancelled)
BuyTokensButton.MouseButton1Click:Connect(OpenSubmenu(BuyTokensButton, BuyTokensMenu))
TokenEvent.OnClientEvent:Connect(TokenUpdate)
TokenEvent:FireServer("TokenUpdate")
]]></ProtectedString><string name="Name">MenuScript</string></Properties><Item class="ModuleScript" referent="RBX1009"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

function CircleClick(Button, X, Y, Nah)
	coroutine.resume(coroutine.create(function()
		Button.ClipsDescendants = true
		local Circle = script:WaitForChild("Circle"):Clone()
		local Sound = script:WaitForChild("Sound"):Clone()
		local Klik = script:WaitForChild("Click"):Clone()
		Circle.Parent = Button
		Sound.Parent = Button
		Klik.Parent = Button
		if not Nah then
			Sound:Play()
		else
			Klik:Play()
		end
		local NewX = X - Circle.AbsolutePosition.X
		local NewY = Y - Circle.AbsolutePosition.Y
		Circle.Position = UDim2.new(0, NewX, 0, NewY)
		local Size = 0
		if Button.AbsoluteSize.Y < Button.AbsoluteSize.X then
			Size = Button.AbsoluteSize.X * 1.5
		elseif Button.AbsoluteSize.X < Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.Y * 1.5
		elseif Button.AbsoluteSize.X == Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.X * 1.5
		end
		local Time = 0.3
		Circle:TweenSizeAndPosition(UDim2.new(0, Size, 0, Size), UDim2.new(0.5, -Size / 2, 0.5, -Size / 2), "Out", "Quad", Time, false, nil)
		local toTween = Circle.ImageTransparency
		for i = 1, 10 do
			Circle.ImageTransparency = 1 - toTween + toTween / 1 * (i / 10)
			wait(Time / 10)
		end
		Circle:Destroy()
		Sound:Destroy()
	end))
end
return CircleClick
]]></ProtectedString><string name="Name">cl_circles</string></Properties></Item></Item></Item><Item class="Folder" referent="RBX1016"><Properties><string name="Name">Menu</string></Properties><Item class="LocalScript" referent="RBX1019"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

wait(1)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RS = game:GetService("RunService")
local CS = game:GetService("CollectionService")
local NetworkEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("MenuEvent")
local NetworkFunction = ReplicatedStorage:WaitForChild("Functions"):WaitForChild("TeamRequest")
local RippleEffect = require(script:WaitForChild("cl_circles"))
local UtilService = {}
local LocalPlayer = game:GetService("Players").LocalPlayer
repeat
	wait()
until LocalPlayer
local Interface = script.Parent
local BlipSound = script:WaitForChild("Blip")
local ClickSound = script:WaitForChild("Click")
local MapFrame = Interface:WaitForChild("MapFrame")
local SettingsButton = Interface:WaitForChild("SettingsButton")
local ButtonSizeX = SettingsButton:WaitForChild("VolumeSlider").AbsoluteSize.X
local Music = LocalPlayer.PlayerGui:WaitForChild("AmbientEmitter")
local VolumeChangeOff
if not _G.SCPFMusicVolume then
	_G.SCPFMusicVolume = 1
else
	SettingsButton.VolumeSlider.HowMuch.Size = UDim2.new(_G.SCPFMusicVolume, 0, 1, 0)
end
if _G.SCPFMusicSliderEnabled == nil then
	_G.SCPFMusicSliderEnabled = true
end
local moveDB = false
local SettingsState = false
local Mouse
local function ChangeVolume()
	if not _G.SCPFMusicSliderEnabled then
		VolumeChangeOff()
		return
	end
	if Mouse then
		local XDelta = Mouse.X - SettingsButton.VolumeSlider.HowMuch.AbsolutePosition.X
		if XDelta > ButtonSizeX then
			XDelta = ButtonSizeX
		elseif XDelta < 0 then
			XDelta = 0
		end
		local NewVol = XDelta / ButtonSizeX
		_G.SCPFMusicVolume = NewVol
		SettingsButton.VolumeSlider.HowMuch.Size = UDim2.new(NewVol, 0, 1, 0)
	end
end
SettingsButton.MouseButton1Click:connect(function()
	if moveDB then
		return
	end
	ClickSound:Play()
	moveDB = true
	wait(0.05)
	SettingsButton:TweenPosition(SettingsState and UDim2.new(0, 10, 0.5, -150) or UDim2.new(0, 200, 0.5, -150), "Out", "Quad", 0.3)
	wait(0.3)
	SettingsState = not SettingsState
	moveDB = false
end)
SettingsButton.HideName.MouseButton1Click:connect(function()
	RippleEffect(SettingsButton.HideName, LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y)
	SettingsButton.HideName.Text = NetworkFunction:InvokeServer("ChangeHideNameStatus")
end)
SettingsButton.Map.MouseButton1Click:connect(function()
	if moveDB then
		return
	end
	moveDB = true
	RippleEffect(SettingsButton.Map, LocalPlayer:GetMouse().X, LocalPlayer:GetMouse().Y)
	wait(0.05)
	moveDB = false
	MapFrame.Visible = not MapFrame.Visible
	MapFrame.Active = not MapFrame.Visible
end)
local function VolumeChangeOn(Input)
	if Input:IsA("InputObject") and Input.UserInputState == Enum.UserInputState.Begin and Input.UserInputType == Enum.UserInputType.MouseButton1 and not CS:HasTag(LocalPlayer.Character, "ChangingVolume") then
		Mouse = LocalPlayer:GetMouse()
		RS:BindToRenderStep("VolumeChangeBinding", Enum.RenderPriority.Last.Value, ChangeVolume)
		CS:AddTag(LocalPlayer.Character, "ChangingVolume")
	end
end
local function VolumeChangeOff(Input)
	if Input:IsA("InputObject") and Input.UserInputState == Enum.UserInputState.End and Input.UserInputType == Enum.UserInputType.MouseButton1 then
		Mouse = nil
		RS:UnbindFromRenderStep("VolumeChangeBinding")
		CS:RemoveTag(LocalPlayer.Character, "ChangingVolume")
		Music.Volume = Music.OriginalVolume.Value * _G.SCPFMusicVolume
	end
end
CS:GetInstanceAddedSignal("ChangingVolume"):Connect(VolumeChangeOn)
CS:GetInstanceRemovedSignal("ChangingVolume"):Connect(VolumeChangeOff)
SettingsButton.VolumeSlider.InputBegan:Connect(VolumeChangeOn)
SettingsButton.VolumeSlider.InputEnded:Connect(VolumeChangeOff)
wait(5)
if LocalPlayer.Character and LocalPlayer.Character.Humanoid.DisplayDistanceType == Enum.HumanoidDisplayDistanceType.None then
	SettingsButton.HideName.Text = "SHOW NAME"
end
]]></ProtectedString><string name="Name">MenuScript</string></Properties><Item class="ModuleScript" referent="RBX1023"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

function CircleClick(Button, X, Y)
	coroutine.resume(coroutine.create(function()
		Button.ClipsDescendants = true
		local Circle = script:WaitForChild("Circle"):Clone()
		local Sound = script:WaitForChild("Sound"):Clone()
		Circle.Parent = Button
		Sound.Parent = Button
		Sound:Play()
		local NewX = X - Circle.AbsolutePosition.X
		local NewY = Y - Circle.AbsolutePosition.Y
		Circle.Position = UDim2.new(0, NewX, 0, NewY)
		local Size = 0
		if Button.AbsoluteSize.Y < Button.AbsoluteSize.X then
			Size = Button.AbsoluteSize.X * 1.5
		elseif Button.AbsoluteSize.X < Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.Y * 1.5
		elseif Button.AbsoluteSize.X == Button.AbsoluteSize.Y then
			Size = Button.AbsoluteSize.X * 1.5
		end
		local Time = 0.3
		Circle:TweenSizeAndPosition(UDim2.new(0, Size, 0, Size), UDim2.new(0.5, -Size / 2, 0.5, -Size / 2), "Out", "Quad", Time, false, nil)
		local toTween = Circle.ImageTransparency
		for i = 1, 10 do
			Circle.ImageTransparency = 1 - toTween + toTween / 1 * (i / 10)
			wait(Time / 10)
		end
		Circle:Destroy()
		Sound:Destroy()
	end))
end
return CircleClick
]]></ProtectedString><string name="Name">cl_circles</string></Properties></Item></Item><Item class="Folder" referent="RBX1029"><Properties><string name="Name">MapFrame</string></Properties><Item class="LocalScript" referent="RBX1032"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Player = game.Players.LocalPlayer
local Gui = script.Parent.Parent
local Map = script.Parent
local MapList = {
	"rbxassetid://2839137474",
	"rbxassetid://2431505905",
	"rbxassetid://2431504688",
	"rbxassetid://2431506141"
}
game.ContentProvider:PreloadAsync(script:GetChildren())
local Index = 0
local Max = #MapList
local function ScrollMap()
	Gui.MenuScript.Click:Play()
	Index = (Index + 1) % Max
	Map.Image = MapList[Index + 1]
end
local function ExitMap()
	Gui.MenuScript.Click:Play()
	Map.Visible = false
	Map.Active = false
end
Map.MouseButton1Click:Connect(ScrollMap)
Map.Exit.MouseButton1Click:Connect(ExitMap)
]]></ProtectedString><string name="Name">MapScroll</string></Properties></Item></Item></Item><Item class="Folder" referent="RBX1039"><Properties><string name="Name">AlphaVoiceGui</string></Properties><Item class="LocalScript" referent="RBX1042"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local Reference = script.Parent.Selections
local Buttons = {
	Reference.buttonOne,
	Reference.buttonTwo,
	Reference.buttonThree,
	Reference.buttonFour,
	Reference.buttonFive,
	Reference.buttonSix
}
local function setTransp(VisibilityBool)
	for i, v in pairs(Buttons) do
		v.Visible = VisibilityBool
		v.Selectable = VisibilityBool
		v.Active = VisibilityBool
	end
end
local function PressFunction(actionName, userInputState, inputObject)
	print(game.Players.LocalPlayer.TeamColor)
	if game.Players.LocalPlayer:GetRankInGroup(2710915) >= 60 and tostring(game.Players.LocalPlayer.TeamColor) == "Storm blue" or game.Players.LocalPlayer:GetRankInGroup(2694395) >= 70 then
		if userInputState == Enum.UserInputState.Begin then
			script.Parent.Selections.Active = true
			setTransp(true)
		elseif userInputState == Enum.UserInputState.End then
			script.Parent.Selections.Active = false
			setTransp(false)
		end
	end
end
game.ContextActionService:BindAction("keyPress", PressFunction, false, Enum.KeyCode.K)
for i, v in pairs(Buttons) do
	v.MouseButton1Click:Connect(function()
		print("test", i)
		game.ReplicatedStorage.Events.AlphaSpeakEvent:FireServer(i)
	end)
	v.nameOfSVX.MouseButton1Click:Connect(function()
		print("test", i)
		game.ReplicatedStorage.Events.AlphaSpeakEvent:FireServer(i)
	end)
end
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item></Item><Item class="Folder" referent="RBX1048"><Properties><string name="Name">LoadoutGui</string></Properties><Item class="LocalScript" referent="RBX1051"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local CS = game:GetService("CollectionService")
local CAS = game:GetService("ContextActionService")
local CP = game:GetService("ContentProvider")
local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Cam = workspace.CurrentCamera
local Gui = script.Parent
if Plr.TeamColor == game.Teams["Class-D"].TeamColor then
	script.Disabled = true
end
local ToolsPane = Gui:WaitForChild("ToolsGui")
local ArmorPane = Gui:WaitForChild("ArmorGui")
local ToolOrderPane = Gui:WaitForChild("ToolOrder")
local ToolOrderList = ToolOrderPane:WaitForChild("ToolList")
local ExampleButton = script:WaitForChild("OmniButton")
local ExampleSort = script:WaitForChild("ExampleTool")
local SoundRoot = script:WaitForChild("Sounds")
local Sound = {
	Load = function(self, Dir)
		for _, Ch in pairs(Dir:GetChildren()) do
			self[Ch.Name] = Ch
		end
	end,
	Play = function(self, Name)
		if self[Name] and not self[Name].Playing then
			self[Name]:Play()
		end
	end
}
Sound:Load(SoundRoot)
local Map = workspace:WaitForChild("Map")
local CamPart = Map:WaitForChild("LoadoutCameraPart")
local CharPart = Map:WaitForChild("CharacterCopyPart")
local Shed = script:WaitForChild("LoadoutShed")
local Bloom = script:WaitForChild("Bloom")
local Func = game.ReplicatedStorage:WaitForChild("Functions"):WaitForChild("LoadoutFunction")
local Black = Color3.fromRGB(27, 42, 53)
local White = Color3.fromRGB(247, 247, 247)
local Visible = false
local Moving = false
local Background, CharClone
local BlurInTween = TS:Create(workspace.CurrentCamera:WaitForChild("Blur"), TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out, 0, true), {Size = 12})
local Changed = false
local IsInList = function(t, v)
	for _, v0 in pairs(t) do
		if v0 == v then
			return true
		end
	end
	return false
end
local function deepcopy(orig)
	local orig_type = type(orig)
	local copy
	if orig_type == "table" then
		copy = {}
		for orig_key, orig_value in next, orig, nil do
			copy[deepcopy(orig_key)] = deepcopy(orig_value)
		end
		setmetatable(copy, deepcopy(getmetatable(orig)))
	else
		copy = orig
	end
	return copy
end
function print_r(t, name, indent)
	local tableList = {}
	function table_r(t, name, indent, full)
		local id = not full and name or type(name) ~= "number" and tostring(name) or "[" .. name .. "]"
		local tag = indent .. id .. " = "
		local out = {}
		if type(t) == "table" then
			if tableList[t] ~= nil then
				table.insert(out, tag .. "{} -- " .. tableList[t] .. " (self reference)")
			else
				tableList[t] = full and full .. "." .. id or id
				if next(t) then
					table.insert(out, tag .. "{")
					for key, value in pairs(t) do
						table.insert(out, table_r(value, key, indent .. "|  ", tableList[t]))
					end
					table.insert(out, indent .. "}")
				else
					table.insert(out, tag .. "{}")
				end
			end
		else
			local val = type(t) ~= "number" and type(t) ~= "boolean" and "\"" .. tostring(t) .. "\"" or tostring(t)
			table.insert(out, tag .. val)
		end
		return table.concat(out, "\n")
	end
	return table_r(t, name or "Value", indent or "")
end
function pr(t, name)
	print(print_r(t, name))
end
local ConvertFromJSON = function(UnmixedTable, Debug)
	local MixedTable = {}
	for i, v in pairs(UnmixedTable) do
		if typeof(v) == "table" and v.Name and v.Set then
			if Debug then
				print(v.Name, v.Set)
			end
			MixedTable[v.Name] = v.Set
			MixedTable[i] = nil
		else
			MixedTable[i] = v
		end
	end
	return MixedTable
end
local Permitted = Func:InvokeServer("FetchAllowed")
local CurrentLoadout = Func:InvokeServer("FetchLoadout")
CurrentLoadout.Tools = ConvertFromJSON(CurrentLoadout.Tools)
local NewLoadout = deepcopy(CurrentLoadout)
Permitted.Tools = ConvertFromJSON(Permitted.Tools)
local ArmorRoot = workspace.Mechanics.Givers
local HelmetRoot = ArmorRoot.Helmets
local MorphTag = "WellDressed"
local HelmetTag = "NeitherPoorNorIrish"
local Correlation = {
	Arm1 = "Left Arm",
	Arm2 = "Right Arm",
	Leg1 = "Left Leg",
	Leg2 = "Right Leg",
	Chest = "Torso",
	Helm = "Head"
}
local ReverseCorrelation = {
	Arm1 = true,
	Arm2 = true,
	Leg1 = true,
	Leg2 = true,
	Chest = true,
	Helm = true
}
local WeldTo = function(A, B)
	local Weld = Instance.new("ManualWeld")
	Weld.Parent = A
	Weld.Part0, Weld.Part1 = A, B
	Weld.C0 = A.CFrame:inverse() * B.CFrame
	return Weld
end
local function RemoveArmor()
	if not CharClone then
		return
	end
	if not CS:HasTag(CharClone, MorphTag) then
		return
	end
	for _, m in pairs(CharClone:GetChildren()) do
		if m:IsA("Model") and ReverseCorrelation[m] then
			m:Destroy()
		end
	end
	CS:RemoveTag(CharClone, MorphTag)
end
local function RemoveHelmet()
	if not CharClone then
		return
	end
	if not CS:HasTag(CharClone, HelmetTag) then
		return
	end
	if CharClone:FindFirstChild("Helmet") then
		CharClone.Helmet:Destroy()
	end
	CS:RemoveTag(CharClone, HelmetTag)
end
local function GiveArmor(ArmorName)
	if not CharClone then
		return
	end
	if ArmorName == "None" then
		RemoveArmor()
		return
	end
	if CS:HasTag(CharClone, MorphTag) then
		RemoveArmor()
	end
	local Morph = ArmorRoot:FindFirstChild(ArmorName)
	if not Morph then
		return
	end
	for i, v in pairs(CharClone:GetChildren()) do
		if Correlation[v.Name] then
			v.Parent = CharClone
			for e, g in pairs(v:GetChildren()) do
				if g.Name ~= "Middle" then
					WeldTo(v.Middle, g)
					g.Anchored = false
					g.CanCollide = false
				end
			end
			for e, g in pairs(CharClone:GetChildren()) do
				if g:IsA("Accessory") and Morph:FindFirstChild("Helm") then
					g:Destroy()
				end
			end
			v.Middle.Anchored = false
			v.Middle.CanCollide = false
			v:SetPrimaryPartCFrame(CharClone:FindFirstChild(Correlation[v.Name]).CFrame)
			WeldTo(CharClone:FindFirstChild(Correlation[v.Name]), v.Middle)
		end
	end
	CS:AddTag(CharClone, MorphTag)
end
local function GiveHelmet(HelmetName)
	if not CharClone or not CharClone:FindFirstChild("Head") then
		return
	end
	if HelmetName == "None" then
		RemoveHelmet()
		return
	end
	if CS:HasTag(CharClone, HelmetTag) then
		RemoveHelmet()
	end
	local Helmet = HelmetRoot:FindFirstChild(HelmetName)
	if Helmet then
		Helmet = Helmet.Helmet:Clone()
	else
		return
	end
	Helmet.Parent = CharClone
	for e, n in pairs(CharClone:GetChildren()) do
		if n:IsA("Accoutrement") then
			n:Destroy()
		end
	end
	for e, n in pairs(Helmet:GetChildren()) do
		if n.Name ~= "Middle" and (n:IsA("UnionOperation") or n:IsA("BasePart")) then
			WeldTo(Helmet.Middle, n)
			n.Anchored = false
			n.CanCollide = false
		end
	end
	Helmet.Middle.Anchored = false
	Helmet.Middle.CanCollide = false
	Helmet:SetPrimaryPartCFrame(CharClone.Head.CFrame)
	WeldTo(Helmet.Middle, CharClone.Head)
	CS:AddTag(CharClone, HelmetTag)
end
local function SetClothing(ShirtId, PantsId, TShirtId)
	if not CharClone then
		return
	end
	local Shirt = CharClone:FindFirstChildWhichIsA("Shirt")
	Shirt = Shirt and Shirt or Instance.new("Shirt", Plr.Character)
	local Pants = CharClone:FindFirstChildWhichIsA("Pants")
	Pants = Pants and Pants or Instance.new("Pants", Plr.Character)
	if TShirtId then
		local TShirt = CharClone:FindFirstChildWhichIsA("ShirtGraphic")
		TShirt = TShirt and TShirt or Instance.new("ShirtGraphic", Plr.Character)
		TShirt.Graphic = TShirtId
	end
	if typeof(ShirtId) == "number" then
		ShirtId = "rbxassetid://" .. ShirtId
	end
	if typeof(PantsId) == "number" then
		PantsId = "rbxassetid://" .. PantsId
	end
	if ShirtId then
		Shirt.ShirtTemplate = ShirtId
	end
	if PantsId then
		Pants.PantsTemplate = PantsId
	end
end
local function RevertClothing()
	if not CharClone then
		return
	end
	if not Plr.Character then
		return
	end
	local Chr = Plr.Character
	local ShirtId, PantsId, TShirtId
	local Shirt = CharClone:FindFirstChildWhichIsA("Shirt")
	local Pants = CharClone:FindFirstChildWhichIsA("Pants")
	local TShirt = CharClone:FindFirstChildWhichIsA("ShirtGraphic")
	if Shirt then
		ShirtId = Shirt.ShirtTemplate
	end
	if Pants then
		PantsId = Pants.PantsTemplate
	end
	if TShirt then
		TShirtId = TShirt.Graphic
	end
	SetClothing(ShirtId, PantsId, TShirtId)
end
local DualListDisplay = {
	H = nil,
	Category = nil,
	Gui = nil,
	EntryList = nil,
	SettingsList = nil
}
function DualListDisplay:ClearList()
	local List = self.EntryList
	local ULL = List.UIListLayout
	local UP = List.UIPadding
	ULL.Parent = nil
	UP.Parent = nil
	List:ClearAllChildren()
	ULL.Parent, UP.Parent = List, List
end
function DualListDisplay:ChangeEntry(Value)
	return function()
		if NewLoadout[self.H][self.Category] ~= Value then
			Sound:Play("Navigate")
			NewLoadout[self.H][self.Category] = Value
			if self.Category == "Armor" then
				GiveArmor(Value)
			end
			if self.Category == "Helmet" then
				GiveHelmet(Value)
			end
			if self.Category == "Clothing" then
				local TheClothe = Permitted.Armor.Clothing[Value]
				if TheClothe == "None" then
					RevertClothing()
				else
					SetClothing(TheClothe.Shirt, TheClothe.Pants, TheClothe.TShirt)
				end
			end
			Changed = true
			for _, B in pairs(self.EntryList:GetChildren()) do
				if B:IsA("GuiButton") then
					if B.Text == Value then
						B.BackgroundColor3 = White
						B.TextColor3 = Black
					else
						B.BackgroundColor3 = Black
						B.TextColor3 = White
					end
				end
			end
		else
			Sound:Play("Click")
		end
	end
end
function DualListDisplay:ChangeCategory(Value)
	return function()
		if self.Category == Value then
			Sound:Play("Click")
			return
		end
		self.Category = Value
		Sound:Play("Navigate")
		for _, B in pairs(self.SettingsList:GetChildren()) do
			if B:IsA("GuiButton") then
				if B.Text == Value then
					B.BackgroundColor3 = White
					B.TextColor3 = Black
				else
					B.BackgroundColor3 = Black
					B.TextColor3 = White
				end
			end
		end
		self:ClearList()
		for K, Entry in pairs(Permitted[self.H][self.Category]) do
			local NewButton = ExampleButton:Clone()
			Entry = typeof(Entry) ~= "table" and Entry or K
			if NewLoadout[self.H][self.Category] == Entry then
				NewButton.BackgroundColor3 = White
				NewButton.TextColor3 = Black
			end
			NewButton.Name = Entry
			NewButton.Text = Entry
			NewButton.Parent = self.EntryList
			NewButton.MouseButton1Click:Connect(self:ChangeEntry(Entry))
		end
	end
end
function DualListDisplay.new(Menu, Name)
	local T = setmetatable({
		Gui = Menu,
		H = Name,
		EntryList = Menu:WaitForChild("EntryList"),
		SettingsList = Menu:WaitForChild("SettingsList")
	}, DualListDisplay)
	local Count = 0
	for i, v in pairs(Permitted[Name]) do
		if typeof(i) == "string" and not T.SettingsList:FindFirstChild(i) then
			Count = Count + 1
			local NewButton = ExampleButton:Clone()
			NewButton.Name = i
			NewButton.Text = i
			NewButton.Parent = T.SettingsList
			NewButton.MouseButton1Click:Connect(T:ChangeCategory(i))
		end
	end
	if Count == 0 then
		Menu.NoneText.Visible = true
	end
	return T
end
DualListDisplay.__index = DualListDisplay
local ArrangeList = {}
function ArrangeList:GetButtonAtIndex(Ind)
	for _, Button in pairs(self.Gui:GetChildren()) do
		if Button:IsA("GuiButton") and Button.LayoutOrder == Ind then
			return Button
		end
	end
end
function ArrangeList:MoveAhead(Button)
	return function()
		local ButtonInd = Button.LayoutOrder
		local NextButton = self:GetButtonAtIndex(ButtonInd + 1)
		if NextButton then
			Sound:Play("Navigate")
			Changed = true
			NextButton.LayoutOrder = NextButton.LayoutOrder - 1
			Button.LayoutOrder = Button.LayoutOrder + 1
		else
			Sound:Play("Click")
		end
	end
end
function ArrangeList:MoveBehind(Button)
	return function()
		local ButtonInd = Button.LayoutOrder
		local NextButton = self:GetButtonAtIndex(ButtonInd - 1)
		if NextButton then
			Sound:Play("Navigate")
			Changed = true
			NextButton.LayoutOrder = NextButton.LayoutOrder + 1
			Button.LayoutOrder = Button.LayoutOrder - 1
		else
			Sound:Play("Click")
		end
	end
end
function ArrangeList.new(Gui, DataSet)
	local T = setmetatable({Gui = Gui}, ArrangeList)
	local Ind = next(DataSet)
	local AbsoluteInd = 0
	while Ind do
		local Button = ExampleSort:Clone()
		local ToStr = typeof(Ind) == "number" and DataSet[Ind] or Ind
		Button.Name, Button.Text = ToStr, ToStr
		Button.LayoutOrder = AbsoluteInd
		Button.Parent = Gui
		Button.MouseButton1Click:Connect(T:MoveAhead(Button))
		Button.MouseButton2Click:Connect(T:MoveBehind(Button))
		AbsoluteInd = AbsoluteInd + 1
		Ind = next(DataSet, Ind)
	end
end
ArrangeList.__index = ArrangeList
local function SendData()
	local ToolsOrder = {}
	for _, Button in pairs(ToolOrderList:GetChildren()) do
		if Button:IsA("GuiButton") then
			table.insert(ToolsOrder, {
				Button.Name,
				Button.LayoutOrder
			})
		end
	end
	table.sort(ToolsOrder, function(a, b)
		return a[2] < b[2]
	end)
	for K, Tool in pairs(ToolsOrder) do
		ToolsOrder[K] = ToolsOrder[K][1]
	end
	local NewTools = NewLoadout.Tools
	local NewArmor = NewLoadout.Armor
	local ReturnTools = {}
	local ReturnArmor = {}
	for _, Tool in pairs(ToolsOrder) do
		if NewTools[Tool] then
			table.insert(ReturnTools, {
				Name = Tool,
				Set = NewTools[Tool]
			})
		else
			table.insert(ReturnTools, Tool)
		end
	end
	ReturnArmor = deepcopy(NewArmor)
	if ReturnArmor.Clothing then
		ReturnArmor.Clothing = deepcopy(Permitted.Armor.Clothing[ReturnArmor.Clothing])
	end
	local Ret = {Tools = ReturnTools, Armor = ReturnArmor}
	return Ret
end
local function ToggleOn()
	if Moving then
		return
	end
	Moving = true
	Background = Shed:Clone()
	for _, Part in pairs(Background:GetChildren()) do
		Part.BrickColor = Plr.TeamColor
	end
	Background.Parent = Cam
	Sound:Play("Open")
	BlurInTween:Play()
	Bloom.Parent = Cam
	if CS:HasTag(workspace.CurrentCamera, "GUIOccupied") then
		return
	end
	CS:AddTag(workspace.CurrentCamera, "GUIOccupied")
	Plr.Character.Archivable = true
	CharClone = Plr.Character:Clone()
	CharClone.Name = "_UIClone" .. Plr.Name
	Plr.Character.Archivable = false
	for _, Part in pairs(CharClone:GetDescendants()) do
		if Part:IsA("BasePart") then
			Part.Anchored = true
		end
	end
	CharClone:SetPrimaryPartCFrame(CharPart.CFrame)
	if NewLoadout.Armor.Armor then
		GiveArmor(NewLoadout.Armor.Armor)
	end
	if NewLoadout.Armor.Helmet then
		GiveHelmet(NewLoadout.Armor.Helmet)
	end
	if NewLoadout.Armor.Clothing then
		local TheClothe = Permitted.Armor.Clothing[NewLoadout.Armor.Clothing]
		if not TheClothe or TheClothe == "None" then
			RevertClothing()
		else
			SetClothing(TheClothe.Shirt, TheClothe.Pants, TheClothe.TShirt)
		end
	end
	CharClone.Parent = Cam
	wait(0.5)
	Cam.CameraType = Enum.CameraType.Scriptable
	Cam.CFrame = CamPart.CFrame
	ToolsPane.Visible = true
	ArmorPane.Visible = true
	ToolOrderPane.Visible = true
	wait(0.5)
	Moving = false
	Visible = true
end
local function ToggleOff()
	if Moving then
		return
	end
	Moving = true
	if Changed then
		Func:InvokeServer("SetLoadout", SendData())
	end
	Changed = false
	BlurInTween:Play()
	Sound:Play("Close")
	wait(0.5)
	if CS:HasTag(workspace.CurrentCamera, "GUIOccupied") then
		CS:RemoveTag(workspace.CurrentCamera, "GUIOccupied")
	end
	if CharClone then
		CharClone:Destroy()
		CharClone = nil
	end
	ToolsPane.Visible = false
	ArmorPane.Visible = false
	ToolOrderPane.Visible = false
	Cam.CameraType = Enum.CameraType.Custom
	Bloom.Parent = script
	wait(0.5)
	if Background then
		Background:Destroy()
		Background = nil
	end
	Moving = false
	Visible = false
end
local function OnPress(Name, State, Obj)
	if State == Enum.UserInputState.Begin then
		if Visible then
			ToggleOff()
		else
			ToggleOn()
		end
	end
end
local ToolsList = DualListDisplay.new(ToolsPane, "Tools")
local ArmorList = DualListDisplay.new(ArmorPane, "Armor")
local ToolSort = ArrangeList.new(ToolOrderList, CurrentLoadout.Tools)
Plr.Character:WaitForChild("Humanoid").Died:Connect(function()
	CAS:UnbindAction("LoadoutMenu")
	if Visible then
		ToggleOff()
	end
end)
CAS:BindAction("LoadoutMenu", OnPress, false, Enum.KeyCode.N)
CP:PreloadAsync(SoundRoot:GetChildren())
]]></ProtectedString><string name="Name">UIScript</string></Properties></Item></Item><Item class="Folder" referent="RBX1057"><Properties><string name="Name">PianoGui</string></Properties><Item class="LocalScript" referent="RBX1060"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

Gui = script.Parent
Player = game.Players.LocalPlayer
PlayingEnabled = false
ScriptReady = false
PianoId = nil
Connector = game.Workspace:FindFirstChild("GlobalPianoConnector")
function Receive(action, ...)
	local args = {
		...
	}
	if not ScriptReady then
		return
	end
	if action == "activate" then
		if not PlayingEnabled then
			Activate(args[1], args[2])
		end
	elseif action == "deactivate" then
		if PlayingEnabled then
			Deactivate()
		end
	elseif action == "play" and Player ~= args[1] then
		PlayNoteServer(args[2], args[3], args[4], args[5])
	end
end
function Activate(cameraCFrame, sounds)
	PlayingEnabled = true
	MakeHumanoidConnections()
	MakeKeyboardConnections()
	MakeGuiConnections()
	SetCamera(cameraCFrame)
	SetSounds(sounds)
	ShowPiano()
end
function Deactivate()
	PlayingEnabled = false
	BreakHumanoidConnections()
	BreakKeyboardConnections()
	BreakGuiConnections()
	HidePiano()
	HideSheets()
	ReturnCamera()
	Jump()
end
function PlayNoteClient(note)
	PlayNoteSound(note)
	HighlightPianoKey(note)
	Connector:FireServer("play", note)
end
function PlayNoteServer(note, point, range)
	PlayNoteSound(note, point, range)
end
function Abort()
	Connector:FireServer("abort")
end
Connector.OnClientEvent:connect(Receive)
InputService = game:GetService("UserInputService")
Mouse = Player:GetMouse()
TextBoxFocused = false
FocusLost = false
ShiftLock = false
function LetterToNote(key, shift)
	local letterNoteMap = "1!2@34$5%6^78*9(0qQwWeErtTyYuiIoOpPasSdDfgGhHjJklLzZxcCvVbBnm"
	local capitalNumberMap = ")!@#$%^&*("
	local letter = string.char(key)
	if shift then
		if tonumber(letter) then
			letter = string.sub(capitalNumberMap, tonumber(letter) + 1, tonumber(letter) + 1)
		else
			letter = string.upper(letter)
		end
	end
	local note = string.find(letterNoteMap, letter, 1, true)
	if note then
		return note
	end
end
function KeyDown(Object)
	if TextBoxFocused then
		return
	end
	local key = Object.KeyCode.Value
	local shift = (InputService:IsKeyDown(303) or InputService:IsKeyDown(304)) == not ShiftLock
	if key >= 97 and key <= 122 or key >= 48 and key <= 57 then
		local note = LetterToNote(key, shift)
		if note then
			PlayNoteClient(note)
		end
	elseif key == 8 then
		Deactivate()
	elseif key == 32 then
		ToggleSheets()
	elseif key == 13 then
		ToggleCaps()
	end
end
function Input(Object)
	local type = Object.UserInputType.Name
	local state = Object.UserInputState.Name
	if type == "Keyboard" and state == "Begin" then
		if FocusLost then
			FocusLost = false
			return
		end
		KeyDown(Object)
	end
end
function TextFocus()
	TextBoxFocused = true
end
function TextUnfocus()
	FocusLost = true
	TextBoxFocused = false
end
KeyboardConnection = nil
JumpConnection = nil
FocusConnection = InputService.TextBoxFocused:connect(TextFocus)
UnfocusConnection = InputService.TextBoxFocusReleased:connect(TextUnfocus)
function MakeKeyboardConnections()
	KeyboardConnection = InputService.InputBegan:connect(Input)
end
function BreakKeyboardConnections()
	KeyboardConnection:disconnect()
end
PianoGui = Gui.PianoGui
SheetsGui = Gui.SheetsGui
SheetsVisible = false
function ShowPiano()
	PianoGui:TweenPosition(UDim2.new(0.5, -380, 1, -220), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.5, true)
end
function HidePiano()
	PianoGui:TweenPosition(UDim2.new(0.5, -380, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.5, true)
end
function ShowSheets()
	SheetsGui:TweenPosition(UDim2.new(0.5, -200, 1, -520), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.5, true)
end
function HideSheets()
	SheetsGui:TweenPosition(UDim2.new(0.5, -200, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.5, true)
end
function ToggleSheets()
	SheetsVisible = not SheetsVisible
	if SheetsVisible then
		ShowSheets()
	else
		HideSheets()
	end
end
function IsBlack(note)
	if note % 12 == 2 or note % 12 == 4 or note % 12 == 7 or note % 12 == 9 or note % 12 == 11 then
		return true
	end
end
function HighlightPianoKey(note)
	local keyGui = PianoGui.Keys[note]
	if IsBlack(note) then
		keyGui.BackgroundColor3 = Color3.new(0.19607843137254902, 0.19607843137254902, 0.19607843137254902)
	else
		keyGui.BackgroundColor3 = Color3.new(0.7843137254901961, 0.7843137254901961, 0.7843137254901961)
	end
	delay(0.5, function()
		RestorePianoKey(note)
	end)
end
function RestorePianoKey(note)
	local keyGui = PianoGui.Keys[note]
	if IsBlack(note) then
		keyGui.BackgroundColor3 = Color3.new(0, 0, 0)
	else
		keyGui.BackgroundColor3 = Color3.new(1, 1, 1)
	end
end
function PianoKeyPressed(Object, note)
	local type = Object.UserInputType.Name
	if type == "MouseButton1" or type == "Touch" then
		PlayNoteClient(note)
	end
end
function ExitButtonPressed(Object)
	local type = Object.UserInputType.Name
	if type == "MouseButton1" or type == "Touch" then
		Deactivate()
	end
end
function SheetsButtonPressed(Object)
	local type = Object.UserInputType.Name
	if type == "MouseButton1" or type == "Touch" then
		ToggleSheets()
	end
end
function SheetsEdited(property)
	if property == "Text" then
		local bounds = SheetsGui.Sheet.ScrollingFrame.TextBox.TextBounds
		SheetsGui.Sheet.ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, math.max(14, bounds.Y))
	end
end
function ToggleCaps()
	ShiftLock = not ShiftLock
	if ShiftLock then
		PianoGui.CapsButton.BackgroundColor3 = Color3.new(1, 0.6666666666666666, 0)
		PianoGui.CapsButton.BorderColor3 = Color3.new(0.6039215686274509, 0.403921568627451, 0)
		PianoGui.CapsButton.TextColor3 = Color3.new(1, 1, 1)
	else
		PianoGui.CapsButton.BackgroundColor3 = Color3.new(0.5490196078431373, 0.5490196078431373, 0.5490196078431373)
		PianoGui.CapsButton.BorderColor3 = Color3.new(0.26666666666666666, 0.26666666666666666, 0.26666666666666666)
		PianoGui.CapsButton.TextColor3 = Color3.new(0.7058823529411765, 0.7058823529411765, 0.7058823529411765)
	end
end
function CapsButtonPressed(Object)
	local type = Object.UserInputType.Name
	if type == "MouseButton1" or type == "Touch" then
		ToggleCaps()
	end
end
PianoKeysConnections = {}
ExitButtonConnection = nil
SheetsButtonConnection = nil
SheetsEditedConnection = nil
CapsButtonConnection = nil
function MakeGuiConnections()
	for i, v in pairs(PianoGui.Keys:GetChildren()) do
		PianoKeysConnections[i] = v.InputBegan:connect(function(Object)
			PianoKeyPressed(Object, tonumber(v.Name))
		end)
	end
	ExitButtonConnection = PianoGui.ExitButton.InputBegan:connect(ExitButtonPressed)
	SheetsButtonConnection = PianoGui.SheetsButton.InputBegan:connect(SheetsButtonPressed)
	SheetsEditedConnection = SheetsGui.Sheet.ScrollingFrame.TextBox.Changed:connect(SheetsEdited)
	CapsButtonConnection = PianoGui.CapsButton.InputBegan:connect(CapsButtonPressed)
end
function BreakGuiConnections()
	for i, v in pairs(PianoKeysConnections) do
		v:disconnect()
	end
	ExitButtonConnection:disconnect()
	SheetsButtonConnection:disconnect()
	SheetsEditedConnection:disconnect()
	CapsButtonConnection:disconnect()
end
ContentProvider = game:GetService("ContentProvider")
LocalSounds = {
	"233836579",
	"233844049",
	"233845680",
	"233852841",
	"233854135",
	"233856105"
}
SoundFolder = Gui.SoundFolder
ExistingSounds = {}
function PreloadAudio(sounds)
	for i, v in pairs(sounds) do
		ContentProvider:Preload("rbxassetid://" .. v)
	end
end
function SetSounds(sounds)
	PreloadAudio(sounds)
	LocalSounds = sounds
end
function PlayNoteSound(note, source, range, sounds)
	local SoundList = sounds or LocalSounds
	local note2 = (note - 1) % 12 + 1
	local octave = math.ceil(note / 12)
	local sound = math.ceil(note2 / 2)
	local offset = 16 * (octave - 1) + 8 * (1 - note2 % 2)
	local audio = Instance.new("Sound", SoundFolder)
	audio.SoundId = "rbxassetid://" .. SoundList[sound]
	if source then
		local a = 1 / range ^ 2
		local distance = (game.Workspace.CurrentCamera.CoordinateFrame.p - source).magnitude
		local volume = -a * distance ^ 2 + 1
		if volume < 0.05 then
			audio:remove()
			return
		end
		audio.Volume = volume
	end
	audio.TimePosition = offset + (octave - 0.9) / 15
	audio:Play()
	table.insert(ExistingSounds, 1, audio)
	if #ExistingSounds >= 10 then
		ExistingSounds[10]:Stop()
		ExistingSounds[10] = nil
	end
	delay(4, function()
		audio:Stop()
		audio:remove()
	end)
end
Camera = game.Workspace.CurrentCamera
function Jump()
	local character = Player.Character
	if character then
		local humanoid = character:FindFirstChild("Humanoid")
		if humanoid then
			humanoid.Jump = true
		end
	end
end
function HumanoidChanged(humanoid, property)
	if property == "Jump" then
		humanoid.Jump = false
	elseif property == "Sit" then
		humanoid.Sit = true
	elseif property == "Parent" then
		Deactivate()
		Abort()
	end
end
function HumanoidDied()
	Deactivate()
end
function SetCamera(cframe)
	Camera.CameraType = Enum.CameraType.Scriptable
	Camera:Interpolate(cframe, cframe + cframe.lookVector, 0.5)
end
function ReturnCamera()
	Camera.CameraType = Enum.CameraType.Custom
end
HumanoidChangedConnection = nil
HumanoidDiedConnection = nil
function MakeHumanoidConnections()
	local character = Player.Character
	if character then
		do
			local humanoid = character:FindFirstChild("Humanoid")
			if humanoid then
				HumanoidChangedConnection = humanoid.Changed:connect(function(property)
					HumanoidChanged(humanoid, property)
				end)
				HumanoidDiedConnection = humanoid.Died:connect(HumanoidDied)
			end
		end
	end
end
function BreakHumanoidConnections()
	HumanoidChangedConnection:disconnect()
	HumanoidDiedConnection:disconnect()
end
ScriptReady = true
]]></ProtectedString><string name="Name">Main</string></Properties></Item></Item><Item class="LocalScript" referent="RBX1066"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local BulletModule = {}
BulletModule.Bullets = {}
BulletModule.StepSpeed = 1
local Trail, Light = script:WaitForChild("Trail"), script:WaitForChild("PointLight")
function BulletModule.new(BulletSettings, ReturnFunction)
	local OriginPart = Instance.new("Part")
	OriginPart.Size, OriginPart.CFrame, OriginPart.Transparency, OriginPart.CanCollide, OriginPart.Anchored = Vector3.new(0.05, 0.05, 0.05), CFrame.new(BulletSettings.OriginPos, BulletSettings.DirectionPos), 1, false, true
	OriginPart.Parent = workspace
	local Attach1, Attach2, Attach3, Attach4 = Instance.new("Attachment"), Instance.new("Attachment")
	Attach1.Parent, Attach2.Parent = OriginPart, OriginPart
	local EffectA, EffectB = Trail:Clone(), Trail:Clone()
	EffectA.Color = ColorSequence.new(BulletSettings.BulletColorA)
	EffectA.Parent = OriginPart
	EffectA.Attachment0, EffectA.Attachment1 = Attach1, Attach2
	local light = Light:Clone()
	light.Parent = Attach1
	if BulletSettings.BulletColorB then
		Attach3, Attach4 = Instance.new("Attachment"), Instance.new("Attachment")
		Attach3.Parent, Attach4.Parent = OriginPart, OriginPart
		EffectB = script.Trail:Clone()
		EffectB.Color = ColorSequence.new(BulletSettings.BulletColorB)
		EffectB.Attachment0, EffectB.Attachment1 = Attach3, Attach4
		EffectB.Parent = OriginPart
	end
	spawn(function()
		local Hit, virtualCF, Counter, Ignore = false, CFrame.new(), 0, BulletSettings.IgnoreList
		local deltaTime = 0.016666666666666666
		for i = 1, 100 do
			if not Hit then
				if Counter >= 100 then
					OriginPart:Destroy()
					return
				end
				local displacement = deltaTime / 0.01 * (deltaTime / 0.01 * 25)
				displacement = (0.25 + math.min(Counter, 2) / 2 * 0.75) * displacement
				local vCF = OriginPart.CFrame * virtualCF
				local bRay = Ray.new(vCF.p, (vCF.p - (vCF * CFrame.new(0, 0, 10)).p).unit * displacement)
				local hit, hitp = workspace:FindPartOnRayWithIgnoreList(bRay, Ignore)
				if hit and hit.Transparency ~= 1 then
					Hit = true
					ReturnFunction(hit, hitp)
					delay(0.1, function()
						light:Destroy()
						EffectA:Destroy()
						Attach1:Destroy()
						Attach2:Destroy()
						if EffectB then
							EffectB:Destroy()
							Attach3:Destroy()
							Attach4:Destroy()
						end
						OriginPart:Destroy()
						Hit, virtualCF, Counter, Ignore, deltaTime = nil, nil, nil, nil, nil
					end)
					virtualCF = OriginPart.CFrame:inverse() * CFrame.new(hitp)
					break
				else
					virtualCF = virtualCF * CFrame.new(0, 0, -displacement)
				end
				if Attach3 then
					Attach3.CFrame = virtualCF * CFrame.new(-0.2, 0, 0)
					Attach4.CFrame = virtualCF * CFrame.new(0.2, 0, 0)
					EffectB.Lifetime = 0.01
				end
				Attach1.CFrame = virtualCF * CFrame.new(-0.1, 0, 0)
				Attach2.CFrame = virtualCF * CFrame.new(0.1, 0, 0)
				EffectA.Lifetime = 0.01
				Counter = Counter + 1
			end
			game:GetService("RunService").RenderStepped:wait(deltaTime)
		end
	end)
end
wait(1)
shared.BulletModule = BulletModule
]]></ProtectedString><string name="Name">BulletRender</string></Properties></Item><Item class="Folder" referent="RBX1071"><Properties><string name="Name">MenuUI</string></Properties><Item class="LocalScript" referent="RBX1074"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

wait()
local Player = game:GetService("Players").LocalPlayer
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local NetworkEvent = ReplicatedStorage:WaitForChild("Events"):WaitForChild("MenuEvent")
local NetworkFunction = ReplicatedStorage:WaitForChild("Functions"):WaitForChild("TeamRequest")
local Blur, Color = script:WaitForChild("Blur"), script:WaitForChild("ColorCorrection")
local VisionTag = "AnomalousVision"
Blur.Parent = workspace.CurrentCamera
Color.Parent = workspace.CurrentCamera
local GUI = script.Parent
GUI.ShowFrame.Visible = true
local GetShortenedTeamName = function(TeamName)
	local Output = ""
	for v in TeamName:gmatch("[^%s]+") do
		Output = Output .. v:sub(1, 1)
	end
	return Output
end
local Buttons, UpdateLog, XboxTips, Teams = GUI:WaitForChild("Buttons"), GUI:WaitForChild("UpdateLog"), GUI:WaitForChild("XboxTips"), GUI:WaitForChild("Teams")
local Cache = {TweeningMenu = false, CurrentMenu = "Home"}
local MenuVisible = false
Player:WaitForChild("PlayerGui"):SetTopbarTransparency(0)
local PlayerTeams = NetworkFunction:InvokeServer("GetPermittedTeams")
GUI.ShowFrame:WaitForChild("ServerWait").Visible = false
if PlayerTeams then
	local PT = {}
	for i, v in pairs(PlayerTeams) do
		PT[i] = {
			Name = v.Name,
			TeamShort = v.ShortHand or GetShortenedTeamName(v.Name),
			TeamColor = v.TeamColor.Color,
			Image = v.Image and "rbxassetid://" .. tostring(v.Image) or nil,
			Authorized = v.Authorized
		}
	end
	PlayerTeams = PT
else
	PlayerTeams = {}
end
local MenuFunctions = {
	Play = function()
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
		MenuVisible = false
		TweenMenuOut()
		if GUI.Music.IsPlaying then
			spawn(function()
				for i = 1, 50 do
					GUI.Music.Volume = 0.4 - 0.4 * (i / 50)
					wait()
				end
				GUI.Music:Stop()
			end)
		end
		workspace.CurrentCamera.CameraType = "Custom"
		workspace.CurrentCamera.CameraSubject = Player.Character:WaitForChild("Humanoid")
	end,
	Teams = function()
		TweenMenuOut(true)
		delay(0.1, function()
			Teams.Visible = true
			local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
			TweenService:Create(Teams.Title, tweenInfoA, {TextTransparency = 0}):Play()
			TweenService:Create(Teams.Title.TextLabel, tweenInfoA, {TextTransparency = 0}):Play()
			local UnauthedTeams = {}
			local AuthedTeams = {}
			for i, v in pairs(Teams.Frame:GetChildren()) do
				if v:IsA("ImageButton") then
					v:Destroy()
				end
			end
			for i, v in pairs(PlayerTeams) do
				if v.Authorized then
					AuthedTeams[#AuthedTeams + 1] = v
				else
					UnauthedTeams[#UnauthedTeams + 1] = v
				end
			end
			for i, v in pairs(AuthedTeams) do
				do
					local Button = script.TeamTemplate:Clone()
					Button.Parent = Teams.Frame
					Teams.Frame.CanvasSize = Teams.Frame.CanvasSize + UDim2.new(0, 0, 0, 120)
					Button.TeamName.Text = v.TeamShort
					Button.TeamName.TextLabel.Text = v.TeamShort
					if v.Image ~= nil then
						Button.TeamImage.Image = v.Image
						TweenService:Create(Button.TeamImage, tweenInfoA, {ImageTransparency = 0.8}):Play()
					end
					Button.MouseButton1Click:connect(function()
						local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
						TweenService:Create(Teams.Title, tweenInfoA, {TextTransparency = 1}):Play()
						TweenService:Create(Teams.Title.TextLabel, tweenInfoA, {TextTransparency = 1}):Play()
						delay(0.1, function()
							Teams.Visible = false
							NetworkEvent:FireServer("TeamChange", v.Name)
							StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
							StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
						end)
					end)
					TweenService:Create(Button.TeamName, tweenInfoA, {TextTransparency = 0}):Play()
					TweenService:Create(Button.TeamName.TextLabel, tweenInfoA, {TextTransparency = 0}):Play()
					TweenService:Create(Button, tweenInfoA, {ImageTransparency = 0}):Play()
					TweenService:Create(Button.Backing, tweenInfoA, {ImageTransparency = 0}):Play()
					wait(0.05)
				end
			end
			local conn
			conn = Teams.Back.MouseButton1Click:connect(function()
				conn:disconnect()
				Teams.Back.Visible = false
				local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
				TweenService:Create(Teams.Title, tweenInfoA, {TextTransparency = 1}):Play()
				TweenService:Create(Teams.Title.TextLabel, tweenInfoA, {TextTransparency = 1}):Play()
				delay(0.1, function()
					Teams.Visible = false
					Teams.Back.Visible = true
					TweenMenuIn(true)
				end)
			end)
		end)
	end
}
function TweenEffects(InOut)
	spawn(function()
		if CollectionService:HasTag(Player, VisionTag) then
			return
		end
		local TweenGoalA = {}
		TweenGoalA.Size = InOut and 12 or 0
		local tweenInfoA = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		local TweenGoalB = {
			Brightness = InOut and 0.2 or 0,
			Contrast = InOut and 0.6 or 0,
			Saturation = InOut and 1 or 0,
			TintColor = InOut and Color3.fromRGB(147, 147, 147) or Color3.new(1, 1, 1)
		}
		local tweenInfoB = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		TweenService:Create(Blur, tweenInfoA, TweenGoalA):Play()
		TweenService:Create(Color, tweenInfoB, TweenGoalB):Play()
	end)
end
function ListenOnButtons()
	local TheButtons = Buttons:GetChildren()
	local TweenGoalA, TweenGoalB = {
		TextColor3 = Color3.fromRGB(255, 255, 255)
	}, {
		TextColor3 = Color3.fromRGB(93, 93, 93)
	}
	local TextTweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
	for i, v in pairs(TheButtons) do
		v.MouseButton1Click:connect(function()
			if not MenuVisible then
				return
			end
			Cache.CurrentMenu = v.Name
			GUI.Click:Play()
			if MenuFunctions[v.Name] then
				MenuFunctions[v.Name]()
			end
		end)
		v.MouseEnter:connect(function()
			if not MenuVisible then
				return
			end
			if not CollectionService:HasTag(v, "TweeningIn") and not Cache.TweeningMenu then
				TweenService:Create(v, TextTweenInfo, TweenGoalA):Play()
				GUI.Navigate:Play()
				CollectionService:AddTag(v, "TweeningIn")
				delay(0.1, function()
					for e, g in pairs(TheButtons) do
						if not CollectionService:HasTag(g, "TweeningOut") and not CollectionService:HasTag(g, "TweeningIn") and g ~= v then
							CollectionService:AddTag(g, "TweeningOut")
							TweenService:Create(g, TextTweenInfo, TweenGoalB):Play()
							delay(0.1, function()
								CollectionService:RemoveTag(g, "TweeningOut")
							end)
						end
					end
					CollectionService:RemoveTag(v, "TweeningIn")
				end)
				for e, g in pairs(TheButtons) do
					if not CollectionService:HasTag(g, "TweeningIn") and g ~= v then
						CollectionService:AddTag(g, "TweeningOut")
						TweenService:Create(g, TextTweenInfo, TweenGoalB):Play()
						delay(0.1, function()
							CollectionService:RemoveTag(g, "TweeningOut")
						end)
					end
				end
			end
		end)
		v.MouseLeave:connect(function()
			if not MenuVisible then
				return
			end
			if not CollectionService:HasTag(v, "TweeningOut") and not Cache.TweeningMenu then
				for e, g in pairs(TheButtons) do
					if not CollectionService:HasTag(g, "TweeningOut") and g ~= v then
						CollectionService:AddTag(g, "TweeningOut")
						TweenService:Create(g, TextTweenInfo, TweenGoalB):Play()
						delay(0.1, function()
							CollectionService:RemoveTag(g, "TweeningOut")
						end)
					end
				end
			end
		end)
	end
end
function TweenMenuOut(DoEffects)
	if Cache.TweeningMenu then
		return
	end
	if CollectionService:HasTag(workspace.CurrentCamera, "GUIOccupied") then
		CollectionService:RemoveTag(workspace.CurrentCamera, "GUIOccupied")
	end
	local TweenGoalA, TweenGoalB = {
		TextColor3 = Color3.fromRGB(255, 255, 255)
	}, {
		TextColor3 = Color3.fromRGB(93, 93, 93)
	}
	local TextTweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
	Cache.TweeningMenu = true
	if not DoEffects then
		TweenEffects(false)
	end
	GUI.Close:Play()
	XboxTips.Visible = false
	delay(0.1, function()
		local order = {
			[4] = "Play",
			[3] = "Teams",
			[2] = "Credits",
			[1] = "Settings"
		}
		spawn(function()
			for i, v in pairs(Buttons:GetChildren()) do
				local oldPosition = Buttons[order[i]].Position
				local Position = UDim2.new(0.7, -60, 0.3, oldPosition.Y.Offset)
				Buttons[order[i]]:TweenPosition(Position, "Out", "Quad", 0.2, false)
				local TweenGoalA = {}
				TweenGoalA.TextTransparency = 1
				local tweenInfoA = TweenInfo.new(0.13, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
				TweenService:Create(Buttons[order[i]], tweenInfoA, TweenGoalA):Play()
				TweenService:Create(Buttons[order[i]].TextLabel, tweenInfoA, TweenGoalA):Play()
				wait()
			end
		end)
		local TweenGoalA = {}
		TweenGoalA.TextTransparency = 1
		local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		local function recurse(t)
			if t:IsA("TextLabel") then
				TweenService:Create(t, tweenInfoA, TweenGoalA):Play()
			end
			for i, v in pairs(t:GetChildren()) do
				recurse(v)
			end
		end
		local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		local oldPositionA, oldPositionB = UpdateLog.Frame1.Position, UpdateLog.Frame2.Position
		local PositionA, PositionB = UDim2.new(0, 20, 0.3, oldPositionA.Y.Offset + 20), UDim2.new(0, 20, 0.3, oldPositionB.Y.Offset + 20)
		TweenService:Create(UpdateLog.Frame1, tweenInfoA, {BackgroundTransparency = 1, Position = PositionA}):Play()
		TweenService:Create(UpdateLog.Frame2, tweenInfoA, {BackgroundTransparency = 1, Position = PositionB}):Play()
		recurse(UpdateLog)
		for e, g in pairs(Buttons:GetChildren()) do
			if not CollectionService:HasTag(g, "TweeningOut") and g.Name ~= "Play" then
				CollectionService:AddTag(g, "TweeningOut")
				TweenService:Create(g, TextTweenInfo, TweenGoalB):Play()
				delay(0.1, function()
					CollectionService:RemoveTag(g, "TweeningOut")
				end)
			end
		end
		if Cache.CurrentMenu == "Home" then
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		end
		wait(0.2)
		UpdateLog.Visible, Buttons.Visible = false, false
		Buttons.Play.TextColor3 = Color3.new(1, 1, 1)
		Cache.TweeningMenu = false
		if not DoEffects then
			Cache.CurrentMenu = "Home"
			Cache.MenuStatus = false
		end
	end)
end
function TweenMenuIn(DoEffects)
	if Cache.TweeningMenu then
		return
	end
	if CollectionService:HasTag(workspace.CurrentCamera, "GUIOccupied") then
		return
	end
	CollectionService:AddTag(workspace.CurrentCamera, "GUIOccupied")
	MenuVisible = true
	Cache.TweeningMenu = true
	if not DoEffects then
		TweenEffects(true)
	end
	GUI.Open:Play()
	workspace.CurrentCamera.CameraType = "Scriptable"
	local CamPartDir = workspace:WaitForChild("CamParts"):GetChildren()
	workspace.CurrentCamera.CFrame = CamPartDir[math.random(#CamPartDir)].CFrame
	UpdateLog.Visible, Buttons.Visible = true, true
	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
	delay(0.3, function()
		local order = {
			[1] = "Play",
			[2] = "Teams",
			[3] = "Credits",
			[4] = "Settings"
		}
		for i, v in pairs(Buttons:GetChildren()) do
			local oldPosition = Buttons[order[i]].Position
			local Position = UDim2.new(0.7, 0, 0.3, oldPosition.Y.Offset)
			Buttons[order[i]]:TweenPosition(Position, "Out", "Quad", 0.3, false)
			local TweenGoalA = {}
			TweenGoalA.TextTransparency = 0
			local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
			TweenService:Create(Buttons[order[i]], tweenInfoA, TweenGoalA):Play()
			TweenService:Create(Buttons[order[i]].TextLabel, tweenInfoA, TweenGoalA):Play()
			wait(0.05)
		end
		local TweenGoalA = {}
		TweenGoalA.TextTransparency = 0
		local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		local function recurse(t)
			if t:IsA("TextLabel") then
				TweenService:Create(t, tweenInfoA, TweenGoalA):Play()
			end
			for i, v in pairs(t:GetChildren()) do
				recurse(v)
			end
		end
		local tweenInfoA = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		local oldPositionA, oldPositionB = UpdateLog.Frame1.Position, UpdateLog.Frame2.Position
		local PositionA, PositionB = UDim2.new(0, 20, 0.3, oldPositionA.Y.Offset - 20), UDim2.new(0, 20, 0.3, oldPositionB.Y.Offset - 20)
		TweenService:Create(UpdateLog.Frame1, tweenInfoA, {BackgroundTransparency = 0.9, Position = PositionA}):Play()
		wait(0.1)
		TweenService:Create(UpdateLog.Frame2, tweenInfoA, {BackgroundTransparency = 0.9, Position = PositionB}):Play()
		recurse(UpdateLog)
		if game:GetService("GuiService"):IsTenFootInterface() then
			XboxTips.Visible = true
		end
		Cache.CurrentMenu = "Home"
		wait(0.2)
		Cache.TweeningMenu = false
		Cache.MenuStatus = true
	end)
end
game:GetService("UserInputService").InputBegan:connect(function(IO, GP)
	if GP then
		return
	end
	if IO.KeyCode == Enum.KeyCode.M and Cache.CurrentMenu == "Home" and not Cache.MenuStatus then
		TweenMenuIn()
	else
	end
end)
NetworkEvent.OnClientEvent:Connect(function(Push)
	if Push == "Close" then
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
		MenuVisible = false
		if GUI.Music.IsPlaying then
			spawn(function()
				for i = 1, 50 do
					GUI.Music.Volume = 0.4 - 0.4 * (i / 50)
					wait()
				end
				GUI.Music:Stop()
			end)
		end
		TweenMenuOut()
		workspace.CurrentCamera.CameraType = "Custom"
		workspace.CurrentCamera.CameraSubject = Player.Character:WaitForChild("Humanoid")
	end
end)
local Max = game:GetService("ContentProvider").RequestQueueSize
script.Parent.ShowFrame.SkipButton.MouseButton1Click:Connect(function()
	script.Parent.ShowFrame.Visible = false
end)
script.Parent.ShowFrame.Visible = true
repeat
	wait(0.1)
	local CurrentQueue = game:GetService("ContentProvider").RequestQueueSize
	Max = math.max(Max, CurrentQueue)
	script.Parent.ShowFrame.PercentLoaded.Text = math.floor(CurrentQueue / Max * 100) .. "% Left"
until script.Parent.ShowFrame.Visible == false or 0 >= game:GetService("ContentProvider").RequestQueueSize
Player:WaitForChild("PlayerGui"):SetTopbarTransparency(0.5)
script.Parent.ShowFrame.Visible = false
GUI.Music:Play()
TweenMenuIn()
spawn(ListenOnButtons)
]]></ProtectedString><string name="Name">MenuRunner</string></Properties></Item></Item></Item><Item class="Folder" referent="RBX1081"><Properties><string name="Name">ReplicatedFirst</string></Properties><Item class="LocalScript" referent="RBX1084"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local sgui = game.StarterGui
sgui:SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
script.Parent:RemoveDefaultLoadingScreen()
local gui = script.LoadingGui:Clone()
local PlayerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
gui.Parent = PlayerGui
PlayerGui:SetTopbarTransparency(0)
local cp = game:GetService("ContentProvider")
spawn(function()
	game.Players.LocalPlayer.PlayerGui:WaitForChild("MenuUI")
	gui:Destroy()
end)
]]></ProtectedString><string name="Name">LoadingGuiLoader</string></Properties><Item class="Folder" referent="RBX1088"><Properties><string name="Name">LoadingGui</string></Properties><Item class="Folder" referent="RBX1091"><Properties><string name="Name">Frame</string></Properties><Item class="LocalScript" referent="RBX1094"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local ath = script.Parent.Athaumic
ath.MouseButton1Click:connect(function()
	script.Parent.Athaumic.ImageColor3 = Color3.fromRGB(144, 144, 144)
	script.Parent.Tada.TimePosition = 0.3
	script.Parent.Tada:Resume()
	wait(0.1)
	script.Parent.Athaumic.ImageColor3 = Color3.fromRGB(255, 255, 255)
end)
ath.MouseEnter:Connect(function()
	script.Parent.Athaumic.ImageColor3 = Color3.fromRGB(180, 180, 180)
end)
ath.MouseLeave:Connect(function()
	script.Parent.Athaumic.ImageColor3 = Color3.fromRGB(255, 255, 255)
end)
script:WaitForChild("Music"):Play()
game.Players.LocalPlayer.PlayerGui:WaitForChild("MenuUI")
script.Music:Stop()
]]></ProtectedString><string name="Name">LocalScript</string></Properties></Item><Item class="Folder" referent="RBX1099"><Properties><string name="Name">LoadingBlip</string></Properties><Item class="Folder" referent="RBX1102"><Properties><string name="Name">BleepBloop</string></Properties><Item class="LocalScript" referent="RBX1105"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local blopblup = script.Parent
local blepblups = {
	blopblup.Blip1,
	blopblup.Blip2,
	blopblup.Blip3,
	blopblup.Blip4,
	blopblup.Blip5
}
local blipblongs = {}
local bloopblinbs = {}
for bleep, blonp in pairs(blepblups) do
	table.insert(blipblongs, game.TweenService:Create(blonp, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, -1, true), {
		Position = blonp.Position + UDim2.new(0, 0, 0.2, 0)
	}))
end
for _, blwomb in pairs(blipblongs) do
	blwomb:Play()
	wait(0.2)
end
]]></ProtectedString><string name="Name">BlipBlap</string></Properties></Item></Item></Item></Item></Item></Item></Item><Item class="Folder" referent="RBX1116"><Properties><string name="Name">NIL</string></Properties><Item class="LocalScript" referent="RBX1119"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

local DebugMode = false
local oneTooMany = 1 or 1 or 1 or 1 or 1 or (...)
local otime = os.time
local time = time
local game = game
local pcall = pcall
local xpcall = xpcall
local error = error
local type = type
local print = print
local assert = assert
local string = string
local setfenv = setfenv
local getfenv = getfenv
local require = require
local tostring = tostring
local coroutine = coroutine
local Instance = Instance
local script = script
local select = select
local unpack = unpack
local debug = debug
local pairs = pairs
local wait = wait
local next = next
local tick = tick
local finderEvent
local realWarn = warn
local realPrint = print
local foundClient = false
local checkedChildren = {}
local replicated = game:GetService("ReplicatedFirst")
local runService = game:GetService("RunService")
local player = game:GetService("Players").LocalPlayer
local Kick = player.Kick
local start = tick()
local checkThese = {}
local services = {
	"Chat",
	"Teams",
	"Players",
	"Workspace",
	"LogService",
	"TestService",
	"InsertService",
	"SoundService",
	"StarterGui",
	"StarterPack",
	"StarterPlayer",
	"ReplicatedFirst",
	"ReplicatedStorage",
	"JointsService",
	"Lighting"
}
local print = function(...)
end
local function warn(str)
	if DebugMode or player.UserId == 1237666 then
		realWarn("ACLI: " .. tostring(str))
	end
end
local function client found...")
if not foundClient then
	warn("Loading took too long")
	Kick(player, "ACLI: Loading Error [Took Too Long]")
else
	print("Debug: Adonis loaded?")
	warn("Client found")
	warn("Finished")
	warn(time())
end
]]></ProtectedString><string name="Name"></string></Properties></Item><Item class="LocalScript" referent="RBX1124"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler
--This script could not be decompiled due to it having no bytecode.
--This is usually caused by trying to decompile a Synapse X generated script.]]></ProtectedString><string name="Name">h2Z1EfMkc0</string></Properties></Item><Item class="LocalScript" referent="RBX1129"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler
--This script could not be decompiled due to it having no bytecode.
--This is usually caused by trying to decompile a Synapse X generated script.]]></ProtectedString><string name="Name">j6QTlxuc2bsgdPESR</string></Properties></Item><Item class="ModuleScript" referent="RBX1134"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

server = nil
client = nil
Pcall = nil
cPcall = nil
Routine = nil
local ErrorHandler
local RealMethods = {}
local methods = setmetatable({}, {
	__index = function(tab, index)
		return function(obj, ...)
]]></ProtectedString><string name="Name">Service</string></Properties></Item><Item class="ModuleScript" referent="RBX1139"><Properties><ProtectedString name="Source"><![CDATA[--SynapseX Decompiler

math.randomseed(os.time())
local _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay = _G, game, script, getfenv, setfenv, workspace, getmetatable, setmetatable, loadstring, coroutine, rawequal, typeof, print, math, warn, error, pcall, ypcall, xpcall, select, rawset, rawget, ipairs, pairs, next, Rect, Axes, os, tick, Faces, unpack, string, Color3, newproxy, tostring, tonumber, Instance, TweenInfo, BrickColor, NumberRange, ColorSequence, NumberSequence, ColorSequenceKeypoint, NumberSequenceKeypoint, PhysicalProperties, Region3int16, Vector3int16, elapsedTime, require, table, type, wait, Enum, UDim, UDim2, Vector2, Vector3, Region3, CFrame, Ray, delay
local unique = {}
local origEnv = getfenv()
setfenv(1, setmetatable({}, {__metatable = unique}))
local origWarn = warn
local startTime = tick()
local clientLocked = false
local oldInstNew = Instance.new
local oldReq = require
local Folder
local locals = {}
local client = {}
local Queues = {}
local service = {}
local RbxEvents = {}
local Debounces = {}
local LoopQueue = {}
local RealMethods = {}
local RunningLoops = {}
local HookedEvents = {}
local WaitingEvents = {}
local ServiceSpecific = {}
local ServiceVariables = {}
local function isModule(module)
	for ind, modu in next, client.Modules, nil do
		if rawequal(module, modu) then
			return true
		end
	end
end
local function logError(err)
	warn("ERROR:" .. tostring(err))
	if client and client.Remote then
		client.Remote.Send("LogError", err)
	end
end
local function message(...)
	game:GetService("TestService"):Message(...)
end
local function print(...)
	for i, v in next, {
		...
	}, nil do
		print(":: Adonis :: " .. tostring(v))
	end
end
local function warn(...)
	for i, v in next, {
		...
	}, nil do
		warn(tostring(v))
	end
end
local function cPcall(func, ...)
	local function cour(...)
		coroutine.resume(coroutine.create(func), ...)
	end
	local ran, error = ypcall(cour, ...)
	if error then
		print(error)
		logError(error)
		warn("ERROR :: " .. error)
	end
end
local function Pcall(func, ...)
	local ran, error = ypcall(func, ...)
	if error then
		logError(error)
	end
end
local function Routine(func, ...)
	coroutine.resume(coroutine.create(func), ...)
end
local function sortedPairs(t, f)
	local a = {}
	for n in next, t, nil do
		table.insert(a, n)
	end
	table.sort(a, f)
	local i = 0
	local function iter()
		i = i + 1
		if a[i] == nil then
			return nil
		else
			return a[i], t[a[i]]
		end
	end
	return iter
end
local player = game:GetService("Players").LocalPlayer
local Fire, Detected
local wrap = coroutine.wrap
local function Kill(info)
	wrap(function()
		pcall(function()
			if Detected then
				Detected("kick", info)
			elseif Fire then
				Fire("BadMemes", info)
			end
		end)
	end)()
	wrap(function()
		pcall(function()
			wait(1)
			service.Player:Kick(info)
		end)
	end)()
	wrap(function()
		pcall(function()
			wait(5)
			while true do
				pcall(spawn, function()
					spawn(Kill)
				end)
			end
		end)
	end)()
end
local GetEnv
function GetEnv(env, repl)
	local scriptEnv = setmetatable({}, {
		__index = function(tab, ind)
			return locals[ind] or (env or origEnv)[ind]
		end,
		__metatable = unique
	})
	if repl and type(repl) == "table" then
		for ind, val in next, repl, nil do
			scriptEnv[ind] = val
		end
	end
	return scriptEnv
end
local function LoadModule(plugin, yield, envVars)
	local plug = require(plugin)
	if type(plug) == "function" then
		if yield then
			local ran, err = service.TrackTask("Plugin: " .. tostring(plugin), setfenv(plug, GetEnv(getfenv(plug), envVars)))
			if not ran then
				warn("Module encountered an error while loading: " .. tostring(plugin))
				warn(tostring(err))
			end
		else
			local ran, err = service.TrackTask("Thread: Plugin: " .. tostring(plugin), setfenv(plug, GetEnv(getfenv(plug), envVars)))
			if not ran then
				warn("Module encountered an error while loading: " .. tostring(plugin))
				warn(tostring(err))
			end
		end
	else
		client[plugin.Name] = plug
	end
end
client = {
	Handlers = {},
	Modules = {},
	Service = service,
	Module = script,
	Print = print,
	Warn = warn,
	Deps = {},
	Pcall = Pcall,
	cPcall = cPcall,
	Routine = Routine,
	LogError = logError,
	TestEvent = Instance.new("RemoteEvent"),
	Disconnect = function(info)
		service.Player:Kick(info or "Disconnected from server")
		wait(30)
		client.Kill(info)
	end,
	Kill = Kill
}
locals = {
	Pcall = Pcall,
	Folder = Folder,
	GetEnv = GetEnv,
	cPcall = cPcall,
	client = client,
	Routine = Routine,
	service = service,
	logError = logError,
	sortedPairs = sortedPairs,
	origEnv = origEnv
}
service = setfenv(require(script.Parent.Core.Service), GetEnv(nil, {client = client}))(function(eType, msg, desc, ...)
	local extra = {
		...
	}
	if eType == "MethodError" and service.Detected then
		Kill("Shananigans denied")
	elseif eType == "ServerError" then
		logError("Client", msg)
	elseif eType == "ReadError" then
		Kill(tostring(msg))
	end
end, function(c, parent, tab)
	if not isModule(c) and c ~= script and c ~= Folder and parent == nil then
		tab.UnHook()
	end
end, ServiceSpecific)
os = service.Localize(os)
math = service.Localize(math)
table = service.Localize(table)
string = service.Localize(string)
coroutine = service.Localize(coroutine)
Instance = service.Localize(Instance)
Vector2 = service.Localize(Vector2)
Vector3 = service.Localize(Vector3)
CFrame = service.Localize(CFrame)
UDim2 = service.Localize(UDim2)
UDim = service.Localize(UDim)
Ray = service.Localize(Ray)
Rect = service.Localize(Rect)
Faces = service.Localize(Faces)
Color3 = service.Localize(Color3)
NumberRange = service.Localize(NumberRange)
NumberSequence = service.Localize(NumberSequence)
NumberSequenceKeypoint = service.Localize(NumberSequenceKeypoint)
ColorSequenceKeypoint = service.Localize(ColorSequenceKeypoint)
PhysicalProperties = service.Localize(PhysicalProperties)
ColorSequence = service.Localize(ColorSequence)
Region3int16 = service.Localize(Region3int16)
Vector3int16 = service.Localize(Vector3int16)
BrickColor = service.Localize(BrickColor)
TweenInfo = service.Localize(TweenInfo)
Axes = service.Localize(Axes)
for i, val in next, service, nil do
	if type(val) == "userdata" then
		service[i] = service.Wrap(val, true)
	end
end
pcall(function()
	return service.Player.Kick
end)
script = service.Wrap(script, true)
Enum = service.Wrap(Enum, true)
game = service.Wrap(game, true)
rawequal = service.RawEqual
workspace = service.Wrap(workspace, true)
Instance = {
	new = function(obj, parent)
		return service.Wrap(oldInstNew(obj, service.UnWrap(parent)), true)
	end
}
function require(obj)
	return service.Wrap(oldReq(service.UnWrap(obj)), true)
end
client.Service = service
client.Module = service.Wrap(client.Module, true)
for ind, loc in next, {
	_G = _G,
	game = game,
	script = script,
	getfenv = getfenv,
	setfenv = setfenv,
	workspace = workspace,
	getmetatable = getmetatable,
	setmetatable = setmetatable,
	loadstring = loadstring,
	coroutine = coroutine,
	rawequal = rawequal,
	typeof = typeof,
	print = print,
	math = math,
	warn = warn,
	error = error,
	pcall = pcall,
	ypcall = ypcall,
	xpcall = xpcall,
	select = select,
	rawset = rawset,
	rawget = rawget,
	ipairs = ipairs,
	pairs = pairs,
	next = next,
	Rect = Rect,
	Axes = Axes,
	os = os,
	tick = tick,
	Faces = Faces,
	delay = delay,
	unpack = unpack,
	string = string,
	Color3 = Color3,
	newproxy = newproxy,
	tostring = tostring,
	tonumber = tonumber,
	Instance = Instance,
	TweenInfo = TweenInfo,
	BrickColor = BrickColor,
	NumberRange = NumberRange,
	ColorSequence = ColorSequence,
	NumberSequence = NumberSequence,
	ColorSequenceKeypoint = ColorSequenceKeypoint,
	NumberSequenceKeypoint = NumberSequenceKeypoint,
	PhysicalProperties = PhysicalProperties,
	Region3int16 = Region3int16,
	Vector3int16 = Vector3int16,
	elapsedTime = elapsedTime,
	require = require,
	table = table,
	type = type,
	wait = wait,
	Enum = Enum,
	UDim = UDim,
	UDim2 = UDim2,
	Vector2 = Vector2,
	Vector3 = Vector3,
	Region3 = Region3,
	CFrame = CFrame,
	Ray = Ray,
	service = service
}, nil do
	locals[ind] = loc
end
return service.NewProxy({
	__metatable = "Adonis",
	__tostring = function()
		return "Adonis"
	end,
	__call = function(tab, data)
		local folder = script.Parent
		local remoteName, depsName = string.match(data.Name, "(.*)\\(.*)")
		Folder = folder:Clone()
		setfenv(1, setmetatable({}, {__metatable = unique}))
		client.Loader = data.Loader
		client.Module = data.Module
		client.DepsName = depsName
		client.TrueStart = data.Start
		client.LoadingTime = data.LoadingTime
		client.RemoteName = remoteName
		folder:Destroy()
		script:Destroy()
		for ind, serv in next, {
			"Workspace",
			"Players",
			"Lighting",
			"ReplicatedStorage",
			"ReplicatedFirst",
			"ScriptContext",
			"JointsService",
			"LogService",
			"Teams",
			"SoundService",
			"StarterGui",
			"StarterPack",
			"StarterPlayers",
			"TestService",
			"NetworkClient"
		}, nil do
			local temp = service[serv]
		end
		local LoadOrder = {
			"Variables",
			"UI",
			"Core",
			"Remote",
			"Functions",
			"Process",
			"Anti"
		}
		for ind, load in next, LoadOrder, nil do
			local modu = Folder.Core:FindFirstChild(load)
			if modu then
				LoadModule(modu, true, {script = script})
			end
		end
		for i, name in next, LoadOrder, nil do
			local core = client[name]
			if core and type(core) == "table" and core.Init then
				core.Init()
				core.Init = nil
			elseif type(core) == "userdata" and getmetatable(core) == "ReadOnly_Table" and core.Init then
				core.Init()
			end
		end
		for ind, obj in next, Folder.Dependencies:GetChildren() do
			client.Deps[obj.Name] = obj
		end
		for index, plugin in next, Folder.Plugins:GetChildren() do
			LoadModule(plugin, nil, {script = plugin})
		end
		ServiceSpecific.Player = service.Players.LocalPlayer
		ServiceSpecific.PlayerGui = service.Player:FindFirstChild("PlayerGui")
		function ServiceSpecific.SafeTweenSize(obj, ...)
			pcall(obj.TweenSize, obj, ...)
		end
		function ServiceSpecific.SafeTweenPos(obj, ...)
			pcall(obj.TweenPosition, obj, ...)
		end
		function ServiceSpecific.Filter(str, from, to)
			return client.Remote.Get("Filter", str, to and from or service.Player, to or from)
		end
		function ServiceSpecific.LaxFilter(str, from)
			return service.Filter(str, from or service.Player, from or service.Player)
		end
		function ServiceSpecific.BroadcastFilter(str, from)
			return client.Remote.Get("BroadcastFilter", str, from or service.Player)
		end
		function ServiceSpecific.IsMobile()
			if service.UserInputService.TouchEnabled and not service.UserInputService.MouseEnabled and not service.UserInputService.KeyboardEnabled then
				return true
			else
				return false
			end
		end
		function ServiceSpecific.LocalContainer()
			if not client.Variables.LocalContainer or not client.Variables.LocalContainer.Parent then
				client.Variables.LocalContainer = service.New("Camera")
				client.Variables.LocalContainer.Name = client.Functions.GetRandom()
				client.Variables.LocalContainer.Parent = service.Workspace
			end
			return client.Variables.LocalContainer
		end
		function client.Finish_Loading()
			if client.Core.Key then
				service.NetworkClient.ChildRemoved:Connect(function()
					wait(30)
					client.Anti.Detected("crash", "Network client disconnected")
				end)
				service.NetworkClient.ChildAdded:Connect(function()
					client.Anti.Detected("crash", "Network client reconnected?")
				end)
				service.Player.Changed:Connect(function()
					if service.Player.Parent ~= service.Players then
						wait(5)
						client.Anti.Detected("kick", "Parent not players")
					elseif client.Anti.RLocked(service.Player) then
						client.Anti.Detected("kick", "Roblox Locked")
					end
				end)
				service.Player.Chatted:Connect(service.EventTask("Event: ProcessChat", client.Process.Chat))
				service.Player.CharacterRemoving:Connect(service.EventTask("Event: CharacterRemoving", client.Process.CharacterRemoving))
				service.Player.CharacterAdded:Connect(service.Threads.NewEventTask("Event: CharacterAdded", client.Process.CharacterAdded))
				service.LogService.MessageOut:Connect(client.Process.LogService)
				service.ScriptContext.Error:Connect(client.Process.ErrorMessage)
				client.Variables.CodeName = client.Remote.Get("Variable", "CodeName")
				client.Remote.Send("ClientLoaded")
				delay(5, function()
					service.StartLoop("ClientCheck", 30, client.Core.CheckClient, true)
				end)
				local settings = client.Remote.Get("Setting", {
					"G_API",
					"G_Access",
					"G_Access_Key",
					"G_Access_Perms",
					"Allowed_API_Calls"
				})
				client.G_API = settings.G_API
				client.G_Access = settings.G_Access
				client.G_Access_Key = settings.G_Access_Key
				client.G_Access_Perms = settings.G_Access_Perms
				client.Allowed_API_Calls = settings.Allowed_API_Calls
				if service.NetworkClient then
					service.TrackTask("Thread: API Manager", client.Core.StartAPI)
				end
				clientLocked = true
				function client.Finish_Loading()
				end
				client.LoadingTime()
			else
				client.Kill("Missing remote key")
			end
		end
		Fire = client.Remote.Fire
		Detected = client.Anti.Detected
		client.Core.Name = "\000"
		client.Core.Special = depsName
		client = service.ReadOnly(client, {
			[client.Variables] = true,
			[client.Handlers] = true,
			G_API = true,
			G_Access = true,
			G_Access_Key = true,
			G_Access_Perms = true,
			Allowed_API_Calls = true,
			Finish_Loading = true,
			RemoteEvent = true,
			ScriptCache = true,
			Returns = true,
			PendingReturns = true,
			EncodeCache = true,
			DecodeCache = true,
			Received = true,
			Sent = true,
			Service = true,
			Holder = true,
			GUIs = true,
			LastUpdate = true
		}, true)
		client.Core.GetEvent()
		return "SUCCESS"
	end
})
]]></ProtectedString><string name="Name">Client</string></Properties></Item></Item></Item></roblox>